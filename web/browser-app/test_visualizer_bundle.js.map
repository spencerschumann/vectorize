{
  "version": 3,
  "sources": ["../src/formats/binary.ts", "../src/vectorize/tracer.ts", "../src/vectorize/geometry.ts", "../src/vectorize/optimizer.ts", "../src/vectorize/line_fit.ts", "../src/vectorize/arc_fit.ts", "../src/vectorize/simplifier.ts", "test_visualizer.ts"],
  "sourcesContent": ["/**\r\n * Binary image format\r\n * 1 bit per pixel, stored as 8 pixels per byte, MSB-first\r\n */\r\nexport interface BinaryImage {\r\n    width: number;\r\n    height: number;\r\n    data: Uint8Array; // length = ceil(width * height / 8)\r\n}\r\n\r\n/**\r\n * Create an empty binary image\r\n */\r\nexport function createBinaryImage(width: number, height: number): BinaryImage {\r\n    const size = Math.ceil((width * height) / 8);\r\n    return {\r\n        width,\r\n        height,\r\n        data: new Uint8Array(size),\r\n    };\r\n}\r\n\r\n/**\r\n * Get pixel value at (x, y)\r\n * Returns 0 or 1\r\n */\r\nexport function getPixelBin(\r\n    img: BinaryImage,\r\n    x: number,\r\n    y: number,\r\n): 0 | 1 {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 8);\r\n    const bitIndex = 7 - (pixelIndex % 8); // MSB-first\r\n\r\n    return ((img.data[byteIndex] >> bitIndex) & 1) as 0 | 1;\r\n}\r\n\r\n/**\r\n * Set pixel value at (x, y)\r\n * value must be 0 or 1\r\n */\r\nexport function setPixelBin(\r\n    img: BinaryImage,\r\n    x: number,\r\n    y: number,\r\n    value: 0 | 1,\r\n): void {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 8);\r\n    const bitIndex = 7 - (pixelIndex % 8); // MSB-first\r\n\r\n    if (value === 1) {\r\n        img.data[byteIndex] |= 1 << bitIndex;\r\n    } else {\r\n        img.data[byteIndex] &= ~(1 << bitIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Clone a binary image\r\n */\r\nexport function cloneBinaryImage(img: BinaryImage): BinaryImage {\r\n    return {\r\n        width: img.width,\r\n        height: img.height,\r\n        data: new Uint8Array(img.data),\r\n    };\r\n}\r\n", "import { type BinaryImage, getPixelBin } from \"../formats/binary.ts\";\r\nimport type { Point } from \"./geometry.ts\";\r\n\r\nexport interface GraphNode {\r\n  id: number; // pixel ID (y * width + x)\r\n  point: Point;\r\n  edges: number[]; // indices into edges array\r\n}\r\n\r\nexport interface GraphEdge {\r\n  id: number;\r\n  points: Point[]; // Ordered list of pixels in the edge\r\n  nodeA: number; // Node ID at start (-1 if loop)\r\n  nodeB: number; // Node ID at end (-1 if loop)\r\n}\r\n\r\nexport interface Graph {\r\n  nodes: Map<number, GraphNode>;\r\n  edges: GraphEdge[];\r\n}\r\n\r\n/**\r\n * Traces connected paths in a binary image into a graph structure.\r\n * Converts raster pixels into vector paths with topology.\r\n */\r\nexport function traceGraph(binary: BinaryImage): Graph {\r\n  const width = binary.width;\r\n  const height = binary.height;\r\n  const nodes = new Map<number, GraphNode>();\r\n  const edges: GraphEdge[] = [];\r\n  const visitedEdges = new Set<string>(); // Stores \"id1-id2\" for visited edge segments\r\n\r\n  const getVertexId = (x: number, y: number) => y * width + x;\r\n\r\n  const isPixelSet = (x: number, y: number) => {\r\n    if (x < 0 || x >= width || y < 0 || y >= height) return false;\r\n    return getPixelBin(binary, x, y) === 1;\r\n  };\r\n\r\n  const getNeighbors = (x: number, y: number): Point[] => {\r\n    const neighbors: Point[] = [];\r\n\r\n    // Cardinal directions first\r\n    const cardinalOffsets: Point[] = [\r\n      { x: 0, y: -1 },\r\n      { x: 1, y: 0 },\r\n      { x: 0, y: 1 },\r\n      { x: -1, y: 0 },\r\n    ];\r\n\r\n    for (const offset of cardinalOffsets) {\r\n      const nx = x + offset.x;\r\n      const ny = y + offset.y;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        if (isPixelSet(nx, ny)) {\r\n          neighbors.push({ x: nx, y: ny });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Then diagonals (only if no stair-step path exists)\r\n    const diagonalOffsets: Point[] = [\r\n      { x: -1, y: -1 },\r\n      { x: 1, y: -1 },\r\n      { x: -1, y: 1 },\r\n      { x: 1, y: 1 },\r\n    ];\r\n\r\n    for (const offset of diagonalOffsets) {\r\n      const nx = x + offset.x;\r\n      const ny = y + offset.y;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        if (isPixelSet(nx, ny)) {\r\n          // Check if there's a stair-step path to this diagonal\r\n          const hasStairStep = cardinalOffsets.some((cardinal) => {\r\n            const cx = x + cardinal.x;\r\n            const cy = y + cardinal.y;\r\n            if (\r\n              cx >= 0 && cx < width && cy >= 0 && cy < height &&\r\n              isPixelSet(cx, cy)\r\n            ) {\r\n              const dcx = nx - cx;\r\n              const dcy = ny - cy;\r\n              return Math.abs(dcx) + Math.abs(dcy) === 1;\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (!hasStairStep) {\r\n            neighbors.push({ x: nx, y: ny });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return neighbors;\r\n  };\r\n\r\n  // Pass 1: Identify Nodes\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (isPixelSet(x, y)) {\r\n        const neighbors = getNeighbors(x, y);\r\n        // A node is any pixel that is NOT a simple path continuation (degree 2)\r\n        // Degree 0: Isolated point (Node)\r\n        // Degree 1: Endpoint (Node)\r\n        // Degree 3+: Junction (Node)\r\n        if (neighbors.length !== 2) {\r\n          const id = getVertexId(x, y);\r\n          nodes.set(id, {\r\n            id,\r\n            point: { x, y },\r\n            edges: [],\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Helper to get edge key\r\n  const getEdgeKey = (id1: number, id2: number) => {\r\n    return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`;\r\n  };\r\n\r\n  // Pass 2: Trace Edges from Nodes\r\n  for (const node of nodes.values()) {\r\n    const startNeighbors = getNeighbors(node.point.x, node.point.y);\r\n\r\n    for (const neighbor of startNeighbors) {\r\n      const neighborId = getVertexId(neighbor.x, neighbor.y);\r\n      const edgeKey = getEdgeKey(node.id, neighborId);\r\n\r\n      if (visitedEdges.has(edgeKey)) continue;\r\n\r\n      // Start tracing a new edge\r\n      const pathPoints: Point[] = [node.point, neighbor];\r\n      visitedEdges.add(edgeKey);\r\n\r\n      let currentId = neighborId;\r\n      let currentPoint = neighbor;\r\n      let prevId = node.id;\r\n\r\n      while (true) {\r\n        // If current point is a node, we are done\r\n        if (nodes.has(currentId)) {\r\n          const edgeIndex = edges.length;\r\n          const endNode = nodes.get(currentId)!;\r\n\r\n          // Add edge to graph\r\n          edges.push({\r\n            id: edgeIndex,\r\n            points: pathPoints,\r\n            nodeA: node.id,\r\n            nodeB: endNode.id,\r\n          });\r\n\r\n          // Link nodes to edge\r\n          node.edges.push(edgeIndex);\r\n          // Avoid adding duplicate edge reference if startNode == endNode (loop back to self)\r\n          if (node.id !== endNode.id) {\r\n            endNode.edges.push(edgeIndex);\r\n          } else {\r\n            node.edges.push(edgeIndex);\r\n          }\r\n          break;\r\n        }\r\n\r\n        // Continue tracing\r\n        const neighbors = getNeighbors(currentPoint.x, currentPoint.y);\r\n        // Find the neighbor that is NOT the previous one\r\n        const next = neighbors.find((n) => getVertexId(n.x, n.y) !== prevId);\r\n\r\n        if (!next) {\r\n          // Should not happen if logic is correct (degree 2 check)\r\n          // But if it does, treat as endpoint (which should have been a node)\r\n          break;\r\n        }\r\n\r\n        const nextId = getVertexId(next.x, next.y);\r\n        const nextKey = getEdgeKey(currentId, nextId);\r\n\r\n        visitedEdges.add(nextKey);\r\n        pathPoints.push(next);\r\n\r\n        prevId = currentId;\r\n        currentId = nextId;\r\n        currentPoint = next;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Pass 3: Trace Isolated Loops (no nodes)\r\n  // Populate visited pixels from existing edges\r\n  const processedPixels = new Set<number>();\r\n  for (const edge of edges) {\r\n    for (const p of edge.points) {\r\n      processedPixels.add(getVertexId(p.x, p.y));\r\n    }\r\n  }\r\n  for (const node of nodes.values()) {\r\n    processedPixels.add(node.id);\r\n  }\r\n\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      const id = getVertexId(x, y);\r\n      if (isPixelSet(x, y) && !processedPixels.has(id)) {\r\n        // Found a start of a loop\r\n        const pathPoints: Point[] = [{ x, y }];\r\n        processedPixels.add(id);\r\n\r\n        let currentPoint = { x, y };\r\n        let currentId = id;\r\n        let prevId = -1; // No previous for start\r\n\r\n        // Trace forward\r\n        while (true) {\r\n          const neighbors = getNeighbors(currentPoint.x, currentPoint.y);\r\n          let next: Point | undefined;\r\n\r\n          if (prevId === -1) {\r\n            next = neighbors[0]; // Pick any direction\r\n          } else {\r\n            next = neighbors.find((n) => getVertexId(n.x, n.y) !== prevId);\r\n          }\r\n\r\n          if (!next) break; // Should be closed loop\r\n\r\n          const nextId = getVertexId(next.x, next.y);\r\n\r\n          if (nextId === id && prevId !== -1) {\r\n            // Closed the loop\r\n            pathPoints.push(next);\r\n            break;\r\n          }\r\n\r\n          if (processedPixels.has(nextId)) {\r\n            break;\r\n          }\r\n\r\n          processedPixels.add(nextId);\r\n          pathPoints.push(next);\r\n          prevId = currentId;\r\n          currentId = nextId;\r\n          currentPoint = next;\r\n        }\r\n\r\n        const edgeIndex = edges.length;\r\n        edges.push({\r\n          id: edgeIndex,\r\n          points: pathPoints,\r\n          nodeA: -1,\r\n          nodeB: -1,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return { nodes, edges };\r\n}\r\n", "/**\r\n * Core geometric primitives and operations for vectorization\r\n */\r\n\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface Line {\r\n  /** Point on the line */\r\n  point: Point;\r\n  /** Unit direction vector */\r\n  direction: Point;\r\n}\r\n\r\nexport interface Arc {\r\n  center: Point;\r\n  radius: number;\r\n  /** Start angle in radians */\r\n  startAngle: number;\r\n  /** End angle in radians */\r\n  endAngle: number;\r\n  /** True if arc goes clockwise from start to end */\r\n  clockwise: boolean;\r\n}\r\n\r\nexport interface Circle {\r\n  center: Point;\r\n  radius: number;\r\n}\r\n\r\n// ============================================================================\r\n// Point Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate distance between two points\r\n */\r\nexport function distance(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\n/**\r\n * Calculate squared distance (faster when you don't need actual distance)\r\n */\r\nexport function distanceSquared(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Add two points (vector addition)\r\n */\r\nexport function add(p1: Point, p2: Point): Point {\r\n  return { x: p1.x + p2.x, y: p1.y + p2.y };\r\n}\r\n\r\n/**\r\n * Subtract two points (vector subtraction)\r\n */\r\nexport function subtract(p1: Point, p2: Point): Point {\r\n  return { x: p1.x - p2.x, y: p1.y - p2.y };\r\n}\r\n\r\n/**\r\n * Scale a point/vector by a scalar\r\n */\r\nexport function scale(p: Point, s: number): Point {\r\n  return { x: p.x * s, y: p.y * s };\r\n}\r\n\r\n/**\r\n * Calculate dot product of two vectors\r\n */\r\nexport function dot(p1: Point, p2: Point): number {\r\n  return p1.x * p2.x + p1.y * p2.y;\r\n}\r\n\r\n/**\r\n * Calculate cross product magnitude (z-component of 3D cross product)\r\n */\r\nexport function cross(p1: Point, p2: Point): number {\r\n  return p1.x * p2.y - p1.y * p2.x;\r\n}\r\n\r\n/**\r\n * Calculate magnitude (length) of a vector\r\n */\r\nexport function magnitude(p: Point): number {\r\n  return Math.sqrt(p.x * p.x + p.y * p.y);\r\n}\r\n\r\n/**\r\n * Normalize a vector to unit length\r\n */\r\nexport function normalize(p: Point): Point {\r\n  const mag = magnitude(p);\r\n  if (mag < 1e-10) {\r\n    return { x: 0, y: 0 };\r\n  }\r\n  return { x: p.x / mag, y: p.y / mag };\r\n}\r\n\r\n/**\r\n * Calculate angle of a vector in radians (-\u03C0 to \u03C0)\r\n */\r\nexport function angle(p: Point): number {\r\n  return Math.atan2(p.y, p.x);\r\n}\r\n\r\n/**\r\n * Calculate angle between two vectors in radians (0 to \u03C0)\r\n */\r\nexport function angleBetween(p1: Point, p2: Point): number {\r\n  const mag1 = magnitude(p1);\r\n  const mag2 = magnitude(p2);\r\n  if (mag1 < 1e-10 || mag2 < 1e-10) {\r\n    return 0;\r\n  }\r\n  const cosAngle = dot(p1, p2) / (mag1 * mag2);\r\n  // Clamp to handle floating point errors\r\n  return Math.acos(Math.max(-1, Math.min(1, cosAngle)));\r\n}\r\n\r\n/**\r\n * Rotate a point around the origin by an angle in radians\r\n */\r\nexport function rotate(p: Point, angleRad: number): Point {\r\n  const cos = Math.cos(angleRad);\r\n  const sin = Math.sin(angleRad);\r\n  return {\r\n    x: p.x * cos - p.y * sin,\r\n    y: p.x * sin + p.y * cos,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if two points are approximately equal within tolerance\r\n */\r\nexport function pointsEqual(p1: Point, p2: Point, tolerance = 1e-6): boolean {\r\n  return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance;\r\n}\r\n\r\n// ============================================================================\r\n// Line Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Create a line from two points\r\n */\r\nexport function lineFromPoints(p1: Point, p2: Point): Line | null {\r\n  const dir = subtract(p2, p1);\r\n  const mag = magnitude(dir);\r\n  if (mag < 1e-10) {\r\n    return null; // Points are too close\r\n  }\r\n  return {\r\n    point: p1,\r\n    direction: normalize(dir),\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate perpendicular distance from a point to a line\r\n */\r\nexport function distanceToLine(point: Point, line: Line): number {\r\n  const toPoint = subtract(point, line.point);\r\n  // Distance is |toPoint \u00D7 direction| since direction is unit length\r\n  return Math.abs(cross(toPoint, line.direction));\r\n}\r\n\r\n/**\r\n * Project a point onto a line (closest point on line to the given point)\r\n */\r\nexport function projectPointOnLine(point: Point, line: Line): Point {\r\n  const toPoint = subtract(point, line.point);\r\n  const projection = dot(toPoint, line.direction);\r\n  return add(line.point, scale(line.direction, projection));\r\n}\r\n\r\n/**\r\n * Calculate parameter t where point lies on line (line.point + t * line.direction)\r\n */\r\nexport function lineParameter(point: Point, line: Line): number {\r\n  const toPoint = subtract(point, line.point);\r\n  return dot(toPoint, line.direction);\r\n}\r\n\r\n/**\r\n * Find intersection point of two lines\r\n * Returns null if lines are parallel\r\n */\r\nexport function lineLineIntersection(\r\n  line1: Line,\r\n  line2: Line,\r\n  tolerance = 1e-6,\r\n): Point | null {\r\n  const d1 = line1.direction;\r\n  const d2 = line2.direction;\r\n  const crossProduct = cross(d1, d2);\r\n\r\n  // Check if lines are parallel\r\n  if (Math.abs(crossProduct) < tolerance) {\r\n    return null;\r\n  }\r\n\r\n  const diff = subtract(line2.point, line1.point);\r\n  const t = cross(diff, d2) / crossProduct;\r\n\r\n  return add(line1.point, scale(d1, t));\r\n}\r\n\r\n// ============================================================================\r\n// Circle Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate distance from a point to the circle perimeter\r\n * Positive means outside, negative means inside\r\n */\r\nexport function distanceToCircle(point: Point, circle: Circle): number {\r\n  return distance(point, circle.center) - circle.radius;\r\n}\r\n\r\n/**\r\n * Project a point onto a circle (closest point on circle to the given point)\r\n */\r\nexport function projectPointOnCircle(point: Point, circle: Circle): Point {\r\n  const toPoint = subtract(point, circle.center);\r\n  const dir = normalize(toPoint);\r\n  return add(circle.center, scale(dir, circle.radius));\r\n}\r\n\r\n/**\r\n * Calculate angle of a point relative to circle center\r\n */\r\nexport function angleOnCircle(point: Point, circle: Circle): number {\r\n  const toPoint = subtract(point, circle.center);\r\n  return angle(toPoint);\r\n}\r\n\r\n/**\r\n * Find intersection points of a line and a circle\r\n * Returns 0, 1, or 2 intersection points\r\n */\r\nexport function lineCircleIntersection(\r\n  line: Line,\r\n  circle: Circle,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  // Vector from line point to circle center\r\n  const toCenter = subtract(circle.center, line.point);\r\n\r\n  // Project center onto line\r\n  const projection = dot(toCenter, line.direction);\r\n\r\n  // Closest point on line to center\r\n  const closest = add(line.point, scale(line.direction, projection));\r\n\r\n  // Distance from center to line\r\n  const distToLine = distance(circle.center, closest);\r\n\r\n  // No intersection if line is too far from circle\r\n  if (distToLine > circle.radius + tolerance) {\r\n    return [];\r\n  }\r\n\r\n  // Tangent case (1 intersection)\r\n  if (Math.abs(distToLine - circle.radius) < tolerance) {\r\n    return [closest];\r\n  }\r\n\r\n  // Two intersections\r\n  const halfChord = Math.sqrt(\r\n    circle.radius * circle.radius - distToLine * distToLine,\r\n  );\r\n  const offset = scale(line.direction, halfChord);\r\n\r\n  return [\r\n    subtract(closest, offset),\r\n    add(closest, offset),\r\n  ];\r\n}\r\n\r\n/**\r\n * Find intersection points of two circles\r\n * Returns 0, 1, or 2 intersection points\r\n */\r\nexport function circleCircleIntersection(\r\n  c1: Circle,\r\n  c2: Circle,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  const d = distance(c1.center, c2.center);\r\n\r\n  // No intersection if circles are too far apart or one contains the other\r\n  if (\r\n    d > c1.radius + c2.radius + tolerance ||\r\n    d < Math.abs(c1.radius - c2.radius) - tolerance\r\n  ) {\r\n    return [];\r\n  }\r\n\r\n  // Same circle\r\n  if (d < tolerance && Math.abs(c1.radius - c2.radius) < tolerance) {\r\n    return []; // Infinite intersections, return empty\r\n  }\r\n\r\n  // Calculate intersection points\r\n  const a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);\r\n  const h = Math.sqrt(c1.radius * c1.radius - a * a);\r\n\r\n  const toC2 = subtract(c2.center, c1.center);\r\n  const unit = normalize(toC2);\r\n  const midpoint = add(c1.center, scale(unit, a));\r\n\r\n  // Tangent case (1 intersection)\r\n  if (Math.abs(h) < tolerance) {\r\n    return [midpoint];\r\n  }\r\n\r\n  // Perpendicular offset\r\n  const perpendicular = { x: -unit.y, y: unit.x };\r\n  const offset = scale(perpendicular, h);\r\n\r\n  return [\r\n    add(midpoint, offset),\r\n    subtract(midpoint, offset),\r\n  ];\r\n}\r\n\r\n// ============================================================================\r\n// Arc Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Normalize angle to range [-\u03C0, \u03C0]\r\n */\r\nexport function normalizeAngle(angleRad: number): number {\r\n  let normalized = angleRad % (2 * Math.PI);\r\n  if (normalized > Math.PI) normalized -= 2 * Math.PI;\r\n  if (normalized < -Math.PI) normalized += 2 * Math.PI;\r\n  return normalized;\r\n}\r\n\r\n/**\r\n * Calculate sweep angle of an arc\r\n * Always returns positive value\r\n */\r\nexport function arcSweepAngle(arc: Arc): number {\r\n  let sweep = arc.endAngle - arc.startAngle;\r\n  if (arc.clockwise) {\r\n    if (sweep > 0) sweep -= 2 * Math.PI;\r\n    return -sweep;\r\n  } else {\r\n    if (sweep < 0) sweep += 2 * Math.PI;\r\n    return sweep;\r\n  }\r\n}\r\n\r\n/**\r\n * Get point on arc at a specific angle\r\n */\r\nexport function pointOnArc(arc: Arc, angleRad: number): Point {\r\n  return {\r\n    x: arc.center.x + arc.radius * Math.cos(angleRad),\r\n    y: arc.center.y + arc.radius * Math.sin(angleRad),\r\n  };\r\n}\r\n\r\n/**\r\n * Get start point of an arc\r\n */\r\nexport function arcStartPoint(arc: Arc): Point {\r\n  return pointOnArc(arc, arc.startAngle);\r\n}\r\n\r\n/**\r\n * Get end point of an arc\r\n */\r\nexport function arcEndPoint(arc: Arc): Point {\r\n  return pointOnArc(arc, arc.endAngle);\r\n}\r\n\r\n/**\r\n * Check if an angle is within the arc's sweep\r\n */\r\nexport function isAngleInArc(arc: Arc, angleRad: number): boolean {\r\n  const normalized = normalizeAngle(angleRad);\r\n  const start = normalizeAngle(arc.startAngle);\r\n  const end = normalizeAngle(arc.endAngle);\r\n\r\n  if (arc.clockwise) {\r\n    if (start > end) {\r\n      return normalized <= start && normalized >= end;\r\n    } else {\r\n      return normalized <= start || normalized >= end;\r\n    }\r\n  } else {\r\n    if (start < end) {\r\n      return normalized >= start && normalized <= end;\r\n    } else {\r\n      return normalized >= start || normalized <= end;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate perpendicular distance from a point to an arc\r\n * Returns the minimum distance considering the arc's extent\r\n */\r\nexport function distanceToArc(point: Point, arc: Arc): number {\r\n  const angleToPoint = angleOnCircle(point, arc);\r\n\r\n  // If the point projects onto the arc, use circle distance\r\n  if (isAngleInArc(arc, angleToPoint)) {\r\n    return Math.abs(distanceToCircle(point, arc));\r\n  }\r\n\r\n  // Otherwise, use distance to nearest endpoint\r\n  const startPoint = arcStartPoint(arc);\r\n  const endPoint = arcEndPoint(arc);\r\n  return Math.min(\r\n    distance(point, startPoint),\r\n    distance(point, endPoint),\r\n  );\r\n}\r\n\r\n/**\r\n * Find intersection points of a line and an arc\r\n */\r\nexport function lineArcIntersection(\r\n  line: Line,\r\n  arc: Arc,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  // First find line-circle intersections\r\n  const circleIntersections = lineCircleIntersection(line, arc, tolerance);\r\n\r\n  // Filter to only points that lie on the arc\r\n  return circleIntersections.filter((point) => {\r\n    const angleToPoint = angleOnCircle(point, arc);\r\n    return isAngleInArc(arc, angleToPoint);\r\n  });\r\n}\r\n\r\n/**\r\n * Find intersection points of two arcs\r\n */\r\nexport function arcArcIntersection(\r\n  arc1: Arc,\r\n  arc2: Arc,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  // First find circle-circle intersections\r\n  const circleIntersections = circleCircleIntersection(arc1, arc2, tolerance);\r\n\r\n  // Filter to only points that lie on both arcs\r\n  return circleIntersections.filter((point) => {\r\n    const angle1 = angleOnCircle(point, arc1);\r\n    const angle2 = angleOnCircle(point, arc2);\r\n    return isAngleInArc(arc1, angle1) && isAngleInArc(arc2, angle2);\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// 3-Point Arc Operations\r\n// ============================================================================\r\n\r\nexport interface Arc3Point {\r\n  start: Point;\r\n  end: Point;\r\n  mid: Point; // A point on the arc\r\n}\r\n\r\n/**\r\n * Convert 3-point arc to center/radius representation\r\n * Returns null if points are collinear (it's a line, not an arc)\r\n */\r\nexport function arc3PointToArc(arc3: Arc3Point): Arc | null {\r\n  const { start, end, mid } = arc3;\r\n\r\n  // Check for collinearity\r\n  // If area of triangle is 0, they are collinear\r\n  // Area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\r\n  const area = 0.5 * Math.abs(\r\n    start.x * (mid.y - end.y) +\r\n      mid.x * (end.y - start.y) +\r\n      end.x * (start.y - mid.y),\r\n  );\r\n\r\n  if (area < 1e-6) {\r\n    return null;\r\n  }\r\n\r\n  // Find center of circle passing through 3 points\r\n  // Perpendicular bisector of start-mid\r\n  const midStartMid = scale(add(start, mid), 0.5);\r\n  const dirStartMid = subtract(mid, start);\r\n  const perpStartMid = { x: -dirStartMid.y, y: dirStartMid.x };\r\n  const line1 = { point: midStartMid, direction: normalize(perpStartMid) };\r\n\r\n  // Perpendicular bisector of mid-end\r\n  const midMidEnd = scale(add(mid, end), 0.5);\r\n  const dirMidEnd = subtract(end, mid);\r\n  const perpMidEnd = { x: -dirMidEnd.y, y: dirMidEnd.x };\r\n  const line2 = { point: midMidEnd, direction: normalize(perpMidEnd) };\r\n\r\n  const center = lineLineIntersection(line1, line2);\r\n  if (!center) return null; // Should be caught by collinear check\r\n\r\n  const radius = distance(center, start);\r\n  const startAngle = angle(subtract(start, center));\r\n  const endAngle = angle(subtract(end, center));\r\n\r\n  // Determine direction (clockwise or counter-clockwise)\r\n  // Cross product of (mid-start) and (end-mid) tells us the turn direction\r\n  const v1 = subtract(mid, start);\r\n  const v2 = subtract(end, mid);\r\n  const crossProd = cross(v1, v2);\r\n  // In Y-down screen coords:\r\n  // cross > 0 => Right Turn (Clockwise)\r\n  // cross < 0 => Left Turn (Counter-Clockwise)\r\n\r\n  return {\r\n    center,\r\n    radius,\r\n    startAngle,\r\n    endAngle,\r\n    clockwise: crossProd > 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate squared distance from a point to a line segment\r\n */\r\nexport function distancePointToLineSegmentSq(\r\n  p: Point,\r\n  a: Point,\r\n  b: Point,\r\n): number {\r\n  const l2 = distanceSquared(a, b);\r\n  if (l2 === 0) return distanceSquared(p, a);\r\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;\r\n  t = Math.max(0, Math.min(1, t));\r\n  const proj = {\r\n    x: a.x + t * (b.x - a.x),\r\n    y: a.y + t * (b.y - a.y),\r\n  };\r\n  return distanceSquared(p, proj);\r\n}\r\n\r\n/**\r\n * Calculate distance from a point to a line segment\r\n */\r\nexport function distancePointToLineSegment(\r\n  p: Point,\r\n  a: Point,\r\n  b: Point,\r\n): number {\r\n  return Math.sqrt(distancePointToLineSegmentSq(p, a, b));\r\n}\r\n\r\n/**\r\n * Calculate distance from a point to a 3-point arc\r\n */\r\nexport function distancePointToArc3Point(p: Point, arc3: Arc3Point): number {\r\n  const arc = arc3PointToArc(arc3);\r\n  if (!arc) {\r\n    // Treat as line segment\r\n    return distancePointToLineSegment(p, arc3.start, arc3.end);\r\n  }\r\n  return distanceToArc(p, arc);\r\n}\r\n", "import {\r\n  add,\r\n  cross,\r\n  distance,\r\n  dot,\r\n  magnitude,\r\n  normalize,\r\n  type Point,\r\n  scale,\r\n  subtract,\r\n} from \"./geometry.ts\";\r\nimport { type Segment, type SimplifiedEdge } from \"./simplifier.ts\";\r\n\r\n// Configuration\r\nconst CONFIG = {\r\n  LEARNING_RATE: 0.05,\r\n  ITERATIONS: 50,\r\n  SPLIT_THRESHOLD: 0.7, // Max error to trigger split\r\n  MERGE_THRESHOLD: 0.2, // Error increase allowed for merge\r\n  ALIGNMENT_STRENGTH: 1.0, // Weight for axis alignment\r\n  SMOOTHNESS_STRENGTH: 0.2, // Weight for tangent continuity\r\n  FIDELITY_WEIGHT: 1.0,\r\n};\r\n\r\nexport interface OptNode {\r\n  x: number;\r\n  y: number;\r\n  fixed: boolean;\r\n}\r\n\r\nexport interface OptSegment {\r\n  startIdx: number; // Index into nodes array\r\n  endIdx: number; // Index into nodes array\r\n  sagitta: number; // Height of arc (0 = line)\r\n  points: Point[]; // Original pixels\r\n}\r\n\r\nexport function optimizeEdge(\r\n  edge: SimplifiedEdge,\r\n  initialSegments?: Segment[],\r\n  onIteration?: (\r\n    nodes: OptNode[],\r\n    segments: OptSegment[],\r\n    label: string,\r\n  ) => void,\r\n): SimplifiedEdge {\r\n  // 1. Initialize Optimization Model\r\n  let nodes: OptNode[] = [];\r\n  let segments: OptSegment[] = [];\r\n\r\n  // Determine if the edge is a closed loop\r\n  const startP = edge.original.points[0];\r\n  const endP = edge.original.points[edge.original.points.length - 1];\r\n  const isClosed = distance(startP, endP) < 1e-4;\r\n\r\n  if (initialSegments && initialSegments.length > 0) {\r\n    // Initialize from existing segments\r\n    // Add first node\r\n    const firstP = initialSegments[0].start;\r\n    nodes.push({ x: firstP.x, y: firstP.y, fixed: false });\r\n\r\n    for (let i = 0; i < initialSegments.length; i++) {\r\n      const seg = initialSegments[i];\r\n      const endP = seg.end;\r\n\r\n      // Add end node\r\n      // Last node is fixed, intermediate nodes are free\r\n      const isLast = i === initialSegments.length - 1;\r\n      nodes.push({ x: endP.x, y: endP.y, fixed: false });\r\n\r\n      // Use points directly from the segment\r\n      const segmentPoints = seg.points;\r\n\r\n      // Calculate initial sagitta\r\n      let sagitta = 0;\r\n      if (seg.type === \"arc\") {\r\n        // Calculate sagitta from arc parameters\r\n        // s = R - sqrt(R^2 - (L/2)^2)  (for small arcs)\r\n        // or just distance from midpoint of chord to arc center minus radius?\r\n        // Sagitta is signed distance from chord to arc.\r\n\r\n        const chord = subtract(seg.end, seg.start);\r\n        const chordLen = magnitude(chord);\r\n        const midChord = scale(add(seg.start, seg.end), 0.5);\r\n\r\n        // Vector from midChord to center\r\n        const toCenter = subtract(seg.arc.center, midChord);\r\n        const distToCenter = magnitude(toCenter);\r\n\r\n        // Check if center is on the \"left\" or \"right\" of the chord\r\n        // Cross product of chord and toCenter\r\n        const cp = cross(chord, toCenter);\r\n\r\n        // If arc is \"small\" (less than semicircle), sagitta has same sign as cross product?\r\n        // Let's use the convention: sagitta is positive if arc is to the \"left\" of chord vector?\r\n        // Our optimizer uses: center = midChord + (R-|s|) * (-sign(s)*normal)\r\n        // where normal = (-dy, dx) / L.\r\n\r\n        // Let's just estimate it numerically from the midpoint of the arc\r\n        const midAngle = (seg.arc.startAngle + seg.arc.endAngle) / 2; // Careful with wrapping\r\n        // Better: use the midpoint of the segment points\r\n        if (segmentPoints.length > 0) {\r\n          const midIdx = Math.floor(segmentPoints.length / 2);\r\n          const pMid = segmentPoints[midIdx];\r\n          // Distance from pMid to chord\r\n          const d = Math.sqrt(\r\n            distancePointToLineSegmentSq(pMid, seg.start, seg.end),\r\n          );\r\n\r\n          // Determine sign\r\n          const normal = { x: chord.y, y: -chord.x };\r\n          const toP = subtract(pMid, seg.start);\r\n          const dotN = dot(toP, normal);\r\n          sagitta = d * (dotN > 0 ? 1 : -1);\r\n        }\r\n      }\r\n\r\n      segments.push({\r\n        startIdx: i,\r\n        endIdx: i + 1,\r\n        sagitta: sagitta,\r\n        points: segmentPoints,\r\n      });\r\n    }\r\n  } else {\r\n    // Create initial single segment\r\n    const startP = edge.original.points[0];\r\n    const endP = edge.original.points[edge.original.points.length - 1];\r\n\r\n    nodes.push({ x: startP.x, y: startP.y, fixed: false });\r\n    nodes.push({ x: endP.x, y: endP.y, fixed: false });\r\n\r\n    segments.push({\r\n      startIdx: 0,\r\n      endIdx: 1,\r\n      sagitta: 0,\r\n      points: edge.original.points,\r\n    });\r\n  }\r\n\r\n  if (onIteration) {\r\n    onIteration(\r\n      JSON.parse(JSON.stringify(nodes)),\r\n      JSON.parse(JSON.stringify(segments)),\r\n      \"Initial\",\r\n    );\r\n  }\r\n\r\n  // 2. Iterative Refinement Loop\r\n  let changed = true;\r\n  let loopCount = 0;\r\n\r\n  while (changed && loopCount < 5) {\r\n    changed = false;\r\n    loopCount++;\r\n\r\n    // A. Optimize Parameters (Gradient Descent)\r\n    optimizeParameters(nodes, segments, isClosed);\r\n    if (onIteration) {\r\n      onIteration(\r\n        JSON.parse(JSON.stringify(nodes)),\r\n        JSON.parse(JSON.stringify(segments)),\r\n        `Iteration ${loopCount} - Optimized`,\r\n      );\r\n    } // B. Split Pass\r\n    const newSegments: OptSegment[] = [];\r\n    let splitOccurred = false;\r\n\r\n    for (const seg of segments) {\r\n      const maxErr = getMaxError(seg, nodes);\r\n      if (maxErr > CONFIG.SPLIT_THRESHOLD && seg.points.length > 4) {\r\n        // Split at max error point\r\n        const splitRes = splitSegment(seg, nodes);\r\n        newSegments.push(splitRes.left);\r\n        newSegments.push(splitRes.right);\r\n        splitOccurred = true;\r\n        changed = true;\r\n      } else {\r\n        newSegments.push(seg);\r\n      }\r\n    }\r\n    segments = newSegments;\r\n\r\n    if (splitOccurred) {\r\n      if (onIteration) {\r\n        onIteration(\r\n          JSON.parse(JSON.stringify(nodes)),\r\n          JSON.parse(JSON.stringify(segments)),\r\n          `Iteration ${loopCount} - Split`,\r\n        );\r\n      }\r\n      // Re-optimize after split\r\n      optimizeParameters(nodes, segments, isClosed);\r\n      if (onIteration) {\r\n        onIteration(\r\n          JSON.parse(JSON.stringify(nodes)),\r\n          JSON.parse(JSON.stringify(segments)),\r\n          `Iteration ${loopCount} - Re-optimized`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // C. Merge Pass (TODO: Implement if needed, for now split-only + optimize is powerful)\r\n    // Merging is tricky with the node indices.\r\n    // For the L-shape case, splitting is the key.\r\n    // Merging helps if we over-split.\r\n  }\r\n\r\n  // Final Polish\r\n  optimizeParameters(nodes, segments, isClosed);\r\n  if (onIteration) {\r\n    onIteration(\r\n      JSON.parse(JSON.stringify(nodes)),\r\n      JSON.parse(JSON.stringify(segments)),\r\n      \"Final\",\r\n    );\r\n  }\r\n\r\n  return {\r\n    original: edge.original,\r\n    segments: convertToSegments(nodes, segments),\r\n  };\r\n}\r\n\r\nfunction optimizeParameters(\r\n  nodes: OptNode[],\r\n  segments: OptSegment[],\r\n  isClosed: boolean = false,\r\n) {\r\n  for (let iter = 0; iter < CONFIG.ITERATIONS; iter++) {\r\n    // Calculate Gradients\r\n    const nodeGrads = nodes.map(() => ({ x: 0, y: 0 }));\r\n    const sagittaGrads = segments.map(() => 0);\r\n\r\n    // 1. Fidelity Gradients\r\n    for (let i = 0; i < segments.length; i++) {\r\n      const seg = segments[i];\r\n      const pStart = nodes[seg.startIdx];\r\n      const pEnd = nodes[seg.endIdx];\r\n\r\n      // Numerical gradient for sagitta\r\n      const h = 0.1;\r\n      const errBase = getSegmentError(seg, pStart, pEnd, seg.sagitta);\r\n      const errPlus = getSegmentError(seg, pStart, pEnd, seg.sagitta + h);\r\n      sagittaGrads[i] += (errPlus - errBase) / h * CONFIG.FIDELITY_WEIGHT;\r\n\r\n      // Numerical gradient for nodes (if not fixed)\r\n      if (!pStart.fixed) {\r\n        const pStartX = { ...pStart, x: pStart.x + h };\r\n        const errX = getSegmentError(seg, pStartX, pEnd, seg.sagitta);\r\n        nodeGrads[seg.startIdx].x += (errX - errBase) / h *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n\r\n        const pStartY = { ...pStart, y: pStart.y + h };\r\n        const errY = getSegmentError(seg, pStartY, pEnd, seg.sagitta);\r\n        nodeGrads[seg.startIdx].y += (errY - errBase) / h *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n      }\r\n\r\n      if (!pEnd.fixed) {\r\n        const pEndX = { ...pEnd, x: pEnd.x + h };\r\n        const errX = getSegmentError(seg, pStart, pEndX, seg.sagitta);\r\n        nodeGrads[seg.endIdx].x += (errX - errBase) / h *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n\r\n        const pEndY = { ...pEnd, y: pEnd.y + h };\r\n        const errY = getSegmentError(seg, pStart, pEndY, seg.sagitta);\r\n        nodeGrads[seg.endIdx].y += (errY - errBase) / h *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n      }\r\n    }\r\n\r\n    // 2. Alignment Gradients (Axis snapping)\r\n    for (let i = 0; i < segments.length; i++) {\r\n      const seg = segments[i];\r\n      const pStart = nodes[seg.startIdx];\r\n      const pEnd = nodes[seg.endIdx];\r\n      const h = 0.1;\r\n\r\n      // Only apply if sagitta is small (line-like)\r\n      if (Math.abs(seg.sagitta) < 1.0) {\r\n        const dx = pEnd.x - pStart.x;\r\n        const dy = pEnd.y - pStart.y;\r\n        const len = Math.sqrt(dx * dx + dy * dy);\r\n        if (len > 1e-4) {\r\n          // Cost = sin^2(2*angle) ? No, we want 0, 90, 180, 270.\r\n          // sin(angle) is 0 at 0, 180. cos(angle) is 0 at 90, 270.\r\n          // Cost = (dx/len)^2 * (dy/len)^2  <-- 0 if horizontal (dy=0) or vertical (dx=0)\r\n          // This is sin^2 * cos^2 = (1/4)sin^2(2*theta)\r\n\r\n          // Let's use numerical gradient for simplicity\r\n          const costBase = alignmentCost(pStart, pEnd);\r\n\r\n          if (!pStart.fixed) {\r\n            const costX = alignmentCost({ ...pStart, x: pStart.x + h }, pEnd);\r\n            nodeGrads[seg.startIdx].x += (costX - costBase) / h *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n            const costY = alignmentCost({ ...pStart, y: pStart.y + h }, pEnd);\r\n            nodeGrads[seg.startIdx].y += (costY - costBase) / h *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n          }\r\n          if (!pEnd.fixed) {\r\n            const costX = alignmentCost(pStart, { ...pEnd, x: pEnd.x + h });\r\n            nodeGrads[seg.endIdx].x += (costX - costBase) / h *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n            const costY = alignmentCost(pStart, { ...pEnd, y: pEnd.y + h });\r\n            nodeGrads[seg.endIdx].y += (costY - costBase) / h *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sync gradients for closed loops\r\n    if (isClosed && nodes.length > 1) {\r\n      const last = nodes.length - 1;\r\n      const gx = (nodeGrads[0].x + nodeGrads[last].x) / 2; // Average? Or sum?\r\n      // If we treat them as one node, the gradient is the sum of forces on that node.\r\n      // But we apply it to two nodes.\r\n      // If we sum, we get double the force if we apply to both?\r\n      // No, if they are the same node, the total force is sum.\r\n      // And we move that one node by learning_rate * sum.\r\n      // Here we have two nodes. If we move both by learning_rate * sum, it's correct.\r\n      const sumX = nodeGrads[0].x + nodeGrads[last].x;\r\n      const sumY = nodeGrads[0].y + nodeGrads[last].y;\r\n      nodeGrads[0].x = sumX;\r\n      nodeGrads[0].y = sumY;\r\n      nodeGrads[last].x = sumX;\r\n      nodeGrads[last].y = sumY;\r\n    }\r\n\r\n    // Apply Gradients\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      if (!nodes[i].fixed) {\r\n        nodes[i].x -= nodeGrads[i].x * CONFIG.LEARNING_RATE;\r\n        nodes[i].y -= nodeGrads[i].y * CONFIG.LEARNING_RATE;\r\n      }\r\n    }\r\n    \r\n    // Sync positions for closed loops (to correct any drift)\r\n    if (isClosed && nodes.length > 1) {\r\n      const last = nodes.length - 1;\r\n      const avgX = (nodes[0].x + nodes[last].x) / 2;\r\n      const avgY = (nodes[0].y + nodes[last].y) / 2;\r\n      nodes[0].x = avgX;\r\n      nodes[0].y = avgY;\r\n      nodes[last].x = avgX;\r\n      nodes[last].y = avgY;\r\n    }\r\n\r\n    for (let i = 0; i < segments.length; i++) {\r\n      segments[i].sagitta -= sagittaGrads[i] * CONFIG.LEARNING_RATE;\r\n\r\n      // Limit sagitta to half chord length (180 degrees max)\r\n      const start = nodes[segments[i].startIdx];\r\n      const end = nodes[segments[i].endIdx];\r\n      const chordLen = distance(start, end);\r\n      const maxSagitta = chordLen / 2 * 0.9999; // Slightly less than half to avoid singularity\r\n\r\n      if (segments[i].sagitta > maxSagitta) segments[i].sagitta = maxSagitta;\r\n      if (segments[i].sagitta < -maxSagitta) segments[i].sagitta = -maxSagitta;\r\n    }\r\n  }\r\n}\r\n\r\nfunction alignmentCost(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  const lenSq = dx * dx + dy * dy;\r\n  if (lenSq < 1e-6) return 0;\r\n  // (dx*dy / lenSq)^2 is minimized when dx=0 or dy=0\r\n  return Math.pow((dx * dy) / lenSq, 2) * 100; // Scale up\r\n}\r\n\r\nfunction getSegmentError(\r\n  seg: OptSegment,\r\n  start: Point,\r\n  end: Point,\r\n  sagitta: number,\r\n): number {\r\n  let error = 0;\r\n  // Pre-calculate arc parameters\r\n  const chord = subtract(end, start);\r\n  const chordLen = magnitude(chord);\r\n  if (chordLen < 1e-6) return 0;\r\n\r\n  const midChord = scale(add(start, end), 0.5);\r\n  const normal = { x: chord.y / chordLen, y: -chord.x / chordLen };\r\n  const arcMid = add(midChord, scale(normal, sagitta));\r\n\r\n  // If sagitta is small, use line distance\r\n  if (Math.abs(sagitta) < 0.1) {\r\n    for (const p of seg.points) {\r\n      error += distancePointToLineSegmentSq(p, start, end);\r\n    }\r\n  } else {\r\n    // Arc distance\r\n    // Find center and radius\r\n    // R^2 = (L/2)^2 + (R-s)^2  => R^2 = L^2/4 + R^2 - 2Rs + s^2 => 2Rs = L^2/4 + s^2 => R = (L^2/4 + s^2) / (2s)\r\n    const R = (Math.pow(chordLen / 2, 2) + sagitta * sagitta) /\r\n      (2 * Math.abs(sagitta));\r\n    const centerDist = R - Math.abs(sagitta); // Distance from chord to center\r\n    // Center is along normal direction (flipped if sagitta < 0?)\r\n    // If sagitta > 0, center is \"below\" chord (away from arcMid).\r\n    // Wait, if sagitta > 0, arcMid is at +s*normal. Center is at (R-s)*(-normal) ?\r\n    // Let's use geometric construction.\r\n    // Center is at midChord + (R - |s|) * (-sign(s) * normal)\r\n    const center = add(\r\n      midChord,\r\n      scale(normal, (R - Math.abs(sagitta)) * (sagitta > 0 ? -1 : 1)),\r\n    );\r\n\r\n    for (const p of seg.points) {\r\n      const d = Math.abs(distance(p, center) - R);\r\n      error += d * d;\r\n    }\r\n  }\r\n  return error;\r\n}\r\n\r\nfunction getMaxError(seg: OptSegment, nodes: OptNode[]): number {\r\n  const start = nodes[seg.startIdx];\r\n  const end = nodes[seg.endIdx];\r\n  let maxErr = 0;\r\n\r\n  // Re-calculate geometry\r\n  const chord = subtract(end, start);\r\n  const chordLen = magnitude(chord);\r\n  if (chordLen < 1e-6) return 0;\r\n\r\n  const midChord = scale(add(start, end), 0.5);\r\n  const normal = { x: chord.y / chordLen, y: -chord.x / chordLen };\r\n\r\n  if (Math.abs(seg.sagitta) < 0.1) {\r\n    for (const p of seg.points) {\r\n      const d = Math.sqrt(distancePointToLineSegmentSq(p, start, end));\r\n      if (d > maxErr) maxErr = d;\r\n    }\r\n  } else {\r\n    const R = (Math.pow(chordLen / 2, 2) + seg.sagitta * seg.sagitta) /\r\n      (2 * Math.abs(seg.sagitta));\r\n    const center = add(\r\n      midChord,\r\n      scale(normal, (R - Math.abs(seg.sagitta)) * (seg.sagitta > 0 ? -1 : 1)),\r\n    );\r\n    for (const p of seg.points) {\r\n      const d = Math.abs(distance(p, center) - R);\r\n      if (d > maxErr) maxErr = d;\r\n    }\r\n  }\r\n  return maxErr;\r\n}\r\n\r\nfunction splitSegment(\r\n  seg: OptSegment,\r\n  nodes: OptNode[],\r\n): { left: OptSegment; right: OptSegment } {\r\n  // Find split point (max error point)\r\n  const start = nodes[seg.startIdx];\r\n  const end = nodes[seg.endIdx];\r\n  let maxErr = -1;\r\n  let splitIdx = -1;\r\n\r\n  // Re-calculate geometry for distance check\r\n  const chord = subtract(end, start);\r\n  const chordLen = magnitude(chord);\r\n  const midChord = scale(add(start, end), 0.5);\r\n  const normal = { x: chord.y / chordLen, y: -chord.x / chordLen };\r\n  let center = { x: 0, y: 0 };\r\n  let R = 0;\r\n  const isLine = Math.abs(seg.sagitta) < 0.1;\r\n\r\n  if (!isLine) {\r\n    R = (Math.pow(chordLen / 2, 2) + seg.sagitta * seg.sagitta) /\r\n      (2 * Math.abs(seg.sagitta));\r\n    center = add(\r\n      midChord,\r\n      scale(normal, (R - Math.abs(seg.sagitta)) * (seg.sagitta > 0 ? -1 : 1)),\r\n    );\r\n  }\r\n\r\n  for (let i = 0; i < seg.points.length; i++) {\r\n    const p = seg.points[i];\r\n    let d = 0;\r\n    if (isLine) {\r\n      d = Math.sqrt(distancePointToLineSegmentSq(p, start, end));\r\n    } else {\r\n      d = Math.abs(distance(p, center) - R);\r\n    }\r\n\r\n    if (d > maxErr) {\r\n      maxErr = d;\r\n      splitIdx = i;\r\n    }\r\n  }\r\n\r\n  // Create new node\r\n  const splitPoint = seg.points[splitIdx];\r\n  const newNodeIdx = nodes.length;\r\n  nodes.push({ x: splitPoint.x, y: splitPoint.y, fixed: false });\r\n\r\n  const leftPoints = seg.points.slice(0, splitIdx + 1);\r\n  const rightPoints = seg.points.slice(splitIdx);\r\n\r\n  return {\r\n    left: {\r\n      startIdx: seg.startIdx,\r\n      endIdx: newNodeIdx,\r\n      sagitta: seg.sagitta / 2, // Initial guess\r\n      points: leftPoints,\r\n    },\r\n    right: {\r\n      startIdx: newNodeIdx,\r\n      endIdx: seg.endIdx,\r\n      sagitta: seg.sagitta / 2, // Initial guess\r\n      points: rightPoints,\r\n    },\r\n  };\r\n}\r\n\r\nfunction distancePointToLineSegmentSq(p: Point, a: Point, b: Point): number {\r\n  const l2 = distanceSquared(a, b);\r\n  if (l2 === 0) return distanceSquared(p, a);\r\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;\r\n  t = Math.max(0, Math.min(1, t));\r\n  const proj = {\r\n    x: a.x + t * (b.x - a.x),\r\n    y: a.y + t * (b.y - a.y),\r\n  };\r\n  return distanceSquared(p, proj);\r\n}\r\n\r\nfunction distanceSquared(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\nexport function convertToSegments(\r\n  nodes: OptNode[],\r\n  optSegments: OptSegment[],\r\n): Segment[] {\r\n  return optSegments.map((seg) => {\r\n    const start = nodes[seg.startIdx];\r\n    const end = nodes[seg.endIdx];\r\n\r\n    if (Math.abs(seg.sagitta) < 1.0) {\r\n      return {\r\n        type: \"line\",\r\n        start: { x: start.x, y: start.y },\r\n        end: { x: end.x, y: end.y },\r\n        points: seg.points,\r\n        line: {\r\n          point: { x: start.x, y: start.y },\r\n          direction: normalize(subtract(end, start)),\r\n        },\r\n      };\r\n    } else {\r\n      // Convert to Arc\r\n      const chord = subtract(end, start);\r\n      const chordLen = magnitude(chord);\r\n\r\n      if (chordLen < 1e-6) {\r\n        // Fallback to line (point) to avoid NaN if start ~= end\r\n        return {\r\n          type: \"line\",\r\n          start: { x: start.x, y: start.y },\r\n          end: { x: end.x, y: end.y },\r\n          points: seg.points,\r\n          line: {\r\n            point: { x: start.x, y: start.y },\r\n            direction: { x: 1, y: 0 },\r\n          },\r\n        };\r\n      }\r\n\r\n      const R = (Math.pow(chordLen / 2, 2) + seg.sagitta * seg.sagitta) /\r\n        (2 * Math.abs(seg.sagitta));\r\n      const midChord = scale(add(start, end), 0.5);\r\n      const normal = { x: chord.y / chordLen, y: -chord.x / chordLen };\r\n      const center = add(\r\n        midChord,\r\n        scale(normal, (R - Math.abs(seg.sagitta)) * (seg.sagitta > 0 ? -1 : 1)),\r\n      );\r\n\r\n      // Calculate angles\r\n      const startAngle = Math.atan2(start.y - center.y, start.x - center.x);\r\n      const endAngle = Math.atan2(end.y - center.y, end.x - center.x);\r\n\r\n      return {\r\n        type: \"arc\",\r\n        start: { x: start.x, y: start.y },\r\n        end: { x: end.x, y: end.y },\r\n        points: seg.points,\r\n        arc: {\r\n          center,\r\n          radius: R,\r\n          startAngle,\r\n          endAngle,\r\n          clockwise: seg.sagitta > 0, // Convention: positive sagitta = CW (Bulge Right relative to chord)\r\n        },\r\n      };\r\n    }\r\n  });\r\n}\r\n", "/**\r\n * Line fitting using Total Least Squares (TLS)\r\n * Minimizes perpendicular distance from points to the fitted line\r\n */\r\n\r\nimport type { Line, Point } from \"./geometry.ts\";\r\nimport { normalize } from \"./geometry.ts\";\r\n\r\nexport interface LineFitResult {\r\n  /** The fitted line */\r\n  line: Line;\r\n  /** Root mean square error (perpendicular distance) */\r\n  rmsError: number;\r\n  /** Median error */\r\n  medianError: number;\r\n  /** Number of points in the fit */\r\n  count: number;\r\n  /** Individual errors for each point */\r\n  errors: number[];\r\n}\r\n\r\n/**\r\n * Fit a line to a set of points using Total Least Squares\r\n * Returns null if fewer than 2 points or points are degenerate\r\n */\r\nexport function fitLine(points: Point[]): LineFitResult | null {\r\n  if (points.length < 2) {\r\n    return null;\r\n  }\r\n\r\n  // Calculate centroid\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  for (const p of points) {\r\n    sumX += p.x;\r\n    sumY += p.y;\r\n  }\r\n  const centroid = {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length,\r\n  };\r\n\r\n  // Calculate covariance matrix\r\n  let covXX = 0;\r\n  let covYY = 0;\r\n  let covXY = 0;\r\n  for (const p of points) {\r\n    const dx = p.x - centroid.x;\r\n    const dy = p.y - centroid.y;\r\n    covXX += dx * dx;\r\n    covYY += dy * dy;\r\n    covXY += dx * dy;\r\n  }\r\n\r\n  // Find principal component (eigenvector of largest eigenvalue)\r\n  // For 2x2 matrix: lambda = (trace \u00B1 sqrt(trace\u00B2 - 4*det)) / 2\r\n  const trace = covXX + covYY;\r\n  const det = covXX * covYY - covXY * covXY;\r\n  const discriminant = trace * trace - 4 * det;\r\n\r\n  if (discriminant < 0 || trace < 1e-10) {\r\n    // Degenerate case: all points are at the same location\r\n    return null;\r\n  }\r\n\r\n  const lambda1 = (trace + Math.sqrt(discriminant)) / 2;\r\n\r\n  // Eigenvector corresponding to lambda1\r\n  let direction: Point;\r\n  if (Math.abs(covXY) > 1e-10) {\r\n    direction = normalize({ x: lambda1 - covYY, y: covXY });\r\n  } else if (covXX > covYY) {\r\n    direction = { x: 1, y: 0 };\r\n  } else {\r\n    direction = { x: 0, y: 1 };\r\n  }\r\n\r\n  const line: Line = {\r\n    point: centroid,\r\n    direction,\r\n  };\r\n\r\n  // Calculate errors\r\n  const errors = points.map((p) => {\r\n    const dx = p.x - centroid.x;\r\n    const dy = p.y - centroid.y;\r\n    // Perpendicular distance: |cross product| with unit direction\r\n    return Math.abs(dx * direction.y - dy * direction.x);\r\n  });\r\n\r\n  // Calculate RMS error\r\n  const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n  const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n  // Calculate median error\r\n  const sortedErrors = [...errors].sort((a, b) => a - b);\r\n  const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n  return {\r\n    line,\r\n    rmsError,\r\n    medianError,\r\n    count: points.length,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Incremental line fitting for online algorithms\r\n * Allows adding points one at a time and updating the fit efficiently\r\n */\r\nexport class IncrementalLineFit {\r\n  private n = 0;\r\n  private sumX = 0;\r\n  private sumY = 0;\r\n  private sumXX = 0;\r\n  private sumYY = 0;\r\n  private sumXY = 0;\r\n  private points: Point[] = [];\r\n\r\n  /**\r\n   * Add a point to the fit\r\n   */\r\n  addPoint(p: Point): void {\r\n    this.n++;\r\n    this.sumX += p.x;\r\n    this.sumY += p.y;\r\n    this.sumXX += p.x * p.x;\r\n    this.sumYY += p.y * p.y;\r\n    this.sumXY += p.x * p.y;\r\n    this.points.push(p);\r\n  }\r\n\r\n  /**\r\n   * Get the number of points in the fit\r\n   */\r\n  getCount(): number {\r\n    return this.n;\r\n  }\r\n\r\n  /**\r\n   * Get all points in the fit\r\n   */\r\n  getPoints(): Point[] {\r\n    return [...this.points];\r\n  }\r\n\r\n  /**\r\n   * Get the current fit result\r\n   * Returns null if fewer than 2 points\r\n   */\r\n  getFit(): LineFitResult | null {\r\n    if (this.n < 2) {\r\n      return null;\r\n    }\r\n\r\n    // Calculate centroid\r\n    const centroid = {\r\n      x: this.sumX / this.n,\r\n      y: this.sumY / this.n,\r\n    };\r\n\r\n    // Calculate covariance matrix components\r\n    const covXX = this.sumXX - this.sumX * this.sumX / this.n;\r\n    const covYY = this.sumYY - this.sumY * this.sumY / this.n;\r\n    const covXY = this.sumXY - this.sumX * this.sumY / this.n;\r\n\r\n    // Find principal component\r\n    const trace = covXX + covYY;\r\n    const det = covXX * covYY - covXY * covXY;\r\n    const discriminant = trace * trace - 4 * det;\r\n\r\n    if (discriminant < 0 || trace < 1e-10) {\r\n      return null;\r\n    }\r\n\r\n    const lambda1 = (trace + Math.sqrt(discriminant)) / 2;\r\n\r\n    // Eigenvector\r\n    let direction: Point;\r\n    if (Math.abs(covXY) > 1e-10) {\r\n      direction = normalize({ x: lambda1 - covYY, y: covXY });\r\n    } else if (covXX > covYY) {\r\n      direction = { x: 1, y: 0 };\r\n    } else {\r\n      direction = { x: 0, y: 1 };\r\n    }\r\n\r\n    const line: Line = {\r\n      point: centroid,\r\n      direction,\r\n    };\r\n\r\n    // Calculate errors\r\n    const errors = this.points.map((p) => {\r\n      const dx = p.x - centroid.x;\r\n      const dy = p.y - centroid.y;\r\n      return Math.abs(dx * direction.y - dy * direction.x);\r\n    });\r\n\r\n    const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n    const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n    const sortedErrors = [...errors].sort((a, b) => a - b);\r\n    const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n    return {\r\n      line,\r\n      rmsError,\r\n      medianError,\r\n      count: this.n,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the fit to start over\r\n   */\r\n  reset(): void {\r\n    this.n = 0;\r\n    this.sumX = 0;\r\n    this.sumY = 0;\r\n    this.sumXX = 0;\r\n    this.sumYY = 0;\r\n    this.sumXY = 0;\r\n    this.points = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile of errors\r\n */\r\nexport function percentile(values: number[], p: number): number {\r\n  if (values.length === 0) return 0;\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const index = Math.floor(sorted.length * p);\r\n  return sorted[Math.min(index, sorted.length - 1)];\r\n}\r\n", "/**\r\n * Arc (circle) fitting using algebraic distance minimization\r\n * Minimizes the algebraic distance from points to the fitted circle\r\n */\r\n\r\nimport type { Circle, Point } from \"./geometry.ts\";\r\nimport { distance } from \"./geometry.ts\";\r\n\r\nexport interface ArcFitResult {\r\n  /** The fitted circle */\r\n  circle: Circle;\r\n  /** Root mean square error (radial distance) */\r\n  rmsError: number;\r\n  /** Median error */\r\n  medianError: number;\r\n  /** Number of points in the fit */\r\n  count: number;\r\n  /** Individual errors for each point */\r\n  errors: number[];\r\n  /** Start angle of the arc in radians */\r\n  startAngle: number;\r\n  /** End angle of the arc in radians */\r\n  endAngle: number;\r\n  /** Sweep angle in radians */\r\n  sweepAngle: number;\r\n  /** True if arc is clockwise */\r\n  clockwise: boolean;\r\n}\r\n\r\n/**\r\n * Fit a circle to a set of points using algebraic fitting\r\n * Returns null if fewer than 3 points or fit is degenerate\r\n */\r\nexport function fitCircle(points: Point[]): ArcFitResult | null {\r\n  if (points.length < 3) {\r\n    return null;\r\n  }\r\n\r\n  // Use algebraic circle fitting (Pratt method)\r\n  // Minimizes algebraic distance: (x-cx)\u00B2 + (y-cy)\u00B2 - r\u00B2\r\n\r\n  const n = points.length;\r\n\r\n  // Calculate means\r\n  let meanX = 0;\r\n  let meanY = 0;\r\n  for (const p of points) {\r\n    meanX += p.x;\r\n    meanY += p.y;\r\n  }\r\n  meanX /= n;\r\n  meanY /= n;\r\n\r\n  // Build moment matrix\r\n  let Mxx = 0, Mxy = 0, Myy = 0;\r\n  let Mxz = 0, Myz = 0;\r\n  let Mzz = 0;\r\n\r\n  for (const p of points) {\r\n    const x = p.x - meanX;\r\n    const y = p.y - meanY;\r\n    const z = x * x + y * y;\r\n\r\n    Mxx += x * x;\r\n    Mxy += x * y;\r\n    Myy += y * y;\r\n    Mxz += x * z;\r\n    Myz += y * z;\r\n    Mzz += z * z;\r\n  }\r\n\r\n  Mxx /= n;\r\n  Mxy /= n;\r\n  Myy /= n;\r\n  Mxz /= n;\r\n  Myz /= n;\r\n  Mzz /= n;\r\n\r\n  // Solve for center offset\r\n  const det = Mxx * Myy - Mxy * Mxy;\r\n  if (Math.abs(det) < 1e-10) {\r\n    return null; // Degenerate case\r\n  }\r\n\r\n  const cx = (Mxz * Myy - Myz * Mxy) / det;\r\n  const cy = (Myz * Mxx - Mxz * Mxy) / det;\r\n\r\n  const center = {\r\n    x: cx + meanX,\r\n    y: cy + meanY,\r\n  };\r\n\r\n  // Calculate radius\r\n  const radiusSquared = cx * cx + cy * cy + (Mxx + Myy);\r\n  if (radiusSquared <= 0) {\r\n    return null; // Invalid circle\r\n  }\r\n  const radius = Math.sqrt(radiusSquared);\r\n\r\n  const circle: Circle = { center, radius };\r\n\r\n  // Calculate errors (radial distance from circle)\r\n  const errors = points.map((p) => Math.abs(distance(p, center) - radius));\r\n\r\n  const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n  const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n  const sortedErrors = [...errors].sort((a, b) => a - b);\r\n  const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n  // Calculate arc parameters\r\n  const angles = points.map((p) => Math.atan2(p.y - center.y, p.x - center.x));\r\n  const startAngle = angles[0];\r\n  const endAngle = angles[angles.length - 1];\r\n\r\n  // Determine if arc is clockwise by checking angle progression\r\n  let totalTurn = 0;\r\n  for (let i = 1; i < angles.length; i++) {\r\n    let delta = angles[i] - angles[i - 1];\r\n    // Normalize to [-\u03C0, \u03C0]\r\n    while (delta > Math.PI) delta -= 2 * Math.PI;\r\n    while (delta < -Math.PI) delta += 2 * Math.PI;\r\n    totalTurn += delta;\r\n  }\r\n\r\n  const clockwise = totalTurn < 0;\r\n  const sweepAngle = Math.abs(totalTurn);\r\n\r\n  return {\r\n    circle,\r\n    rmsError,\r\n    medianError,\r\n    count: points.length,\r\n    errors,\r\n    startAngle,\r\n    endAngle,\r\n    sweepAngle,\r\n    clockwise,\r\n  };\r\n}\r\n\r\n/**\r\n * Incremental circle fitting for online algorithms\r\n * Allows adding points one at a time and updating the fit efficiently\r\n */\r\nexport class IncrementalCircleFit {\r\n  private n = 0;\r\n  private sumX = 0;\r\n  private sumY = 0;\r\n  private sumXX = 0;\r\n  private sumYY = 0;\r\n  private sumXY = 0;\r\n  private sumXXX = 0;\r\n  private sumXXY = 0;\r\n  private sumXYY = 0;\r\n  private sumYYY = 0;\r\n  private points: Point[] = [];\r\n\r\n  /**\r\n   * Add a point to the fit\r\n   */\r\n  addPoint(p: Point): void {\r\n    this.n++;\r\n    this.sumX += p.x;\r\n    this.sumY += p.y;\r\n    this.sumXX += p.x * p.x;\r\n    this.sumYY += p.y * p.y;\r\n    this.sumXY += p.x * p.y;\r\n    this.sumXXX += p.x * p.x * p.x;\r\n    this.sumXXY += p.x * p.x * p.y;\r\n    this.sumXYY += p.x * p.y * p.y;\r\n    this.sumYYY += p.y * p.y * p.y;\r\n\r\n    this.points.push(p);\r\n  }\r\n\r\n  /**\r\n   * Get the number of points in the fit\r\n   */\r\n  getCount(): number {\r\n    return this.n;\r\n  }\r\n\r\n  /**\r\n   * Get all points in the fit\r\n   */\r\n  getPoints(): Point[] {\r\n    return [...this.points];\r\n  }\r\n\r\n  /**\r\n   * Get the current fit result\r\n   * Returns null if fewer than 3 points\r\n   */\r\n  getFit(): ArcFitResult | null {\r\n    if (this.n < 3) {\r\n      return null;\r\n    }\r\n\r\n    const meanX = this.sumX / this.n;\r\n    const meanY = this.sumY / this.n;\r\n\r\n    // Calculate moment matrix using stored sums\r\n    // These match the batch computation exactly\r\n    let Mxx = 0, Mxy = 0, Myy = 0;\r\n    let Mxz = 0, Myz = 0;\r\n\r\n    for (const p of this.points) {\r\n      const x = p.x - meanX;\r\n      const y = p.y - meanY;\r\n      const z = x * x + y * y;\r\n\r\n      Mxx += x * x;\r\n      Mxy += x * y;\r\n      Myy += y * y;\r\n      Mxz += x * z;\r\n      Myz += y * z;\r\n    }\r\n\r\n    Mxx /= this.n;\r\n    Mxy /= this.n;\r\n    Myy /= this.n;\r\n    Mxz /= this.n;\r\n    Myz /= this.n;\r\n\r\n    const det = Mxx * Myy - Mxy * Mxy;\r\n    if (Math.abs(det) < 1e-10) {\r\n      return null;\r\n    }\r\n\r\n    const cx = (Mxz * Myy - Myz * Mxy) / det;\r\n    const cy = (Myz * Mxx - Mxz * Mxy) / det;\r\n\r\n    const center = {\r\n      x: cx + meanX,\r\n      y: cy + meanY,\r\n    };\r\n\r\n    const radiusSquared = cx * cx + cy * cy + (Mxx + Myy);\r\n    if (radiusSquared <= 0) {\r\n      return null;\r\n    }\r\n    const radius = Math.sqrt(radiusSquared);\r\n\r\n    const circle: Circle = { center, radius };\r\n\r\n    // Calculate errors\r\n    const errors = this.points.map((p) =>\r\n      Math.abs(distance(p, center) - radius)\r\n    );\r\n\r\n    const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n    const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n    const sortedErrors = [...errors].sort((a, b) => a - b);\r\n    const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n    // Calculate arc parameters\r\n    const angles = this.points.map((p) =>\r\n      Math.atan2(p.y - center.y, p.x - center.x)\r\n    );\r\n    const startAngle = angles[0];\r\n    const endAngle = angles[angles.length - 1];\r\n\r\n    let totalTurn = 0;\r\n    for (let i = 1; i < angles.length; i++) {\r\n      let delta = angles[i] - angles[i - 1];\r\n      while (delta > Math.PI) delta -= 2 * Math.PI;\r\n      while (delta < -Math.PI) delta += 2 * Math.PI;\r\n      totalTurn += delta;\r\n    }\r\n\r\n    const clockwise = totalTurn < 0;\r\n    const sweepAngle = Math.abs(totalTurn);\r\n\r\n    return {\r\n      circle,\r\n      rmsError,\r\n      medianError,\r\n      count: this.n,\r\n      errors,\r\n      startAngle,\r\n      endAngle,\r\n      sweepAngle,\r\n      clockwise,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the fit to start over\r\n   */\r\n  reset(): void {\r\n    this.n = 0;\r\n    this.sumX = 0;\r\n    this.sumY = 0;\r\n    this.sumXX = 0;\r\n    this.sumYY = 0;\r\n    this.sumXY = 0;\r\n    this.sumXXX = 0;\r\n    this.sumXXY = 0;\r\n    this.sumXYY = 0;\r\n    this.sumYYY = 0;\r\n    this.points = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile of errors\r\n */\r\nexport function percentile(values: number[], p: number): number {\r\n  if (values.length === 0) return 0;\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const index = Math.floor(sorted.length * p);\r\n  return sorted[Math.min(index, sorted.length - 1)];\r\n}\r\n", "import type { Graph, GraphEdge } from \"./tracer.ts\";\r\nimport type { Arc, Line, Point } from \"./geometry.ts\";\r\nimport { optimizeEdge } from \"./optimizer.ts\";\r\nimport { IncrementalLineFit } from \"./line_fit.ts\";\r\nimport { IncrementalCircleFit } from \"./arc_fit.ts\";\r\n\r\nexport type Segment =\r\n  | { type: \"line\"; line: Line; start: Point; end: Point; points: Point[] }\r\n  | { type: \"arc\"; arc: Arc; start: Point; end: Point; points: Point[] };\r\n\r\nexport interface SimplifiedEdge {\r\n  original: GraphEdge;\r\n  segments: Segment[];\r\n}\r\n\r\nexport interface SimplifiedGraph {\r\n  nodes: Graph[\"nodes\"];\r\n  edges: SimplifiedEdge[];\r\n}\r\n\r\nfunction segmentEdge(points: Point[]): Segment[] {\r\n  const segments: Segment[] = [];\r\n  let startIndex = 0;\r\n  const TOLERANCE = 2.0; // Higher tolerance for initial pass\r\n\r\n  while (startIndex < points.length - 1) {\r\n    let bestEndIndex = startIndex + 1;\r\n    let bestType: \"line\" | \"arc\" = \"line\";\r\n    let bestLineFit = null;\r\n    let bestArcFit = null;\r\n\r\n    const lineFit = new IncrementalLineFit();\r\n    const arcFit = new IncrementalCircleFit();\r\n\r\n    // Add first point\r\n    lineFit.addPoint(points[startIndex]);\r\n    arcFit.addPoint(points[startIndex]);\r\n\r\n    // Try to extend as far as possible\r\n    for (let i = startIndex + 1; i < points.length; i++) {\r\n      const p = points[i];\r\n      lineFit.addPoint(p);\r\n      arcFit.addPoint(p);\r\n\r\n      const count = i - startIndex + 1;\r\n\r\n      let lValid = false;\r\n      let aValid = false;\r\n      let lFit = null;\r\n      let aFit = null;\r\n\r\n      // Check Line Fit\r\n      if (count >= 2) {\r\n        lFit = lineFit.getFit();\r\n        if (lFit) {\r\n          const maxErr = Math.max(...lFit.errors);\r\n          if (maxErr <= TOLERANCE) lValid = true;\r\n        }\r\n      }\r\n\r\n      // Check Arc Fit\r\n      if (count >= 3) {\r\n        aFit = arcFit.getFit();\r\n        if (aFit) {\r\n          const maxErr = Math.max(...aFit.errors);\r\n          // Limit arc to 180 degrees to avoid ambiguity in sagitta representation\r\n          // and degenerate cases with closed loops.\r\n          if (maxErr <= TOLERANCE && Math.abs(aFit.sweepAngle) <= Math.PI) {\r\n            aValid = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!lValid && !aValid) {\r\n        // Both failed. The previous index was the last valid one.\r\n        break;\r\n      }\r\n\r\n      // Current index is valid for at least one type\r\n      bestEndIndex = i;\r\n\r\n      if (lValid && aValid) {\r\n        // Prefer line unless arc is significantly better\r\n        if (aFit!.rmsError < lFit!.rmsError * 0.8) {\r\n          bestType = \"arc\";\r\n          bestArcFit = aFit;\r\n          bestLineFit = null;\r\n        } else {\r\n          bestType = \"line\";\r\n          bestLineFit = lFit;\r\n          bestArcFit = null;\r\n        }\r\n      } else if (lValid) {\r\n        bestType = \"line\";\r\n        bestLineFit = lFit;\r\n        bestArcFit = null;\r\n      } else {\r\n        bestType = \"arc\";\r\n        bestArcFit = aFit;\r\n        bestLineFit = null;\r\n      }\r\n    }\r\n\r\n    // Create segment\r\n    const startP = points[startIndex];\r\n    const endP = points[bestEndIndex];\r\n    const segmentPoints = points.slice(startIndex, bestEndIndex + 1);\r\n\r\n    if (bestType === \"line\") {\r\n      if (!bestLineFit) {\r\n        const dx = endP.x - startP.x;\r\n        const dy = endP.y - startP.y;\r\n        const len = Math.sqrt(dx * dx + dy * dy);\r\n        bestLineFit = {\r\n          line: { point: startP, direction: { x: dx / len, y: dy / len } },\r\n          rmsError: 0,\r\n          medianError: 0,\r\n          count: 2,\r\n          errors: [0, 0],\r\n        };\r\n      }\r\n\r\n      segments.push({\r\n        type: \"line\",\r\n        line: bestLineFit!.line,\r\n        start: startP,\r\n        end: endP,\r\n        points: segmentPoints,\r\n      });\r\n    } else {\r\n      segments.push({\r\n        type: \"arc\",\r\n        arc: {\r\n          center: bestArcFit!.circle.center,\r\n          radius: bestArcFit!.circle.radius,\r\n          startAngle: bestArcFit!.startAngle,\r\n          endAngle: bestArcFit!.endAngle,\r\n          clockwise: bestArcFit!.clockwise,\r\n        },\r\n        start: startP,\r\n        end: endP,\r\n        points: segmentPoints,\r\n      });\r\n    }\r\n\r\n    startIndex = bestEndIndex;\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\nimport type { OptNode, OptSegment } from \"./optimizer.ts\";\r\n\r\n/**\r\n * Simplifies the edges in the graph into geometric segments (lines and arcs).\r\n */\r\nexport function simplifyGraph(\r\n  graph: Graph,\r\n  onIteration?: (\r\n    edgeId: number,\r\n    nodes: OptNode[],\r\n    segments: OptSegment[],\r\n    label: string,\r\n  ) => void,\r\n): SimplifiedGraph {\r\n  const simplifiedEdges: SimplifiedEdge[] = [];\r\n\r\n  for (const edge of graph.edges) {\r\n    if (edge.points.length < 2) {\r\n      continue;\r\n    }\r\n\r\n    // 1. Initial Greedy Pass\r\n    const initialSegments = segmentEdge(edge.points);\r\n\r\n    const initial: SimplifiedEdge = {\r\n      original: edge,\r\n      segments: initialSegments,\r\n    };\r\n\r\n    // 2. Optimization Pass\r\n    const optimized = optimizeEdge(\r\n      initial,\r\n      initialSegments,\r\n      (nodes, segments, label) => {\r\n        if (onIteration) onIteration(edge.id, nodes, segments, label);\r\n      },\r\n    );\r\n    simplifiedEdges.push(optimized);\r\n  }\r\n\r\n  return {\r\n    nodes: graph.nodes,\r\n    edges: simplifiedEdges,\r\n  };\r\n}\r\n", "import {\r\n  type BinaryImage,\r\n  createBinaryImage,\r\n  getPixelBin,\r\n  setPixelBin,\r\n} from \"../src/formats/binary.ts\";\r\nimport { traceGraph } from \"../src/vectorize/tracer.ts\";\r\nimport { type Segment, simplifyGraph } from \"../src/vectorize/simplifier.ts\";\r\nimport {\r\n  convertToSegments,\r\n  type OptNode,\r\n  type OptSegment,\r\n} from \"../src/vectorize/optimizer.ts\";\r\n\r\nfunction binaryFromAscii(ascii: string): BinaryImage {\r\n  const lines = ascii.split(\"\\n\");\r\n  if (lines[0].trim() === \"\") lines.shift();\r\n  while (lines.length > 0 && lines[lines.length - 1].trim() === \"\") {\r\n    lines.pop();\r\n  }\r\n\r\n  const height = lines.length;\r\n  const width = lines.reduce((max, line) => Math.max(max, line.length), 0);\r\n\r\n  const img = createBinaryImage(width, height);\r\n\r\n  lines.forEach((line, y) => {\r\n    line = line.trimEnd().trimStart();\r\n    for (let x = 0; x < line.length; x++) {\r\n      const char = line[x];\r\n      if (char !== \".\" && char !== \" \") {\r\n        setPixelBin(img, x, y, 1);\r\n      }\r\n    }\r\n  });\r\n\r\n  return img;\r\n}\r\n\r\nconst TEST_CASES = [\r\n  {\r\n    name: \"Horizontal Line\",\r\n    ascii: `\r\n    ..........\r\n    .#####....\r\n    ..........\r\n    `,\r\n  },\r\n  {\r\n    name: \"L-Shape (Corner)\",\r\n    ascii: `\r\n    #.........\r\n    #.........\r\n    #.........\r\n    #.........\r\n    #.........\r\n    ##########\r\n    `,\r\n  },\r\n  {\r\n    name: \"Diagonal Line\",\r\n    ascii: `\r\n    #.........\r\n    .#........\r\n    ..#.......\r\n    ...#......\r\n    ....#.....\r\n    `,\r\n  },\r\n  {\r\n    name: \"Circle (Small)\",\r\n    ascii: `\r\n    ...###...\r\n    ..#...#..\r\n    .#.....#.\r\n    .#.....#.\r\n    .#.....#.\r\n    ..#...#..\r\n    ...###...\r\n    `,\r\n  },\r\n];\r\n\r\nfunction renderTestCase(\r\n  container: HTMLElement,\r\n  testCase: { name: string; ascii: string },\r\n) {\r\n  const div = document.createElement(\"div\");\r\n  div.className = \"test-case\";\r\n\r\n  const h2 = document.createElement(\"h2\");\r\n  h2.textContent = testCase.name;\r\n  div.appendChild(h2);\r\n\r\n  const bin = binaryFromAscii(testCase.ascii);\r\n  const graph = traceGraph(bin);\r\n\r\n  // Capture history\r\n  interface HistoryStep {\r\n    label: string;\r\n    nodes: OptNode[];\r\n    segments: OptSegment[];\r\n  }\r\n  const history: HistoryStep[] = [];\r\n\r\n  const simplified = simplifyGraph(graph, (edgeId, nodes, segments, label) => {\r\n    history.push({ label, nodes, segments });\r\n  });\r\n\r\n  const SCALE = 20;\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = bin.width * SCALE;\r\n  canvas.height = bin.height * SCALE;\r\n  div.appendChild(canvas);\r\n\r\n  // Controls\r\n  const controls = document.createElement(\"div\");\r\n  controls.className = \"controls\";\r\n  div.appendChild(controls);\r\n\r\n  const slider = document.createElement(\"input\");\r\n  slider.type = \"range\";\r\n  slider.min = \"0\";\r\n  slider.max = String(Math.max(0, history.length - 1));\r\n  slider.value = String(Math.max(0, history.length - 1));\r\n  slider.style.width = \"300px\";\r\n  controls.appendChild(slider);\r\n\r\n  const labelSpan = document.createElement(\"span\");\r\n  labelSpan.style.marginLeft = \"10px\";\r\n  labelSpan.style.fontWeight = \"bold\";\r\n  controls.appendChild(labelSpan);\r\n\r\n  const infoDiv = document.createElement(\"div\");\r\n  infoDiv.style.fontFamily = \"monospace\";\r\n  infoDiv.style.whiteSpace = \"pre\";\r\n  infoDiv.style.marginTop = \"10px\";\r\n  div.appendChild(infoDiv);\r\n\r\n  const ctx = canvas.getContext(\"2d\")!;\r\n\r\n  function draw(stepIndex: number) {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // 1. Draw Grid\r\n    ctx.strokeStyle = \"#eee\";\r\n    ctx.lineWidth = 1;\r\n    for (let x = 0; x <= bin.width; x++) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(x * SCALE, 0);\r\n      ctx.lineTo(x * SCALE, bin.height * SCALE);\r\n      ctx.stroke();\r\n    }\r\n    for (let y = 0; y <= bin.height; y++) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(0, y * SCALE);\r\n      ctx.lineTo(bin.width * SCALE, y * SCALE);\r\n      ctx.stroke();\r\n    }\r\n\r\n    // 2. Draw Pixels\r\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.1)\";\r\n    for (let y = 0; y < bin.height; y++) {\r\n      for (let x = 0; x < bin.width; x++) {\r\n        if (getPixelBin(bin, x, y)) {\r\n          ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);\r\n\r\n          // Draw center point\r\n          ctx.fillStyle = \"rgba(0, 0, 0, 0.3)\";\r\n          ctx.beginPath();\r\n          ctx.arc((x + 0.5) * SCALE, (y + 0.5) * SCALE, 2, 0, Math.PI * 2);\r\n          ctx.fill();\r\n          ctx.fillStyle = \"rgba(0, 0, 0, 0.1)\";\r\n        }\r\n      }\r\n    }\r\n\r\n    if (history.length === 0) return;\r\n\r\n    const step = history[stepIndex];\r\n    labelSpan.textContent = `${stepIndex + 1}/${history.length}: ${step.label}`;\r\n\r\n    // Convert OptSegments to Segments for drawing\r\n    const segments = convertToSegments(step.nodes, step.segments);\r\n\r\n    // Update Info Text\r\n    let info = \"\";\r\n    segments.forEach((seg, i) => {\r\n      info += `Segment ${i}: ${seg.type.toUpperCase()}\\n`;\r\n      info += `  Start: (${seg.start.x.toFixed(2)}, ${\r\n        seg.start.y.toFixed(2)\r\n      })\\n`;\r\n      info += `  End:   (${seg.end.x.toFixed(2)}, ${seg.end.y.toFixed(2)})\\n`;\r\n      if (seg.type === \"arc\") {\r\n        info += `  Radius: ${seg.arc.radius.toFixed(2)}\\n`;\r\n        info += `  Center: (${seg.arc.center.x.toFixed(2)}, ${\r\n          seg.arc.center.y.toFixed(2)\r\n        })\\n`;\r\n      }\r\n      // Show sagitta from optimization state\r\n      const optSeg = step.segments[i];\r\n      if (optSeg) {\r\n        info += `  Sagitta: ${optSeg.sagitta.toFixed(4)}\\n`;\r\n      }\r\n      info += \"\\n\";\r\n    });\r\n    infoDiv.textContent = info;\r\n\r\n    // 4. Draw Simplified Segments\r\n    // Cycle colors for different edges\r\n    const colors = [\"#e74c3c\", \"#3498db\", \"#2ecc71\", \"#9b59b6\", \"#f1c40f\"];\r\n\r\n    segments.forEach((seg, i) => {\r\n      ctx.strokeStyle = colors[i % colors.length];\r\n      ctx.lineWidth = 3;\r\n\r\n      ctx.beginPath();\r\n      if (seg.type === \"line\") {\r\n        const startX = (seg.start.x + 0.5) * SCALE;\r\n        const startY = (seg.start.y + 0.5) * SCALE;\r\n        const endX = (seg.end.x + 0.5) * SCALE;\r\n        const endY = (seg.end.y + 0.5) * SCALE;\r\n        ctx.moveTo(startX, startY);\r\n        ctx.lineTo(endX, endY);\r\n      } else {\r\n        const arc = seg.arc;\r\n        const cx = (arc.center.x + 0.5) * SCALE;\r\n        const cy = (arc.center.y + 0.5) * SCALE;\r\n        const r = arc.radius * SCALE;\r\n\r\n        // Canvas arc takes start/end angles.\r\n        // Need to handle direction carefully.\r\n        ctx.arc(cx, cy, r, arc.startAngle, arc.endAngle, !arc.clockwise);\r\n      }\r\n      ctx.stroke();\r\n\r\n      // Draw endpoints\r\n      ctx.fillStyle = \"black\";\r\n      const startX = (seg.start.x + 0.5) * SCALE;\r\n      const startY = (seg.start.y + 0.5) * SCALE;\r\n      const endX = (seg.end.x + 0.5) * SCALE;\r\n      const endY = (seg.end.y + 0.5) * SCALE;\r\n\r\n      ctx.beginPath();\r\n      ctx.arc(startX, startY, 4, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      ctx.beginPath();\r\n      ctx.arc(endX, endY, 4, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    });\r\n  }\r\n\r\n  slider.addEventListener(\"input\", () => {\r\n    draw(parseInt(slider.value));\r\n  });\r\n\r\n  // Initial draw\r\n  if (history.length > 0) {\r\n    draw(history.length - 1);\r\n  }\r\n\r\n  container.appendChild(div);\r\n}\r\n\r\nfunction init() {\r\n  const container = document.getElementById(\"container\");\r\n  if (!container) return;\r\n\r\n  TEST_CASES.forEach((testCase) => {\r\n    renderTestCase(container, testCase);\r\n  });\r\n}\r\n\r\ninit();\r\n"],
  "mappings": "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",
  "names": ["endP", "startP", "startX", "startY", "endX", "endY"]
}
