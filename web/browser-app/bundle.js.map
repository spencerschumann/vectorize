{
  "version": 3,
  "sources": ["../src/pdf/image_load.ts", "../src/pdf/pdf_render.ts", "../src/gpu/gpu_context.ts", "../src/gpu/cleanup_gpu.ts", "../src/gpu/value_process_gpu.ts", "../src/gpu/palettize_gpu.ts", "../src/formats/palettized.ts", "../src/gpu/median_gpu.ts", "../src/gpu/extract_black_gpu.ts", "../src/gpu/bloom_gpu.ts", "../src/gpu/subtract_black_gpu.ts", "storage.ts", "utils.ts", "state.ts", "canvas.ts", "palette.ts", "incremental_segmentation.ts", "vectorize.ts", "main.ts"],
  "sourcesContent": ["/**\r\n * Load image from File object in browser\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\n\r\nexport function loadImageFromFile(file: File): Promise<RGBAImage> {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        \r\n        img.onload = () => {\r\n            // Create canvas to extract pixel data\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            \r\n            const ctx = canvas.getContext(\"2d\");\r\n            if (!ctx) {\r\n                reject(new Error(\"Could not get 2D context\"));\r\n                return;\r\n            }\r\n            \r\n            // Draw image\r\n            ctx.drawImage(img, 0, 0);\r\n            \r\n            // Extract pixel data\r\n            const imageData = ctx.getImageData(0, 0, img.width, img.height);\r\n            \r\n            resolve({\r\n                width: img.width,\r\n                height: img.height,\r\n                data: new Uint8ClampedArray(imageData.data),\r\n            });\r\n            \r\n            // Clean up\r\n            URL.revokeObjectURL(img.src);\r\n        };\r\n        \r\n        img.onerror = () => {\r\n            reject(new Error(\"Failed to load image\"));\r\n            URL.revokeObjectURL(img.src);\r\n        };\r\n        \r\n        // Create object URL and load\r\n        img.src = URL.createObjectURL(file);\r\n    });\r\n}\r\n", "import type { RGBAImage } from \"../formats/rgba_image.ts\";\r\n\r\n/**\r\n * Canvas backend interface\r\n * Allows for different implementations in browser vs Deno\r\n */\r\nexport interface CanvasBackend {\r\n  createCanvas(width: number, height: number): CanvasLike;\r\n}\r\n\r\n/**\r\n * Minimal canvas interface needed for PDF rendering\r\n */\r\nexport interface CanvasLike {\r\n  width: number;\r\n  height: number;\r\n  getContext(contextId: \"2d\"): CanvasRenderingContext2DLike | null;\r\n}\r\n\r\n/**\r\n * Minimal 2D context interface\r\n */\r\nexport interface CanvasRenderingContext2DLike {\r\n  getImageData(\r\n    sx: number,\r\n    sy: number,\r\n    sw: number,\r\n    sh: number,\r\n  ): ImageDataLike;\r\n  putImageData(imageData: ImageDataLike, dx: number, dy: number): void;\r\n  drawImage(image: unknown, dx: number, dy: number): void;\r\n}\r\n\r\n/**\r\n * Minimal ImageData interface\r\n */\r\nexport interface ImageDataLike {\r\n  width: number;\r\n  height: number;\r\n  data: Uint8ClampedArray;\r\n}\r\n\r\n/**\r\n * PDF rendering options\r\n */\r\nexport interface PDFRenderOptions {\r\n  file: ArrayBuffer | Uint8Array;\r\n  pageNumber: number;\r\n  dpi?: number;\r\n  scale?: number;\r\n}\r\n\r\n/**\r\n * Render a PDF page to an RGBA image\r\n * Uses the provided canvas backend (browser or Deno)\r\n */\r\nexport async function renderPdfPage(\r\n  options: PDFRenderOptions,\r\n  backend: CanvasBackend,\r\n  pdfjsLib: any,\r\n): Promise<RGBAImage> {\r\n  const { file, pageNumber, scale = 2.0 } = options;\r\n\r\n  // Load PDF document\r\n  const loadingTask = pdfjsLib.getDocument({ data: file });\r\n  const pdf = await loadingTask.promise;\r\n\r\n  if (pageNumber < 1 || pageNumber > pdf.numPages) {\r\n    throw new Error(\r\n      `Page ${pageNumber} out of range (1-${pdf.numPages})`,\r\n    );\r\n  }\r\n\r\n  // Get page\r\n  const page = await pdf.getPage(pageNumber);\r\n  const viewport = page.getViewport({ scale });\r\n\r\n  // Create canvas\r\n  const canvas = backend.createCanvas(viewport.width, viewport.height);\r\n  const context = canvas.getContext(\"2d\");\r\n\r\n  if (!context) {\r\n    throw new Error(\"Failed to get 2D context\");\r\n  }\r\n\r\n  // Render page to canvas\r\n  await page.render({\r\n    canvasContext: context,\r\n    viewport: viewport,\r\n  }).promise;\r\n\r\n  // Extract image data\r\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n  return {\r\n    width: imageData.width,\r\n    height: imageData.height,\r\n    data: imageData.data,\r\n  };\r\n}\r\n", "/**\r\n * WebGPU context management\r\n * Shared between browser and Deno\r\n */\r\n\r\n// Extend Navigator interface for WebGPU support\r\ndeclare global {\r\n    interface Navigator {\r\n        gpu?: GPU;\r\n    }\r\n}\r\n\r\nexport interface GPUContext {\r\n    device: GPUDevice;\r\n    adapter: GPUAdapter;\r\n}\r\n\r\nlet cachedContext: GPUContext | null = null;\r\nlet isInitializing = false;\r\nlet initPromise: Promise<GPUContext> | null = null;\r\n\r\n/**\r\n * Initialize WebGPU context (works in both browser and Deno)\r\n * Caches context and pipelines for reuse\r\n */\r\nexport async function getGPUContext(): Promise<GPUContext> {\r\n    if (cachedContext) {\r\n        return cachedContext;\r\n    }\r\n\r\n    // Prevent multiple simultaneous initializations\r\n    if (isInitializing && initPromise) {\r\n        return initPromise;\r\n    }\r\n\r\n    isInitializing = true;\r\n    initPromise = (async () => {\r\n        if (!navigator.gpu) {\r\n            throw new Error(\"WebGPU not supported in this environment\");\r\n        }\r\n\r\n        const adapter = await navigator.gpu.requestAdapter();\r\n        if (!adapter) {\r\n            throw new Error(\"No WebGPU adapter found\");\r\n        }\r\n\r\n        const device = await adapter.requestDevice();\r\n        \r\n        // Set up error handling\r\n        device.addEventListener('uncapturederror', (event: Event) => {\r\n            const gpuEvent = event as GPUUncapturedErrorEvent;\r\n            console.error('WebGPU uncaptured error:');\r\n            console.error('  Type:', gpuEvent.error.constructor.name);\r\n            console.error('  Message:', gpuEvent.error.message);\r\n            console.error('  Full error:', gpuEvent.error);\r\n        });\r\n        \r\n        // Log adapter limits for debugging\r\n        console.log(\"WebGPU Adapter Limits:\");\r\n        console.log(`  maxStorageBufferBindingSize: ${adapter.limits.maxStorageBufferBindingSize}`);\r\n        console.log(`  maxBufferSize: ${adapter.limits.maxBufferSize}`);\r\n        console.log(`  maxComputeWorkgroupStorageSize: ${adapter.limits.maxComputeWorkgroupStorageSize}`);\r\n        console.log(`  maxComputeInvocationsPerWorkgroup: ${adapter.limits.maxComputeInvocationsPerWorkgroup}`);\r\n        console.log(`  maxComputeWorkgroupsPerDimension: ${adapter.limits.maxComputeWorkgroupsPerDimension}`);\r\n        console.log(`  maxComputeWorkgroupSizeX: ${adapter.limits.maxComputeWorkgroupSizeX}`);\r\n        console.log(`  maxComputeWorkgroupSizeY: ${adapter.limits.maxComputeWorkgroupSizeY}`);\r\n        console.log(`  maxComputeWorkgroupSizeZ: ${adapter.limits.maxComputeWorkgroupSizeZ}`);\r\n        \r\n        cachedContext = { device, adapter };\r\n        isInitializing = false;\r\n        return cachedContext;\r\n    })();\r\n\r\n    return await initPromise;\r\n}\r\n\r\n/**\r\n * Create a GPU buffer from typed array data\r\n */\r\nexport function createGPUBuffer(\r\n    device: GPUDevice,\r\n    data: Uint8Array | Uint32Array | Float32Array,\r\n    usage: GPUBufferUsageFlags,\r\n): GPUBuffer {\r\n    const buffer = device.createBuffer({\r\n        size: data.byteLength,\r\n        usage,\r\n        mappedAtCreation: true,\r\n    });\r\n    \r\n    const arrayBuffer = buffer.getMappedRange();\r\n    if (data instanceof Uint8Array) {\r\n        new Uint8Array(arrayBuffer).set(data);\r\n    } else if (data instanceof Uint32Array) {\r\n        new Uint32Array(arrayBuffer).set(data);\r\n    } else {\r\n        new Float32Array(arrayBuffer).set(data);\r\n    }\r\n    buffer.unmap();\r\n    \r\n    return buffer;\r\n}\r\n\r\n/**\r\n * Read data back from GPU buffer\r\n */\r\nexport async function readGPUBuffer(\r\n    device: GPUDevice,\r\n    buffer: GPUBuffer,\r\n    size: number,\r\n): Promise<Uint8Array> {\r\n    const readBuffer = device.createBuffer({\r\n        size,\r\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n\r\n    const commandEncoder = device.createCommandEncoder();\r\n    commandEncoder.copyBufferToBuffer(buffer, 0, readBuffer, 0, size);\r\n    device.queue.submit([commandEncoder.finish()]);\r\n\r\n    await readBuffer.mapAsync(GPUMapMode.READ);\r\n    const data = new Uint8Array(readBuffer.getMappedRange()).slice();\r\n    readBuffer.unmap();\r\n    readBuffer.destroy();\r\n\r\n    return data;\r\n}\r\n", "/**\r\n * WebGPU cleanup operation\r\n * Handles JPEG compression noise by processing channels separately:\r\n * 1. Calculate value (min(R,G,B)) for background vs lines\r\n * 2. Calculate saturation (max(R,G,B) - min(R,G,B))\r\n * 3. Threshold value at 50%\r\n * 4. Median filter on saturation (3x3)\r\n * 5. Extract hue and median filter it (3x3)\r\n * 6. Recombine into RGB\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\n// Step 1: Extract value, saturation, and hue channels\r\nconst extractChannelsShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> value_out: array<f32>;\r\n@group(0) @binding(2) var<storage, read_write> saturation_out: array<f32>;\r\n@group(0) @binding(3) var<storage, read_write> hue_out: array<f32>;\r\n@group(0) @binding(4) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let pixel = input[pixel_idx];\r\n    \r\n    // Extract RGBA bytes (little-endian: byte 0=R, 1=G, 2=B, 3=A)\r\n    // But when stored as u32 in GPU buffer from RGBA bytes:\r\n    // GPU sees it as: A|B|G|R (bytes 3|2|1|0 in memory become 0|1|2|3 in u32)\r\n    let r = f32((pixel >> 0u) & 0xFFu) / 255.0;\r\n    let g = f32((pixel >> 8u) & 0xFFu) / 255.0;\r\n    let b = f32((pixel >> 16u) & 0xFFu) / 255.0;\r\n    \r\n    // Calculate min and max for HSV\r\n    let min_rgb = min(min(r, g), b);\r\n    let max_rgb = max(max(r, g), b);\r\n    let delta = max_rgb - min_rgb;\r\n    \r\n    // Value = min(R,G,B) - gives 1.0 for white, 0.0 for black/colors\r\n    value_out[pixel_idx] = min_rgb;\r\n    \r\n    // Saturation = max(R,G,B) - min(R,G,B) - gives 0.0 for grayscale, higher for saturated\r\n    saturation_out[pixel_idx] = delta;\r\n    \r\n    // Hue calculation\r\n    var h: f32 = -1.0;\r\n    if (delta > 0.1) {\r\n        if (max_rgb == r) {\r\n            h = ((g - b) / delta) / 6.0;\r\n            if (h < 0.0) {\r\n                h = h + 1.0;\r\n            }\r\n        } else if (max_rgb == g) {\r\n            h = ((b - r) / delta + 2.0) / 6.0;\r\n        } else {\r\n            h = ((r - g) / delta + 4.0) / 6.0;\r\n        }\r\n    }\r\n    hue_out[pixel_idx] = h; // Store hue as 0.0 to 1.0\r\n}\r\n`;\r\n\r\n// Step 2: Threshold value channel to packed binary format\r\n// Output: 1 = line (signal), 0 = background\r\nconst thresholdShader = `\r\n@group(0) @binding(0) var<storage, read> value_in: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> value_out: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    threshold: f32,\r\n    _padding: f32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let value = value_in[pixel_idx];\r\n    \r\n    // Binary threshold: 1 = line (dark), 0 = background (light)\r\n    // Inverted from original: value < threshold means it's dark (a line)\r\n    if (value < params.threshold) {\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&value_out[word_idx], 1u << bit_idx);\r\n    }\r\n}\r\n`;\r\n\r\n// Step 3: 3x3 Median filter for saturation and hue\r\nconst medianFilterShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<f32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Sorting network for 9 elements (median filter)\r\nfn median9(v: array<f32, 9>) -> f32 {\r\n    var arr = v;\r\n    \r\n    // Simple bubble sort for median (good enough for 9 elements)\r\n    for (var i = 0u; i < 9u; i = i + 1u) {\r\n        for (var j = 0u; j < 8u - i; j = j + 1u) {\r\n            if (arr[j] > arr[j + 1u]) {\r\n                let temp = arr[j];\r\n                arr[j] = arr[j + 1u];\r\n                arr[j + 1u] = temp;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return arr[4]; // Middle element\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let w = i32(params.width);\r\n    let h = i32(params.height);\r\n    let ix = i32(x);\r\n    let iy = i32(y);\r\n    \r\n    var values: array<f32, 9>;\r\n    var idx = 0u;\r\n    \r\n    // Gather 3x3 neighborhood\r\n    for (var dy = -1; dy <= 1; dy = dy + 1) {\r\n        for (var dx = -1; dx <= 1; dx = dx + 1) {\r\n            let nx = clamp(ix + dx, 0, w - 1);\r\n            let ny = clamp(iy + dy, 0, h - 1);\r\n            values[idx] = input[u32(ny) * params.width + u32(nx)];\r\n            idx = idx + 1u;\r\n        }\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    output[pixel_idx] = median9(values);\r\n}\r\n`;\r\n\r\n// Step 4: Recombine channels into RGB\r\n// Value input is packed binary: 1 = line, 0 = background\r\nconst recombineShader = `\r\n@group(0) @binding(0) var<storage, read> value_in: array<u32>;\r\n@group(0) @binding(1) var<storage, read> saturation_in: array<f32>;\r\n@group(0) @binding(2) var<storage, read> hue_in: array<f32>;\r\n@group(0) @binding(3) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(4) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Convert HSV to RGB\r\nfn hsv_to_rgb(h: f32, s: f32, v: f32) -> vec3<f32> {\r\n    if (h < 0 || s < 0.1) {\r\n        // Grayscale\r\n        return vec3<f32>(v, v, v);\r\n    }\r\n    \r\n    let h6 = h * 6.0;\r\n    let sector = u32(floor(h6));\r\n    let frac = h6 - f32(sector);\r\n    \r\n    let p = v * (1.0 - s);\r\n    let q = v * (1.0 - s * frac);\r\n    let t = v * (1.0 - s * (1.0 - frac));\r\n    \r\n    switch (sector % 6u) {\r\n        case 0u: { return vec3<f32>(v, t, p); }\r\n        case 1u: { return vec3<f32>(q, v, p); }\r\n        case 2u: { return vec3<f32>(p, v, t); }\r\n        case 3u: { return vec3<f32>(p, q, v); }\r\n        case 4u: { return vec3<f32>(t, p, v); }\r\n        default: { return vec3<f32>(v, p, q); }\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    \r\n    // Read packed binary value: 1 = line, 0 = background\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    let value_bit = (value_in[word_idx] >> bit_idx) & 1u;\r\n    \r\n    let saturation = saturation_in[pixel_idx]; // Cleaned saturation\r\n    let hue = hue_in[pixel_idx]; // Cleaned hue\r\n    \r\n    // For background pixels (value_bit = 0), output white\r\n    // For line pixels (value_bit = 1), reconstruct color from cleaned hue and saturation\r\n    var rgb: vec3<f32>;\r\n    if (value_bit == 0u) {\r\n        // Background - output white\r\n        rgb = vec3<f32>(1.0, 1.0, 1.0);\r\n    } else {\r\n        // Line - reconstruct color with full brightness\r\n        // Use saturation and hue to rebuild the color\r\n        if (saturation < 0.1 || hue < 0.0) {\r\n            // Grayscale line - output black\r\n            rgb = vec3<f32>(0.0, 0.0, 0.0);\r\n        } else {\r\n            // Colored line - reconstruct from HSV with V=1.0 for full brightness\r\n            rgb = hsv_to_rgb(hue, 1.0, 1.0);\r\n        }\r\n    }\r\n    \r\n    let r = u32(clamp(rgb.x * 255.0, 0.0, 255.0));\r\n    let g = u32(clamp(rgb.y * 255.0, 0.0, 255.0));\r\n    let b = u32(clamp(rgb.z * 255.0, 0.0, 255.0));\r\n    let a = 255u;\r\n    \r\n    output[pixel_idx] = r | (g << 8u) | (b << 16u) | (a << 24u);\r\n}\r\n`;\r\n\r\n// Helper: Convert single channel (f32) to grayscale RGBA\r\nconst channelToGrayscaleShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let value = input[pixel_idx];\r\n    \r\n    let gray = u32(clamp(value * 255.0, 0.0, 255.0));\r\n    output[pixel_idx] = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\n// Helper: Convert binary u32 to grayscale RGBA\r\nconst binaryToGrayscaleShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    let bit = (input[word_idx] >> bit_idx) & 1u;\r\n    \r\n    // 1 = line (black), 0 = background (white)\r\n    let gray = (1u - bit) * 255u;\r\n    output[pixel_idx] = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\n// Helper: Convert hue channel to RGB for visualization\r\nconst hueToRGBShader = `\r\n@group(0) @binding(0) var<storage, read> hue_in: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\nfn hsv_to_rgb(h: f32, s: f32, v: f32) -> vec3<f32> {\r\n    if (h < 0 || s < 0.1) {\r\n        // Grayscale\r\n        return vec3<f32>(v, v, v);\r\n    }\r\n\r\n    let h6 = h * 6.0;\r\n    let sector = u32(floor(h6));\r\n    let frac = h6 - f32(sector);\r\n    \r\n    let p = v * (1.0 - s);\r\n    let q = v * (1.0 - s * frac);\r\n    let t = v * (1.0 - s * (1.0 - frac));\r\n    \r\n    switch (sector % 6u) {\r\n        case 0u: { return vec3<f32>(v, t, p); }\r\n        case 1u: { return vec3<f32>(q, v, p); }\r\n        case 2u: { return vec3<f32>(p, v, t); }\r\n        case 3u: { return vec3<f32>(p, q, v); }\r\n        case 4u: { return vec3<f32>(t, p, v); }\r\n        default: { return vec3<f32>(v, p, q); }\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let hue = hue_in[pixel_idx];\r\n    \r\n    // Convert hue to RGB with full saturation and value for visualization\r\n    let rgb = hsv_to_rgb(hue, 1.0, 1.0);\r\n    \r\n    let r = u32(clamp(rgb.x * 255.0, 0.0, 255.0));\r\n    let g = u32(clamp(rgb.y * 255.0, 0.0, 255.0));\r\n    let b = u32(clamp(rgb.z * 255.0, 0.0, 255.0));\r\n    \r\n    output[pixel_idx] = r | (g << 8u) | (b << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\nexport interface CleanupResults {\r\n    value: RGBAImage;              // Thresholded value channel (visualized)\r\n    saturation: RGBAImage;         // Raw saturation channel\r\n    saturationMedian: RGBAImage;   // Median-filtered saturation\r\n    hue: RGBAImage;                // Raw hue channel\r\n    hueMedian: RGBAImage;          // Median-filtered hue\r\n    final: RGBAImage;              // Final recombined result\r\n    valueBuffer: GPUBuffer;        // Binary value buffer (u32 array: 0=line, 1=bg)\r\n    saturationBuffer: GPUBuffer;   // Median-filtered saturation buffer (f32)\r\n    hueBuffer: GPUBuffer;          // Median-filtered hue buffer (f32)\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n/**\r\n * Apply cleanup filter using multi-pass WebGPU pipeline\r\n * Returns all intermediate channel visualizations\r\n */\r\nexport async function cleanupGPU(image: RGBAImage): Promise<CleanupResults> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    const byteSize = pixelCount * 4;\r\n    const floatByteSize = pixelCount * 4; // f32 arrays\r\n    const binaryWordCount = Math.ceil(pixelCount / 32);  // Pack 32 pixels per u32\r\n    const binaryByteSize = binaryWordCount * 4;\r\n    \r\n    console.log(`Cleanup: ${width}x${height}, ${pixelCount} pixels, data.length=${data.length}, expected=${byteSize}`);\r\n    \r\n    // Create input buffer - data should be RGBA bytes (4 per pixel)\r\n    // Shader will read as array<u32> where each u32 contains one RGBA pixel\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(data.buffer, data.byteOffset, data.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create channel buffers\r\n    const valueBuffer1 = device.createBuffer({\r\n        size: floatByteSize,  // f32\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const valueBuffer2 = device.createBuffer({\r\n        size: binaryByteSize,  // Packed binary format\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    const saturationBuffer1 = device.createBuffer({\r\n        size: floatByteSize,  // f32\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const saturationBuffer2 = device.createBuffer({\r\n        size: floatByteSize,\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const hueBuffer1 = device.createBuffer({\r\n        size: floatByteSize,\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const hueBuffer2 = device.createBuffer({\r\n        size: floatByteSize,\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffers\r\n    const extractParams = new Uint32Array([width, height]);\r\n    const extractParamsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(extractParamsBuffer, 0, extractParams);\r\n    \r\n    // Threshold params: u32 width, u32 height, f32 threshold, f32 padding\r\n    const thresholdParamsBuffer = device.createBuffer({\r\n        size: 16,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    const thresholdParamsArray = new ArrayBuffer(16);\r\n    const thresholdParamsU32 = new Uint32Array(thresholdParamsArray);\r\n    const thresholdParamsF32 = new Float32Array(thresholdParamsArray);\r\n    thresholdParamsU32[0] = width;   // u32\r\n    thresholdParamsU32[1] = height;  // u32\r\n    thresholdParamsF32[2] = 0.5;     // f32 threshold (50%)\r\n    thresholdParamsF32[3] = 0.0;     // f32 padding\r\n    device.queue.writeBuffer(thresholdParamsBuffer, 0, thresholdParamsArray);\r\n    \r\n    const medianParams = new Uint32Array([width, height]);\r\n    const medianParamsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(medianParamsBuffer, 0, medianParams);\r\n    \r\n    // Create shader modules\r\n    const extractModule = device.createShaderModule({ code: extractChannelsShader });\r\n    const thresholdModule = device.createShaderModule({ code: thresholdShader });\r\n    const medianModule = device.createShaderModule({ code: medianFilterShader });\r\n    const recombineModule = device.createShaderModule({ code: recombineShader });\r\n    \r\n    // Create pipelines\r\n    const extractPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: extractModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const thresholdPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: thresholdModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const medianPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: medianModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const recombinePipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: recombineModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const workgroupsX = Math.ceil(width / 8);\r\n    const workgroupsY = Math.ceil(height / 8);\r\n    \r\n    // Pass 1: Extract channels\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: extractPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: inputBuffer } },\r\n                { binding: 1, resource: { buffer: valueBuffer1 } },\r\n                { binding: 2, resource: { buffer: saturationBuffer1 } },\r\n                { binding: 3, resource: { buffer: hueBuffer1 } },\r\n                { binding: 4, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(extractPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Clear valueBuffer2 before threshold pass (atomic operations require starting at 0)\r\n    device.queue.writeBuffer(valueBuffer2, 0, new Uint32Array(binaryWordCount));\r\n    \r\n    // Pass 2: Threshold value channel\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: thresholdPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer1 } },\r\n                { binding: 1, resource: { buffer: valueBuffer2 } },\r\n                { binding: 2, resource: { buffer: thresholdParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(thresholdPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 3: Median filter on saturation\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: medianPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: saturationBuffer1 } },\r\n                { binding: 1, resource: { buffer: saturationBuffer2 } },\r\n                { binding: 2, resource: { buffer: medianParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(medianPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 4: Median filter on hue\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: medianPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: hueBuffer1 } },\r\n                { binding: 1, resource: { buffer: hueBuffer2 } },\r\n                { binding: 2, resource: { buffer: medianParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(medianPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 5: Recombine channels\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: recombinePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer2 } },\r\n                { binding: 1, resource: { buffer: saturationBuffer2 } },\r\n                { binding: 2, resource: { buffer: hueBuffer2 } },\r\n                { binding: 3, resource: { buffer: outputBuffer } },\r\n                { binding: 4, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(recombinePipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n    }\r\n    \r\n    // Wait for completion\r\n    if (typeof window !== 'undefined') {\r\n        await device.queue.onSubmittedWorkDone();\r\n    } else {\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n    \r\n    // Create visualization pipelines\r\n    const grayscaleModule = device.createShaderModule({ code: channelToGrayscaleShader });\r\n    const binaryModule = device.createShaderModule({ code: binaryToGrayscaleShader });\r\n    const hueVisModule = device.createShaderModule({ code: hueToRGBShader });\r\n    \r\n    const grayscalePipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: grayscaleModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const binaryPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: binaryModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const hueVisPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: hueVisModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    // Create output buffers for visualizations\r\n    const valueVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const saturationVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const saturationMedianVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const hueVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const hueMedianVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Visualize value channel (binary thresholded)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: binaryPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer2 } },\r\n                { binding: 1, resource: { buffer: valueVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(binaryPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize saturation (raw)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: grayscalePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: saturationBuffer1 } },\r\n                { binding: 1, resource: { buffer: saturationVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(grayscalePipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize saturation (median filtered)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: grayscalePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: saturationBuffer2 } },\r\n                { binding: 1, resource: { buffer: saturationMedianVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(grayscalePipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize hue (raw)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: hueVisPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: hueBuffer1 } },\r\n                { binding: 1, resource: { buffer: hueVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(hueVisPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize hue (median filtered)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: hueVisPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: hueBuffer2 } },\r\n                { binding: 1, resource: { buffer: hueMedianVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(hueVisPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Read back all results\r\n    const [finalData, valueData, satData, satMedianData, hueData, hueMedianData] = await Promise.all([\r\n        readGPUBuffer(device, outputBuffer, byteSize),\r\n        readGPUBuffer(device, valueVisBuffer, byteSize),\r\n        readGPUBuffer(device, saturationVisBuffer, byteSize),\r\n        readGPUBuffer(device, saturationMedianVisBuffer, byteSize),\r\n        readGPUBuffer(device, hueVisBuffer, byteSize),\r\n        readGPUBuffer(device, hueMedianVisBuffer, byteSize),\r\n    ]);\r\n    \r\n    console.log(`Cleanup complete: ${finalData.length} bytes`);\r\n    \r\n    // Cleanup buffers (keep valueBuffer2, saturationBuffer2, hueBuffer2 for further processing)\r\n    inputBuffer.destroy();\r\n    valueBuffer1.destroy();\r\n    // valueBuffer2 kept - returned for value processing\r\n    saturationBuffer1.destroy();\r\n    // saturationBuffer2 kept - returned for recombination\r\n    hueBuffer1.destroy();\r\n    // hueBuffer2 kept - returned for recombination\r\n    outputBuffer.destroy();\r\n    valueVisBuffer.destroy();\r\n    saturationVisBuffer.destroy();\r\n    saturationMedianVisBuffer.destroy();\r\n    hueVisBuffer.destroy();\r\n    hueMedianVisBuffer.destroy();\r\n    extractParamsBuffer.destroy();\r\n    thresholdParamsBuffer.destroy();\r\n    medianParamsBuffer.destroy();\r\n    \r\n    return {\r\n        value: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(valueData.buffer, 0, byteSize),\r\n        },\r\n        saturation: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(satData.buffer, 0, byteSize),\r\n        },\r\n        saturationMedian: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(satMedianData.buffer, 0, byteSize),\r\n        },\r\n        hue: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(hueData.buffer, 0, byteSize),\r\n        },\r\n        hueMedian: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(hueMedianData.buffer, 0, byteSize),\r\n        },\r\n        final: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(finalData.buffer, 0, byteSize),\r\n        },\r\n        valueBuffer: valueBuffer2,  // Don't destroy - pass to value processing\r\n        saturationBuffer: saturationBuffer2,  // Don't destroy - pass to recombination\r\n        hueBuffer: hueBuffer2,  // Don't destroy - pass to recombination\r\n        width,\r\n        height,\r\n    };\r\n}\r\n\r\n/**\r\n * Recombine channels with a custom value buffer (e.g., skeletonized)\r\n * Uses the saturation and hue buffers from cleanup, but with processed value\r\n */\r\nexport async function recombineWithValue(\r\n    valueBuffer: GPUBuffer,  // u32 binary buffer (0=line, 1=background)\r\n    saturationBuffer: GPUBuffer,  // f32 buffer\r\n    hueBuffer: GPUBuffer,  // f32 buffer\r\n    width: number,\r\n    height: number,\r\n): Promise<RGBAImage> {\r\n    const { device } = await getGPUContext();\r\n    \r\n    const pixelCount = width * height;\r\n    const byteSize = pixelCount * 4;\r\n    \r\n    // Create output buffer\r\n    const outputBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffer\r\n    const paramsArray = new ArrayBuffer(8);\r\n    const paramsU32 = new Uint32Array(paramsArray);\r\n    paramsU32[0] = width;\r\n    paramsU32[1] = height;\r\n    \r\n    const paramsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(paramsBuffer, 0, paramsArray);\r\n    \r\n    // Create pipeline\r\n    const recombineModule = device.createShaderModule({ code: recombineShader });\r\n    const recombinePipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: recombineModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const workgroupsX = Math.ceil(width / 8);\r\n    const workgroupsY = Math.ceil(height / 8);\r\n    \r\n    // Recombine\r\n    const bindGroup = device.createBindGroup({\r\n        layout: recombinePipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: valueBuffer } },\r\n            { binding: 1, resource: { buffer: saturationBuffer } },\r\n            { binding: 2, resource: { buffer: hueBuffer } },\r\n            { binding: 3, resource: { buffer: outputBuffer } },\r\n            { binding: 4, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    const encoder = device.createCommandEncoder();\r\n    const pass = encoder.beginComputePass();\r\n    pass.setPipeline(recombinePipeline);\r\n    pass.setBindGroup(0, bindGroup);\r\n    pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n    pass.end();\r\n    device.queue.submit([encoder.finish()]);\r\n    await device.queue.onSubmittedWorkDone();\r\n    \r\n    // Read result\r\n    const finalData = await readGPUBuffer(device, outputBuffer, byteSize);\r\n    \r\n    // Cleanup\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: new Uint8ClampedArray(finalData.buffer, 0, byteSize),\r\n    };\r\n}\r\n", "/**\r\n * WebGPU value channel processing\r\n * - Convert to 1-bit binary format\r\n * - Weighted 3x3 median filter (cardinal directions weighted 2x)\r\n * - Skeletonization/thinning\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport { getGPUContext, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\n// Step 1: Weighted 3x3 median filter on packed binary data\r\n// Cardinals (N/E/S/W) counted twice, diagonals once = 12 total samples\r\n// Input/output: 1 = line (signal), 0 = background\r\nconst weightedMedianShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\nfn get_bit(data: ptr<storage, array<u32>, read>, x: u32, y: u32, w: u32, h: u32) -> u32 {\r\n    if (x >= w || y >= h) {\r\n        return 0u; // Background outside bounds\r\n    }\r\n    let pixel_idx = y * w + x;\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    return ((*data)[word_idx] >> bit_idx) & 1u;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let w = params.width;\r\n    let h = params.height;\r\n    \r\n    // Gather 3x3 neighborhood\r\n    var sum = 0u;\r\n    \r\n    // Corners = 4 samples (1x each)\r\n    sum += get_bit(&input, max(x, 1u) - 1u, max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, max(x, 1u) - 1u, min(y + 1u, h - 1u), w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), min(y + 1u, h - 1u), w, h);\r\n    \r\n    // Cardinals = 8 samples (2x each for weighting)\r\n    sum += get_bit(&input, x, max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, x, max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, x, min(y + 1u, h - 1u), w, h);\r\n    sum += get_bit(&input, x, min(y + 1u, h - 1u), w, h);\r\n    sum += get_bit(&input, max(x, 1u) - 1u, y, w, h);\r\n    sum += get_bit(&input, max(x, 1u) - 1u, y, w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), y, w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), y, w, h);\r\n    \r\n    // Center = 1 sample\r\n    sum += get_bit(&input, x, y, w, h);\r\n    \r\n    // Total: 4 corners + 8 cardinals + 1 center = 13 samples\r\n    // Median threshold: keep if >= 7 samples are set\r\n    let median_bit = u32(sum >= 7u);\r\n    \r\n    if (median_bit == 1u) {\r\n        let pixel_idx = y * w + x;\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n    }\r\n}\r\n`;// Step 2: Pure Zhang-Suen skeletonization algorithm\r\n// Input/output: 1 = line (signal), 0 = background\r\nconst skeletonizeShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n@group(0) @binding(3) var<storage, read_write> change_counter: array<atomic<u32>>;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    iteration: u32,  // 0 or 1 for two-pass algorithm\r\n    _padding: u32,\r\n}\r\n\r\nfn get_bit(data: ptr<storage, array<u32>, read>, x: i32, y: i32, w: u32, h: u32) -> u32 {\r\n    if (x < 0 || y < 0 || x >= i32(w) || y >= i32(h)) {\r\n        return 0u; // Background outside bounds\r\n    }\r\n    let pixel_idx = u32(y) * w + u32(x);\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    return (input[word_idx] >> bit_idx) & 1u;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = i32(global_id.x);\r\n    let y = i32(global_id.y);\r\n    \r\n    if (x >= i32(params.width) || y >= i32(params.height)) {\r\n        return;\r\n    }\r\n    \r\n    let w = params.width;\r\n    let h = params.height;\r\n    \r\n    // Get center pixel (1 = line, 0 = background)\r\n    let p1 = get_bit(&input, x, y, w, h);\r\n    \r\n    // Only process line pixels\r\n    if (p1 == 0u) {\r\n        return;\r\n    }\r\n    \r\n    // Get 8-neighborhood in Zhang-Suen order (P2-P9):\r\n    // P9 P2 P3\r\n    // P8 P1 P4\r\n    // P7 P6 P5\r\n    let p2 = get_bit(&input, x,     y - 1, w, h);  // N\r\n    let p3 = get_bit(&input, x + 1, y - 1, w, h);  // NE\r\n    let p4 = get_bit(&input, x + 1, y,     w, h);  // E\r\n    let p5 = get_bit(&input, x + 1, y + 1, w, h);  // SE\r\n    let p6 = get_bit(&input, x,     y + 1, w, h);  // S\r\n    let p7 = get_bit(&input, x - 1, y + 1, w, h);  // SW\r\n    let p8 = get_bit(&input, x - 1, y,     w, h);  // W\r\n    let p9 = get_bit(&input, x - 1, y - 1, w, h);  // NW\r\n    \r\n    // Condition 1: 2 <= B(P1) <= 6\r\n    // B(P1) = number of line neighbors\r\n    let b = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9;\r\n    if (b < 2u || b > 6u) {\r\n        // Keep pixel\r\n        let pixel_idx = u32(y) * w + u32(x);\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n        return;\r\n    }\r\n    \r\n    // Condition 2: A(P1) = 1\r\n    // A(P1) = number of 0->1 transitions in ordered sequence P2,P3,...,P9,P2\r\n    var a = 0u;\r\n    if (p2 == 0u && p3 == 1u) { a += 1u; }\r\n    if (p3 == 0u && p4 == 1u) { a += 1u; }\r\n    if (p4 == 0u && p5 == 1u) { a += 1u; }\r\n    if (p5 == 0u && p6 == 1u) { a += 1u; }\r\n    if (p6 == 0u && p7 == 1u) { a += 1u; }\r\n    if (p7 == 0u && p8 == 1u) { a += 1u; }\r\n    if (p8 == 0u && p9 == 1u) { a += 1u; }\r\n    if (p9 == 0u && p2 == 1u) { a += 1u; }\r\n    \r\n    if (a != 1u) {\r\n        // Keep pixel\r\n        let pixel_idx = u32(y) * w + u32(x);\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n        return;\r\n    }\r\n    \r\n    // Conditions 3 & 4 depend on iteration (step 1 vs step 2)\r\n    // BOTH conditions must be satisfied (both products = 0) to delete\r\n    var should_delete = false;\r\n    \r\n    if (params.iteration == 0u) {\r\n        // Step 1:\r\n        // Condition 3: P2 * P4 * P6 = 0 (at least one of N, E, S is background)\r\n        // Condition 4: P4 * P6 * P8 = 0 (at least one of E, S, W is background)\r\n        if ((p2 * p4 * p6) == 0u && (p4 * p6 * p8) == 0u) {\r\n            should_delete = true;\r\n        }\r\n    } else {\r\n        // Step 2:\r\n        // Condition 3: P2 * P4 * P8 = 0 (at least one of N, E, W is background)\r\n        // Condition 4: P2 * P6 * P8 = 0 (at least one of N, S, W is background)\r\n        if ((p2 * p4 * p8) == 0u && (p2 * p6 * p8) == 0u) {\r\n            should_delete = true;\r\n        }\r\n    }\r\n    \r\n    if (!should_delete) {\r\n        let pixel_idx = u32(y) * w + u32(x);\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n    } else {\r\n        // Pixel was deleted - increment change counter\r\n        atomicAdd(&change_counter[0], 1u);\r\n    }\r\n}\r\n`;\r\n\r\n// Helper: Convert packed binary to grayscale RGBA for visualization\r\n// Input: 1 = line (black), 0 = background (white)\r\nconst binaryToRGBAShader = `\r\n@group(0) @binding(0) var<storage, read> binary_in: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> rgba_out: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    let bit = (binary_in[word_idx] >> bit_idx) & 1u;\r\n    \r\n    // 1 = line (black), 0 = background (white)\r\n    let gray = (1u - bit) * 255u;\r\n    \r\n    rgba_out[pixel_idx] = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\nexport interface ValueProcessResults {\r\n    median: RGBAImage;           // After weighted median filter\r\n    skeleton: RGBAImage;         // After skeletonization\r\n    skeletonBuffer: GPUBuffer;   // Binary skeleton buffer (u32: 0=line, 1=background)\r\n}\r\n\r\n/**\r\n * Process value channel: weighted median, skeletonization\r\n * Input valueBuffer is already binary (u32: 0=line, 1=background)\r\n */\r\nexport async function processValueChannel(\r\n    valueBuffer: GPUBuffer,  // u32 array (binary) from cleanup\r\n    width: number,\r\n    height: number,\r\n): Promise<ValueProcessResults> {\r\n    const { device } = await getGPUContext();\r\n    \r\n    const pixelCount = width * height;\r\n    const binaryWordCount = Math.ceil(pixelCount / 32);  // Pack 32 pixels per u32\r\n    const binaryByteSize = binaryWordCount * 4;\r\n    const rgbaByteSize = pixelCount * 4;\r\n    \r\n    console.log(`Value processing: ${width}x${height}`);\r\n    \r\n    // Create binary buffers (unpacked: u32 per pixel)\r\n    // Input valueBuffer is already binary, use it directly\r\n    \r\n    const binaryBuffer2 = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const binaryBuffer3 = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const binaryBuffer4 = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create temporary buffer for intermediate pass results\r\n    const binaryBufferTemp = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    // Create RGBA output buffers for visualization\r\n    const rgbaBuffer1 = device.createBuffer({\r\n        size: rgbaByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const rgbaBuffer2 = device.createBuffer({\r\n        size: rgbaByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffer\r\n    const params = new Uint32Array([width, height]);\r\n    const paramsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(paramsBuffer, 0, params);\r\n    \r\n    // Create skeleton params buffer (with iteration field)\r\n    const skeletonParamsBuffer = device.createBuffer({\r\n        size: 16,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    // Create change counter buffer for convergence detection\r\n    const changeCounterBuffer = device.createBuffer({\r\n        size: 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create staging buffer for reading back the change counter\r\n    const stagingBuffer = device.createBuffer({\r\n        size: 4,\r\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    // Create shader modules\r\n    const medianModule = device.createShaderModule({ code: weightedMedianShader });\r\n    const skeletonModule = device.createShaderModule({ code: skeletonizeShader });\r\n    const toRGBAModule = device.createShaderModule({ code: binaryToRGBAShader });\r\n    \r\n    // Create pipelines\r\n    const medianPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: medianModule, entryPoint: \"main\" },\r\n    });    const skeletonPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: skeletonModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const toRGBAPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: toRGBAModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const workgroupsX = Math.ceil(width / 8);\r\n    const workgroupsY = Math.ceil(height / 8);\r\n    \r\n    // Clear binary buffers (atomic operations require starting at 0)\r\n    device.queue.writeBuffer(binaryBuffer2, 0, new Uint32Array(binaryWordCount));\r\n    device.queue.writeBuffer(binaryBuffer3, 0, new Uint32Array(binaryWordCount));\r\n    device.queue.writeBuffer(binaryBuffer4, 0, new Uint32Array(binaryWordCount));\r\n    \r\n    // Pass 1: Weighted median filter (input is valueBuffer - already binary)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: medianPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer } },\r\n                { binding: 1, resource: { buffer: binaryBuffer2 } },\r\n                { binding: 2, resource: { buffer: paramsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(medianPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 2: Skeletonization (Zhang-Suen algorithm - needs multiple iterations)\r\n    // Start from binaryBuffer2 (median output), copy to binaryBuffer3, then ping-pong between 3 and 4\r\n    // Run 4 iterations (2 passes each)\r\n    \r\n    // First, copy median result to binaryBuffer3 so we don't modify binaryBuffer2\r\n    {\r\n        const encoder = device.createCommandEncoder();\r\n        encoder.copyBufferToBuffer(binaryBuffer2, 0, binaryBuffer3, 0, binaryByteSize);\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Run up to 20 iterations, but exit early if converged\r\n    let convergedIter = -1;\r\n    for (let iter = 0; iter < 20; iter++) {\r\n        const inputBuffer = (iter % 2 == 0) ? binaryBuffer3 : binaryBuffer4;\r\n        const outputBuffer = (iter % 2 == 0) ? binaryBuffer4 : binaryBuffer3;\r\n        \r\n        // Clear temp buffer and output buffer, reset change counter\r\n        device.queue.writeBuffer(binaryBufferTemp, 0, new Uint32Array(binaryWordCount));\r\n        device.queue.writeBuffer(outputBuffer, 0, new Uint32Array(binaryWordCount));\r\n        device.queue.writeBuffer(changeCounterBuffer, 0, new Uint32Array(1));\r\n        \r\n        // Pass 0 - first pass of Zhang-Suen: input \u2192 temp\r\n        {\r\n            const skeletonParams = new Uint32Array([width, height, 0, 0]);\r\n            device.queue.writeBuffer(skeletonParamsBuffer, 0, skeletonParams);\r\n            \r\n            const bindGroup = device.createBindGroup({\r\n                layout: skeletonPipeline.getBindGroupLayout(0),\r\n                entries: [\r\n                    { binding: 0, resource: { buffer: inputBuffer } },\r\n                    { binding: 1, resource: { buffer: binaryBufferTemp } },\r\n                    { binding: 2, resource: { buffer: skeletonParamsBuffer } },\r\n                    { binding: 3, resource: { buffer: changeCounterBuffer } },\r\n                ],\r\n            });\r\n            \r\n            const encoder = device.createCommandEncoder();\r\n            const pass = encoder.beginComputePass();\r\n            pass.setPipeline(skeletonPipeline);\r\n            pass.setBindGroup(0, bindGroup);\r\n            pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n            pass.end();\r\n            device.queue.submit([encoder.finish()]);\r\n            await device.queue.onSubmittedWorkDone();\r\n        }\r\n        \r\n        // Pass 1 - second pass of Zhang-Suen: temp \u2192 output\r\n        {\r\n            const skeletonParams = new Uint32Array([width, height, 1, 0]);\r\n            device.queue.writeBuffer(skeletonParamsBuffer, 0, skeletonParams);\r\n            \r\n            const bindGroup = device.createBindGroup({\r\n                layout: skeletonPipeline.getBindGroupLayout(0),\r\n                entries: [\r\n                    { binding: 0, resource: { buffer: binaryBufferTemp } },\r\n                    { binding: 1, resource: { buffer: outputBuffer } },\r\n                    { binding: 2, resource: { buffer: skeletonParamsBuffer } },\r\n                    { binding: 3, resource: { buffer: changeCounterBuffer } },\r\n                ],\r\n            });\r\n            \r\n            const encoder = device.createCommandEncoder();\r\n            const pass = encoder.beginComputePass();\r\n            pass.setPipeline(skeletonPipeline);\r\n            pass.setBindGroup(0, bindGroup);\r\n            pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n            pass.end();\r\n            device.queue.submit([encoder.finish()]);\r\n            await device.queue.onSubmittedWorkDone();\r\n        }\r\n        \r\n        // Check for convergence by reading the change counter\r\n        {\r\n            const encoder = device.createCommandEncoder();\r\n            encoder.copyBufferToBuffer(changeCounterBuffer, 0, stagingBuffer, 0, 4);\r\n            device.queue.submit([encoder.finish()]);\r\n            await device.queue.onSubmittedWorkDone();\r\n            \r\n            await stagingBuffer.mapAsync(GPUMapMode.READ);\r\n            const counterData = new Uint32Array(stagingBuffer.getMappedRange());\r\n            const changeCount = counterData[0];\r\n            stagingBuffer.unmap();\r\n            \r\n            if (changeCount === 0) {\r\n                convergedIter = iter;\r\n                console.log(`Zhang-Suen converged after ${iter + 1} iteration(s) (${(iter + 1) * 2} passes)`);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (convergedIter === -1) {\r\n        console.log(`Zhang-Suen completed maximum 20 iterations (40 passes) without full convergence`);\r\n    }\r\n    \r\n    // After iterations, result is in outputBuffer from the last iteration\r\n    // Iter 0: input=buf3, output=buf4\r\n    // Iter 1: input=buf4, output=buf3\r\n    const finalIterCount = convergedIter === -1 ? 19 : convergedIter;\r\n    const finalSkeletonBuffer = finalIterCount % 2 == 0 ? binaryBuffer4 : binaryBuffer3;\r\n    \r\n    // Convert binary stages to RGBA for visualization\r\n    // Median stage (binaryBuffer2 preserved from Pass 1)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: toRGBAPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: binaryBuffer2 } },\r\n                { binding: 1, resource: { buffer: rgbaBuffer1 } },\r\n                { binding: 2, resource: { buffer: paramsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(toRGBAPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Skeleton stage\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: toRGBAPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: finalSkeletonBuffer } },\r\n                { binding: 1, resource: { buffer: rgbaBuffer2 } },\r\n                { binding: 2, resource: { buffer: paramsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(toRGBAPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Read back results\r\n    const [medianData, skeletonData] = await Promise.all([\r\n        readGPUBuffer(device, rgbaBuffer1, rgbaByteSize),\r\n        readGPUBuffer(device, rgbaBuffer2, rgbaByteSize),\r\n    ]);\r\n    \r\n    console.log(`Value processing complete`);\r\n    \r\n    // Cleanup (keep binaryBuffer3 (finalSkeletonBuffer) for recombination)\r\n    binaryBuffer2.destroy();\r\n    // binaryBuffer3 (finalSkeletonBuffer) kept - returned for recombination\r\n    binaryBuffer4.destroy();\r\n    rgbaBuffer1.destroy();\r\n    rgbaBuffer2.destroy();\r\n    paramsBuffer.destroy();\r\n    skeletonParamsBuffer.destroy();\r\n    \r\n    return {\r\n        median: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(medianData.buffer, 0, rgbaByteSize),\r\n        },\r\n        skeleton: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(skeletonData.buffer, 0, rgbaByteSize),\r\n        },\r\n        skeletonBuffer: finalSkeletonBuffer,  // Don't destroy - pass to recombination\r\n    };\r\n}\r\n", "/**\r\n * WebGPU palettization operation\r\n * Quantizes RGBA image to nearest colors in palette\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport type { PalettizedImage } from \"../formats/palettized.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<storage, read> palette: array<u32>;\r\n@group(0) @binding(3) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    palette_size: u32,\r\n}\r\n\r\nfn color_distance(c1: vec3<f32>, c2: vec3<f32>) -> f32 {\r\n    let diff = c1 - c2;\r\n    return dot(diff, diff);\r\n}\r\n\r\nfn luminosity(color: vec3<f32>) -> f32 {\r\n    return 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let idx = y * params.width + x;\r\n    let pixel = input[idx];\r\n    \r\n    // Unpack RGB\r\n    let r = f32(pixel & 0xFFu) / 255.0;\r\n    let g = f32((pixel >> 8u) & 0xFFu) / 255.0;\r\n    let b = f32((pixel >> 16u) & 0xFFu) / 255.0;\r\n    let color = vec3<f32>(r, g, b);\r\n    \r\n    // If input pixel is black (luminosity < threshold), force to white (palette index 0)\r\n    const threshold = 0.10;\r\n    let lum = luminosity(color);\r\n    if (lum < threshold) {\r\n        output[idx] = 0u;\r\n        return;\r\n    }\r\n    \r\n    // Pre-compute which palette indices are black (luminosity < 20%)\r\n    var is_black: array<bool, 16>;\r\n    for (var i = 0u; i < params.palette_size; i++) {\r\n        let pal_pixel = palette[i];\r\n        let pr = f32(pal_pixel & 0xFFu) / 255.0;\r\n        let pg = f32((pal_pixel >> 8u) & 0xFFu) / 255.0;\r\n        let pb = f32((pal_pixel >> 16u) & 0xFFu) / 255.0;\r\n        let pal_color = vec3<f32>(pr, pg, pb);\r\n        let pal_lum = luminosity(pal_color);\r\n        is_black[i] = pal_lum < threshold;\r\n    }\r\n    \r\n    // Find nearest palette color, skipping black palette entries\r\n    var best_idx: u32 = 0u;\r\n    var best_dist = 999999.0;\r\n    \r\n    for (var i = 0u; i < params.palette_size; i++) {\r\n        // Skip black palette colors\r\n        if (is_black[i]) {\r\n            continue;\r\n        }\r\n        \r\n        let pal_pixel = palette[i];\r\n        let pr = f32(pal_pixel & 0xFFu) / 255.0;\r\n        let pg = f32((pal_pixel >> 8u) & 0xFFu) / 255.0;\r\n        let pb = f32((pal_pixel >> 16u) & 0xFFu) / 255.0;\r\n        let pal_color = vec3<f32>(pr, pg, pb);\r\n        \r\n        let dist = color_distance(color, pal_color);\r\n        if (dist < best_dist) {\r\n            best_dist = dist;\r\n            best_idx = i;\r\n        }\r\n    }\r\n    \r\n    // Pack 2 pixels per u32 (4 bits each)\r\n    // Each workgroup handles one pixel, we'll pack later\r\n    output[idx] = best_idx;\r\n}\r\n`;\r\n\r\n/**\r\n * Palettize RGBA image using WebGPU\r\n * Returns palettized image with 4 bits per pixel\r\n */\r\nexport async function palettizeGPU(\r\n    image: RGBAImage,\r\n    palette: Uint8ClampedArray, // RGBA palette, length = paletteSize * 4\r\n): Promise<PalettizedImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const paletteSize = palette.length / 4;\r\n    if (paletteSize !== 16) {\r\n        throw new Error(\"GPU palettization currently only supports 16-color palettes\");\r\n    }\r\n    \r\n    // Convert RGBA bytes to u32 arrays - must copy to ensure alignment\r\n    const pixelCount = width * height;\r\n    const input = new Uint32Array(pixelCount);\r\n    const paletteU32 = new Uint32Array(paletteSize);\r\n    \r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        input[i] = dataView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    const paletteView = new DataView(palette.buffer, palette.byteOffset, palette.byteLength);\r\n    for (let i = 0; i < paletteSize; i++) {\r\n        paletteU32[i] = paletteView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(input.buffer, input.byteOffset, input.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: pixelCount * 4, // Temporary: one u32 per pixel\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paletteBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(paletteU32.buffer, paletteU32.byteOffset, paletteU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const paramsData = new Uint32Array([width, height, paletteSize, 0]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paletteBuffer } },\r\n            { binding: 3, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results (unpacked indices)\r\n    const indices = await readGPUBuffer(device, outputBuffer, pixelCount * 4);\r\n    const indicesU32 = new Uint32Array(indices.buffer);\r\n    \r\n    // Pack 2 pixels per byte (4 bits each)\r\n    const packedSize = Math.ceil(pixelCount / 2);\r\n    const packed = new Uint8Array(packedSize);\r\n    \r\n    for (let i = 0; i < pixelCount; i++) {\r\n        const byteIdx = Math.floor(i / 2);\r\n        const isHighNibble = (i % 2) === 0;\r\n        const paletteIdx = indicesU32[i] & 0xF;\r\n        \r\n        if (isHighNibble) {\r\n            packed[byteIdx] = (paletteIdx << 4);\r\n        } else {\r\n            packed[byteIdx] |= paletteIdx;\r\n        }\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paletteBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: packed,\r\n        palette: new Uint32Array(palette),\r\n    };\r\n}\r\n", "/**\r\n * Palettized image format\r\n * 4 bits per pixel (16 colors), stored as 2 pixels per byte\r\n * High nibble = left pixel, low nibble = right pixel\r\n */\r\nexport interface PalettizedImage {\r\n    width: number;\r\n    height: number;\r\n    data: Uint8Array; // length = ceil(width * height / 2)\r\n    palette?: Uint32Array; // optional RGBA palette (16 colors)\r\n}\r\n\r\n/**\r\n * Create an empty palettized image\r\n */\r\nexport function createPalettizedImage(\r\n    width: number,\r\n    height: number,\r\n    palette?: Uint32Array,\r\n): PalettizedImage {\r\n    const size = Math.ceil((width * height) / 2);\r\n    return {\r\n        width,\r\n        height,\r\n        data: new Uint8Array(size),\r\n        palette,\r\n    };\r\n}\r\n\r\n/**\r\n * Get pixel value at (x, y)\r\n * Returns index 0-15\r\n */\r\nexport function getPixelPal(\r\n    img: PalettizedImage,\r\n    x: number,\r\n    y: number,\r\n): number {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 2);\r\n    const isHighNibble = pixelIndex % 2 === 0;\r\n\r\n    if (isHighNibble) {\r\n        return (img.data[byteIndex] >> 4) & 0x0f;\r\n    } else {\r\n        return img.data[byteIndex] & 0x0f;\r\n    }\r\n}\r\n\r\n/**\r\n * Set pixel value at (x, y)\r\n * value must be 0-15\r\n */\r\nexport function setPixelPal(\r\n    img: PalettizedImage,\r\n    x: number,\r\n    y: number,\r\n    value: number,\r\n): void {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 2);\r\n    const isHighNibble = pixelIndex % 2 === 0;\r\n\r\n    value = value & 0x0f; // ensure 0-15\r\n\r\n    if (isHighNibble) {\r\n        img.data[byteIndex] = (img.data[byteIndex] & 0x0f) | (value << 4);\r\n    } else {\r\n        img.data[byteIndex] = (img.data[byteIndex] & 0xf0) | value;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert palettized image back to RGBA for export\r\n */\r\nexport function palettizedToRGBA(img: PalettizedImage): { width: number; height: number; data: Uint8ClampedArray } {\r\n    const palette = img.palette || DEFAULT_PALETTE;\r\n    const rgbaData = new Uint8ClampedArray(img.width * img.height * 4);\r\n    \r\n    for (let y = 0; y < img.height; y++) {\r\n        for (let x = 0; x < img.width; x++) {\r\n            const paletteIdx = getPixelPal(img, x, y);\r\n            const color = palette[paletteIdx];\r\n            \r\n            const pixelOffset = (y * img.width + x) * 4;\r\n            rgbaData[pixelOffset] = color & 0xFF;           // R\r\n            rgbaData[pixelOffset + 1] = (color >> 8) & 0xFF;  // G\r\n            rgbaData[pixelOffset + 2] = (color >> 16) & 0xFF; // B\r\n            rgbaData[pixelOffset + 3] = (color >> 24) & 0xFF; // A\r\n        }\r\n    }\r\n    \r\n    return {\r\n        width: img.width,\r\n        height: img.height,\r\n        data: rgbaData,\r\n    };\r\n}\r\n\r\n/**\r\n * Default palette\r\n * The classic 8-bit color palette, https://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_color_formats#3-bit_RGB,\r\n * with orange instead of yellow to improve visibility, plus one gray.\r\n */\r\nexport const DEFAULT_PALETTE: Uint32Array = new Uint32Array([\r\n    0xffffffff, // 0: white\r\n    0x000000ff, // 1: black\r\n    0xff0000ff, // 2: red\r\n    0x00ff00ff, // 3: green\r\n    0x0000ffff, // 4: blue\r\n    0xffaa00ff, // 5: orange (yellow is too similar to white)\r\n    0xff00ffff, // 6: magenta\r\n    0x00ffffff, // 7: cyan\r\n    0x808080ff, // 8: gray\r\n]);\r\n", "/**\r\n * WebGPU 3x3 median filter operation\r\n * Operates on palettized images (4-bit per pixel)\r\n */\r\n\r\nimport type { PalettizedImage } from \"../formats/palettized.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\nimport { getPixelPal } from \"../formats/palettized.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\nfn get_pixel(data: ptr<storage, array<u32>>, x: u32, y: u32, w: u32) -> u32 {\r\n    let idx = y * w + x;\r\n    return (*data)[idx] & 0xFu;\r\n}\r\n\r\nfn mode_nonzero(values: array<u32, 9>, center: u32) -> u32 {\r\n    // Count occurrences of each color\r\n    var counts: array<u32, 16>;\r\n    for (var i = 0u; i < 16u; i++) {\r\n        counts[i] = 0u;\r\n    }\r\n    \r\n    for (var i = 0u; i < 9u; i++) {\r\n        let val = values[i];\r\n        counts[val] = counts[val] + 1u;\r\n    }\r\n    \r\n    // Strategy: Only change center pixel if it's clearly an outlier\r\n    // Look at the 8 neighbors (excluding center)\r\n    var neighbor_counts: array<u32, 16>;\r\n    for (var i = 0u; i < 16u; i++) {\r\n        neighbor_counts[i] = 0u;\r\n    }\r\n    \r\n    // Count only the 8 neighbors (skip center at index 4)\r\n    for (var i = 0u; i < 9u; i++) {\r\n        if (i != 4u) {\r\n            let val = values[i];\r\n            neighbor_counts[val] = neighbor_counts[val] + 1u;\r\n        }\r\n    }\r\n    \r\n    // Find the most common neighbor color\r\n    var max_neighbor_count = 0u;\r\n    var dominant_neighbor = 0u;\r\n    for (var color = 0u; color < 16u; color++) {\r\n        if (neighbor_counts[color] > max_neighbor_count) {\r\n            max_neighbor_count = neighbor_counts[color];\r\n            dominant_neighbor = color;\r\n        }\r\n    }\r\n    \r\n    // Decision logic:\r\n    // 1. If center is different from all 8 neighbors, it's a single-pixel island - replace it\r\n    // 2. If 6+ neighbors agree on a color different from center, center is likely a cavity/barnacle - replace it\r\n    // 3. Otherwise, keep center as-is to preserve edges\r\n    \r\n    if (neighbor_counts[center] == 0u) {\r\n        // Center is completely isolated from all 8 neighbors - definitely noise\r\n        return dominant_neighbor;\r\n    } else if (max_neighbor_count >= 6u && dominant_neighbor != center) {\r\n        // Strong majority of neighbors agree on a different color - likely cavity or barnacle\r\n        return dominant_neighbor;\r\n    }\r\n    \r\n    // Keep center pixel - it's part of a legitimate feature\r\n    return center;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    // Clamp coordinates for edge handling\r\n    let x_prev = max(x, 1u) - 1u;\r\n    let x_next = min(x + 1u, params.width - 1u);\r\n    let y_prev = max(y, 1u) - 1u;\r\n    let y_next = min(y + 1u, params.height - 1u);\r\n    \r\n    // Gather 3x3 neighborhood\r\n    var values: array<u32, 9>;\r\n    values[0] = get_pixel(&input, x_prev, y_prev, params.width);\r\n    values[1] = get_pixel(&input, x,      y_prev, params.width);\r\n    values[2] = get_pixel(&input, x_next, y_prev, params.width);\r\n    values[3] = get_pixel(&input, x_prev, y,      params.width);\r\n    values[4] = get_pixel(&input, x,      y,      params.width);\r\n    values[5] = get_pixel(&input, x_next, y,      params.width);\r\n    values[6] = get_pixel(&input, x_prev, y_next, params.width);\r\n    values[7] = get_pixel(&input, x,      y_next, params.width);\r\n    values[8] = get_pixel(&input, x_next, y_next, params.width);\r\n    \r\n    let center = values[4];\r\n    let result = mode_nonzero(values, center);\r\n    \r\n    // Store result (unpacked, one u32 per pixel for now)\r\n    let idx = y * params.width + x;\r\n    output[idx] = result;\r\n}\r\n`;\r\n\r\n/**\r\n * Apply 3x3 median filter using WebGPU\r\n * Operates on palettized images\r\n */\r\nexport async function median3x3GPU(\r\n    image: PalettizedImage,\r\n): Promise<PalettizedImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, palette } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    \r\n    // Unpack to u32 array (one pixel per u32 for easier GPU access)\r\n    const unpacked = new Uint32Array(pixelCount);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        unpacked[i] = getPixelPal(image, i % width, Math.floor(i / width));\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(unpacked.buffer, unpacked.byteOffset, unpacked.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: unpacked.byteLength,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paramsData = new Uint32Array([width, height]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const outputData = await readGPUBuffer(device, outputBuffer, unpacked.byteLength);\r\n    const outputU32 = new Uint32Array(outputData.buffer);\r\n    \r\n    // Pack back to 4-bit format\r\n    const packedSize = Math.ceil(pixelCount / 2);\r\n    const packed = new Uint8Array(packedSize);\r\n    \r\n    for (let i = 0; i < pixelCount; i++) {\r\n        const byteIdx = Math.floor(i / 2);\r\n        const isHighNibble = (i % 2) === 0;\r\n        const paletteIdx = outputU32[i] & 0xF;\r\n        \r\n        if (isHighNibble) {\r\n            packed[byteIdx] = (paletteIdx << 4);\r\n        } else {\r\n            packed[byteIdx] |= paletteIdx;\r\n        }\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: packed,\r\n        palette: palette ? new Uint32Array(palette) : undefined,\r\n    };\r\n}\r\n", "/**\r\n * WebGPU black pixel extraction operation\r\n * Extracts black pixels from RGBA image based on luminosity threshold\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport type { BinaryImage } from \"../formats/binary.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input_rgba: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    threshold: f32,\r\n}\r\n\r\n// Set a bit in the bit-packed array using atomics\r\nfn set_pixel_bit(x: u32, y: u32, w: u32, value: u32) {\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    let bit_position = byte_shift + bit_idx;\r\n    \r\n    let bit_mask = 1u << bit_position;\r\n    \r\n    if (value == 1u) {\r\n        atomicOr(&output[u32_idx], bit_mask);\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let idx = y * params.width + x;\r\n    let pixel = input_rgba[idx];\r\n    \r\n    // Unpack RGBA (little-endian: RGBA in memory = ABGR in u32)\r\n    let r = f32(pixel & 0xFFu) / 255.0;\r\n    let g = f32((pixel >> 8u) & 0xFFu) / 255.0;\r\n    let b = f32((pixel >> 16u) & 0xFFu) / 255.0;\r\n    \r\n    // Calculate luminosity\r\n    let luminosity = 0.299 * r + 0.587 * g + 0.114 * b;\r\n    \r\n    // If below threshold, mark as black (1)\r\n    if (luminosity < params.threshold) {\r\n        set_pixel_bit(x, y, params.width, 1u);\r\n    }\r\n}\r\n`;\r\n\r\n/**\r\n * Extract black pixels from RGBA image using WebGPU\r\n * Pixels with luminosity below threshold are marked as black (1)\r\n */\r\nexport async function extractBlackGPU(\r\n    image: RGBAImage,\r\n    luminosityThreshold: number = 0.20,\r\n): Promise<BinaryImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    \r\n    // Convert RGBA to u32 array\r\n    const inputU32 = new Uint32Array(pixelCount);\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        inputU32[i] = dataView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    // Create output buffer for bit-packed binary image\r\n    const byteCount = Math.ceil(pixelCount / 8);\r\n    const u32Count = Math.ceil(byteCount / 4);\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(inputU32.buffer, inputU32.byteOffset, inputU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: u32Count * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffer with proper types: u32, u32, f32, padding\r\n    const paramsArray = new ArrayBuffer(16); // 3 values + padding\r\n    const paramsU32 = new Uint32Array(paramsArray);\r\n    const paramsF32 = new Float32Array(paramsArray);\r\n    paramsU32[0] = width;  // u32\r\n    paramsU32[1] = height; // u32\r\n    paramsF32[2] = luminosityThreshold; // f32\r\n    \r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(paramsArray),\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const resultU32 = await readGPUBuffer(device, outputBuffer, u32Count * 4);\r\n    const resultU32Array = new Uint32Array(resultU32.buffer);\r\n    \r\n    // Convert back to byte array\r\n    const resultData = new Uint8Array(byteCount);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        resultData[i] = (resultU32Array[u32Idx] >> shift) & 0xff;\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: resultData,\r\n    };\r\n}\r\n", "/**\r\n * WebGPU bloom filter operation for binary images\r\n * For each pixel, if any pixel in its 3x3 neighborhood is black (1), set it to black\r\n */\r\n\r\nimport type { BinaryImage } from \"../formats/binary.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Get a bit from the bit-packed array\r\n// Data format: 8 pixels per byte, MSB first, bytes packed into u32s (little-endian)\r\nfn get_pixel_bit(x: u32, y: u32, w: u32, h: u32) -> u32 {\r\n    if (x >= w || y >= h) {\r\n        return 0u;\r\n    }\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    \r\n    let u32_val = input[u32_idx];\r\n    let byte_val = (u32_val >> byte_shift) & 0xFFu;\r\n    let bit_val = (byte_val >> bit_idx) & 1u;\r\n    return bit_val;\r\n}\r\n\r\n// Set a bit in the bit-packed array using atomics\r\nfn set_pixel_bit(x: u32, y: u32, w: u32, value: u32) {\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    let bit_position = byte_shift + bit_idx;\r\n    \r\n    let bit_mask = 1u << bit_position;\r\n    \r\n    if (value == 1u) {\r\n        atomicOr(&output[u32_idx], bit_mask);\r\n    } else {\r\n        atomicAnd(&output[u32_idx], ~bit_mask);\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    // Check 3x3 neighborhood for any black pixels (value == 1)\r\n    var has_black = false;\r\n    for (var dy = -1; dy <= 1; dy++) {\r\n        for (var dx = -1; dx <= 1; dx++) {\r\n            let nx = i32(x) + dx;\r\n            let ny = i32(y) + dy;\r\n            \r\n            if (nx >= 0 && ny >= 0 && nx < i32(params.width) && ny < i32(params.height)) {\r\n                let bit = get_pixel_bit(u32(nx), u32(ny), params.width, params.height);\r\n                if (bit == 1u) {\r\n                    has_black = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Set output pixel\r\n    set_pixel_bit(x, y, params.width, select(0u, 1u, has_black));\r\n}\r\n`;\r\n\r\n/**\r\n * Apply 3x3 bloom filter to binary image using WebGPU\r\n * Sets a pixel to black (1) if any pixel in its 3x3 neighborhood is black\r\n */\r\nexport async function bloomFilter3x3GPU(image: BinaryImage): Promise<BinaryImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    const byteCount = Math.ceil(pixelCount / 8);\r\n    \r\n    // Convert to u32 array for GPU (pad to 4-byte alignment)\r\n    const u32Count = Math.ceil(byteCount / 4);\r\n    const inputU32 = new Uint32Array(u32Count);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        inputU32[u32Idx] |= (data[i] << shift);\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(inputU32.buffer, inputU32.byteOffset, inputU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: u32Count * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paramsData = new Uint32Array([width, height]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const resultU32 = await readGPUBuffer(device, outputBuffer, u32Count * 4);\r\n    const resultU32Array = new Uint32Array(resultU32.buffer);\r\n    \r\n    // Convert back to byte array\r\n    const resultData = new Uint8Array(byteCount);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        resultData[i] = (resultU32Array[u32Idx] >> shift) & 0xff;\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: resultData,\r\n    };\r\n}\r\n", "/**\r\n * WebGPU black subtraction operation\r\n * Subtracts bloom-filtered black from RGBA image by setting black pixels to white\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport type { BinaryImage } from \"../formats/binary.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input_rgba: array<u32>;\r\n@group(0) @binding(1) var<storage, read> bloom_mask: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(3) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Get a bit from the bit-packed binary image\r\n// Data format: 8 pixels per byte, MSB first, bytes packed into u32s (little-endian)\r\nfn get_pixel_bit(x: u32, y: u32, w: u32, h: u32) -> u32 {\r\n    if (x >= w || y >= h) {\r\n        return 0u;\r\n    }\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    \r\n    let u32_val = bloom_mask[u32_idx];\r\n    let byte_val = (u32_val >> byte_shift) & 0xFFu;\r\n    let bit_val = (byte_val >> bit_idx) & 1u;\r\n    return bit_val;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let idx = y * params.width + x;\r\n    let is_black = get_pixel_bit(x, y, params.width, params.height);\r\n    \r\n    if (is_black == 1u) {\r\n        // Set to white: RGBA = (255, 255, 255, 255)\r\n        // In little-endian u32: 0xFFFFFFFF\r\n        output[idx] = 0xFFFFFFFFu;\r\n    } else {\r\n        // Copy original pixel\r\n        output[idx] = input_rgba[idx];\r\n    }\r\n}\r\n`;\r\n\r\n/**\r\n * Subtract bloom-filtered black from RGBA image using WebGPU\r\n * Sets pixels to white where bloom mask is black (1)\r\n */\r\nexport async function subtractBlackGPU(\r\n    image: RGBAImage,\r\n    bloomFiltered: BinaryImage,\r\n): Promise<RGBAImage> {\r\n    if (image.width !== bloomFiltered.width || image.height !== bloomFiltered.height) {\r\n        throw new Error(\"Image dimensions must match\");\r\n    }\r\n    \r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    \r\n    // Convert RGBA to u32 array\r\n    const inputU32 = new Uint32Array(pixelCount);\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        inputU32[i] = dataView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    // Convert binary image to u32 array\r\n    const byteCount = bloomFiltered.data.length;\r\n    const u32Count = Math.ceil(byteCount / 4);\r\n    const maskU32 = new Uint32Array(u32Count);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        maskU32[u32Idx] |= (bloomFiltered.data[i] << shift);\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(inputU32.buffer, inputU32.byteOffset, inputU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const maskBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(maskU32.buffer, maskU32.byteOffset, maskU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: pixelCount * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paramsData = new Uint32Array([width, height]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: maskBuffer } },\r\n            { binding: 2, resource: { buffer: outputBuffer } },\r\n            { binding: 3, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const resultBytes = await readGPUBuffer(device, outputBuffer, pixelCount * 4);\r\n    const resultData = new Uint8ClampedArray(resultBytes);\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    maskBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: resultData,\r\n    };\r\n}\r\n", "/**\r\n * IndexedDB storage for uploaded files\r\n */\r\n\r\nconst DB_NAME = \"CleanPlansDB\";\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = \"files\";\r\n\r\nexport interface StoredFile {\r\n  id: string;\r\n  name: string;\r\n  type: string;\r\n  data: Uint8Array;\r\n  uploadedAt: number;\r\n  thumbnail?: string; // base64 data URL\r\n  palette?: string; // JSON serialized palette\r\n}\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nasync function openDB(): Promise<IDBDatabase> {\r\n  if (db) return db;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n    request.onerror = () => reject(request.error);\r\n    request.onsuccess = () => {\r\n      db = request.result;\r\n      resolve(db);\r\n    };\r\n\r\n    request.onupgradeneeded = (event) => {\r\n      const db = (event.target as IDBOpenDBRequest).result;\r\n      \r\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\r\n        const store = db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\r\n        store.createIndex(\"uploadedAt\", \"uploadedAt\", { unique: false });\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nexport async function saveFile(file: File, thumbnail?: string): Promise<string> {\r\n  const db = await openDB();\r\n  const id = crypto.randomUUID();\r\n  const arrayBuffer = await file.arrayBuffer();\r\n\r\n  const storedFile: StoredFile = {\r\n    id,\r\n    name: file.name,\r\n    type: file.type,\r\n    data: new Uint8Array(arrayBuffer),\r\n    uploadedAt: Date.now(),\r\n    thumbnail,\r\n  };\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.add(storedFile);\r\n\r\n    request.onsuccess = () => resolve(id);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function updateFile(id: string, updates: Partial<StoredFile>): Promise<void> {\r\n  const db = await openDB();\r\n  const existing = await getFile(id);\r\n  \r\n  if (!existing) {\r\n    throw new Error(`File ${id} not found`);\r\n  }\r\n\r\n  const updated = { ...existing, ...updates };\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.put(updated);\r\n\r\n    request.onsuccess = () => resolve();\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function getFile(id: string): Promise<StoredFile | null> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readonly\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.get(id);\r\n\r\n    request.onsuccess = () => resolve(request.result || null);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function listFiles(): Promise<StoredFile[]> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readonly\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.getAll();\r\n\r\n    request.onsuccess = () => {\r\n      const files = request.result as StoredFile[];\r\n      // Sort by most recent first\r\n      files.sort((a, b) => b.uploadedAt - a.uploadedAt);\r\n      resolve(files);\r\n    };\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function deleteFile(id: string): Promise<void> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.delete(id);\r\n\r\n    request.onsuccess = () => resolve();\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function clearAllFiles(): Promise<void> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.clear();\r\n\r\n    request.onsuccess = () => resolve();\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n", "/**\r\n * Utility functions for color conversion and helpers\r\n */\r\n\r\n// Convert u32 color to hex\r\nexport function u32ToHex(color: number): string {\r\n  const r = (color >> 24) & 0xff;\r\n  const g = (color >> 16) & 0xff;\r\n  const b = (color >> 8) & 0xff;\r\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\r\n}\r\n\r\n// Convert hex to RGBA values\r\nexport function hexToRGBA(hex: string): [number, number, number, number] {\r\n  const r = parseInt(hex.slice(1, 3), 16);\r\n  const g = parseInt(hex.slice(3, 5), 16);\r\n  const b = parseInt(hex.slice(5, 7), 16);\r\n  return [r, g, b, 255];\r\n}\r\n", "/**\r\n * Application state management\r\n * Using a state object to allow mutations from importing modules\r\n */\r\n\r\nimport type { RGBAImage } from \"../src/formats/rgba_image.ts\";\r\nimport type { PalettizedImage } from \"../src/formats/palettized.ts\";\r\nimport type { BinaryImage } from \"../src/formats/binary.ts\";\r\nimport { DEFAULT_PALETTE } from \"../src/formats/palettized.ts\";\r\nimport type { ProcessingStage, PaletteColor } from \"./types.ts\";\r\nimport type { VectorizedImage } from \"./vectorize.ts\";\r\nimport { u32ToHex } from \"./utils.ts\";\r\n\r\n// UI State\r\nexport const state = {\r\n  currentFileId: null as string | null,\r\n  currentPdfData: null as Uint8Array | null,\r\n  currentImage: null as RGBAImage | null,\r\n  currentSelectedPage: null as number | null,\r\n  pdfPageCount: 0,\r\n  cancelThumbnailLoading: false,\r\n\r\n  // Processing state\r\n  currentStage: \"cropped\" as ProcessingStage,\r\n  processedImages: new Map<ProcessingStage, RGBAImage | PalettizedImage | BinaryImage>(),\r\n  vectorizedImages: new Map<string, VectorizedImage>(), // e.g., \"color_1_vec\"\r\n\r\n  // Palette configuration\r\n  userPalette: Array.from(DEFAULT_PALETTE).map(color => ({\r\n    inputColor: u32ToHex(color),\r\n    outputColor: u32ToHex(color),\r\n    mapToBg: false,\r\n  })) as PaletteColor[],\r\n  currentPaletteName: \"\",\r\n\r\n  // Canvas/Viewport State\r\n  zoom: 1.0,\r\n  panX: 0,\r\n  panY: 0,\r\n  isPanning: false,\r\n  isDraggingCropHandle: false,\r\n  activeCropHandle: null as string | null,\r\n  cropRegion: null as { x: number; y: number; width: number; height: number } | null,\r\n  lastPanX: 0,\r\n  lastPanY: 0,\r\n\r\n  // Processing canvas state\r\n  processZoom: 1.0,\r\n  processPanX: 0,\r\n  processPanY: 0,\r\n  isProcessPanning: false,\r\n  lastProcessPanX: 0,\r\n  lastProcessPanY: 0,\r\n  processViewInitialized: false,\r\n  \r\n  // Vector overlay state\r\n  vectorOverlayEnabled: false,\r\n  vectorOverlayStage: null as string | null, // e.g., \"color_1_vec\"\r\n};\r\n", "/**\r\n * Canvas viewport and crop management\r\n */\r\n\r\nimport type { RGBAImage } from \"../src/formats/rgba_image.ts\";\r\nimport { state } from \"./state.ts\";\r\n\r\n// DOM Elements (initialized in main.ts)\r\nexport let canvasContainer: HTMLDivElement;\r\nexport let mainCanvas: HTMLCanvasElement;\r\nexport let ctx: CanvasRenderingContext2D;\r\nexport let cropOverlay: HTMLCanvasElement;\r\nexport let cropCtx: CanvasRenderingContext2D;\r\nexport let zoomLevel: HTMLDivElement;\r\nexport let cropInfo: HTMLDivElement;\r\n\r\nexport function initCanvasElements(elements: {\r\n  canvasContainer: HTMLDivElement;\r\n  mainCanvas: HTMLCanvasElement;\r\n  ctx: CanvasRenderingContext2D;\r\n  cropOverlay: HTMLCanvasElement;\r\n  cropCtx: CanvasRenderingContext2D;\r\n  zoomLevel: HTMLDivElement;\r\n  cropInfo: HTMLDivElement;\r\n}) {\r\n  canvasContainer = elements.canvasContainer;\r\n  mainCanvas = elements.mainCanvas;\r\n  ctx = elements.ctx;\r\n  cropOverlay = elements.cropOverlay;\r\n  cropCtx = elements.cropCtx;\r\n  zoomLevel = elements.zoomLevel;\r\n  cropInfo = elements.cropInfo;\r\n}\r\n\r\nexport function loadImage(image: RGBAImage, statusCallback: (msg: string) => void) {\r\n  state.currentImage = image;\r\n  \r\n  // Set up canvases\r\n  mainCanvas.width = image.width;\r\n  mainCanvas.height = image.height;\r\n  cropOverlay.width = image.width;\r\n  cropOverlay.height = image.height;\r\n  \r\n  // Make sure main canvas is visible (crop overlay shown after drawing)\r\n  mainCanvas.style.display = \"block\";\r\n  canvasContainer.style.opacity = \"1\";\r\n  \r\n  // Load saved crop settings or set default 10% margin\r\n  const savedCrop = getCropSettings(image.width, image.height);\r\n  if (savedCrop) {\r\n    state.cropRegion = savedCrop;\r\n  } else {\r\n    setDefaultCrop(image.width, image.height);\r\n  }\r\n  \r\n  // Draw the image first\r\n  const imageData = new ImageData(\r\n    new Uint8ClampedArray(image.data),\r\n    image.width,\r\n    image.height,\r\n  );\r\n  ctx.putImageData(imageData, 0, 0);\r\n  \r\n  // Then fit to screen and draw crop\r\n  fitToScreen();\r\n  cropOverlay.style.display = \"block\";\r\n  drawCropOverlay();\r\n  \r\n  statusCallback(`\u2713 Ready: ${image.width}\u00D7${image.height} pixels`);\r\n}\r\n\r\nexport function fitToScreen() {\r\n  if (!state.currentImage) return;\r\n  \r\n  const containerWidth = canvasContainer.clientWidth;\r\n  const containerHeight = canvasContainer.clientHeight;\r\n  const imageWidth = state.currentImage.width;\r\n  const imageHeight = state.currentImage.height;\r\n  \r\n  const scaleX = containerWidth / imageWidth;\r\n  const scaleY = containerHeight / imageHeight;\r\n  state.zoom = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding\r\n  \r\n  state.panX = (containerWidth - imageWidth * state.zoom) / 2;\r\n  state.panY = (containerHeight - imageHeight * state.zoom) / 2;\r\n  \r\n  updateZoom();\r\n  updateTransform();\r\n}\r\n\r\nexport function updateZoom() {\r\n  zoomLevel.textContent = `${Math.round(state.zoom * 100)}%`;\r\n}\r\n\r\n// Crop management functions\r\nexport function setDefaultCrop(imageWidth: number, imageHeight: number) {\r\n  const margin = 0.1; // 10% margin\r\n  state.cropRegion = {\r\n    x: imageWidth * margin,\r\n    y: imageHeight * margin,\r\n    width: imageWidth * (1 - 2 * margin),\r\n    height: imageHeight * (1 - 2 * margin),\r\n  };\r\n  updateCropInfo();\r\n}\r\n\r\nexport function getCropSettings(imageWidth: number, imageHeight: number) {\r\n  const key = `crop_${Math.round(imageWidth)}_${Math.round(imageHeight)}`;\r\n  const stored = localStorage.getItem(key);\r\n  if (stored) {\r\n    try {\r\n      return JSON.parse(stored) as { x: number; y: number; width: number; height: number };\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function saveCropSettings(imageWidth: number, imageHeight: number, crop: { x: number; y: number; width: number; height: number }) {\r\n  const key = `crop_${Math.round(imageWidth)}_${Math.round(imageHeight)}`;\r\n  localStorage.setItem(key, JSON.stringify(crop));\r\n}\r\n\r\nexport function updateCropInfo() {\r\n  if (state.cropRegion) {\r\n    cropInfo.textContent = `Crop: ${Math.round(state.cropRegion.width)}\u00D7${Math.round(state.cropRegion.height)} at (${Math.round(state.cropRegion.x)}, ${Math.round(state.cropRegion.y)})`;\r\n  }\r\n}\r\n\r\nexport function getCropHandleAtPoint(x: number, y: number): string | null {\r\n  if (!state.cropRegion) return null;\r\n  \r\n  const handleSize = 15 / state.zoom; // Handle hit area in canvas coordinates\r\n  const { x: cx, y: cy, width: cw, height: ch } = state.cropRegion;\r\n  \r\n  // Check corners first\r\n  if (Math.abs(x - cx) < handleSize && Math.abs(y - cy) < handleSize) return \"tl\";\r\n  if (Math.abs(x - (cx + cw)) < handleSize && Math.abs(y - cy) < handleSize) return \"tr\";\r\n  if (Math.abs(x - cx) < handleSize && Math.abs(y - (cy + ch)) < handleSize) return \"bl\";\r\n  if (Math.abs(x - (cx + cw)) < handleSize && Math.abs(y - (cy + ch)) < handleSize) return \"br\";\r\n  \r\n  // Check edges\r\n  if (Math.abs(x - (cx + cw / 2)) < handleSize && Math.abs(y - cy) < handleSize) return \"t\";\r\n  if (Math.abs(x - (cx + cw / 2)) < handleSize && Math.abs(y - (cy + ch)) < handleSize) return \"b\";\r\n  if (Math.abs(y - (cy + ch / 2)) < handleSize && Math.abs(x - cx) < handleSize) return \"l\";\r\n  if (Math.abs(y - (cy + ch / 2)) < handleSize && Math.abs(x - (cx + cw)) < handleSize) return \"r\";\r\n  \r\n  return null;\r\n}\r\n\r\nexport function updateCursorForHandle(handle: string | null) {\r\n  if (!handle) {\r\n    canvasContainer.style.cursor = \"default\";\r\n  } else if (handle === \"tl\" || handle === \"br\") {\r\n    canvasContainer.style.cursor = \"nwse-resize\";\r\n  } else if (handle === \"tr\" || handle === \"bl\") {\r\n    canvasContainer.style.cursor = \"nesw-resize\";\r\n  } else if (handle === \"t\" || handle === \"b\") {\r\n    canvasContainer.style.cursor = \"ns-resize\";\r\n  } else if (handle === \"l\" || handle === \"r\") {\r\n    canvasContainer.style.cursor = \"ew-resize\";\r\n  }\r\n}\r\n\r\nexport function adjustCropRegion(handle: string, dx: number, dy: number) {\r\n  if (!state.cropRegion || !state.currentImage) return;\r\n  \r\n  const { x, y, width, height } = state.cropRegion;\r\n  let newX = x, newY = y, newWidth = width, newHeight = height;\r\n  \r\n  switch (handle) {\r\n    case \"tl\":\r\n      newX = x + dx;\r\n      newY = y + dy;\r\n      newWidth = width - dx;\r\n      newHeight = height - dy;\r\n      break;\r\n    case \"tr\":\r\n      newY = y + dy;\r\n      newWidth = width + dx;\r\n      newHeight = height - dy;\r\n      break;\r\n    case \"bl\":\r\n      newX = x + dx;\r\n      newWidth = width - dx;\r\n      newHeight = height + dy;\r\n      break;\r\n    case \"br\":\r\n      newWidth = width + dx;\r\n      newHeight = height + dy;\r\n      break;\r\n    case \"t\":\r\n      newY = y + dy;\r\n      newHeight = height - dy;\r\n      break;\r\n    case \"b\":\r\n      newHeight = height + dy;\r\n      break;\r\n    case \"l\":\r\n      newX = x + dx;\r\n      newWidth = width - dx;\r\n      break;\r\n    case \"r\":\r\n      newWidth = width + dx;\r\n      break;\r\n  }\r\n  \r\n  // Constrain to image bounds\r\n  newX = Math.max(0, Math.min(newX, state.currentImage.width - 10));\r\n  newY = Math.max(0, Math.min(newY, state.currentImage.height - 10));\r\n  newWidth = Math.max(10, Math.min(newWidth, state.currentImage.width - newX));\r\n  newHeight = Math.max(10, Math.min(newHeight, state.currentImage.height - newY));\r\n  \r\n  state.cropRegion.x = newX;\r\n  state.cropRegion.y = newY;\r\n  state.cropRegion.width = newWidth;\r\n  state.cropRegion.height = newHeight;\r\n  \r\n  updateCropInfo();\r\n}\r\n\r\n// Fast update - only changes transform (for panning/zooming)\r\nexport function updateTransform() {\r\n  const transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;\r\n  mainCanvas.style.transform = transform;\r\n  mainCanvas.style.transformOrigin = \"0 0\";\r\n  mainCanvas.style.willChange = \"transform\";\r\n  \r\n  cropOverlay.style.transform = transform;\r\n  cropOverlay.style.transformOrigin = \"0 0\";\r\n  cropOverlay.style.willChange = \"transform\";\r\n  \r\n  // Use crisp pixels when zoomed in (>= 1x), filtered when zoomed out (< 1x)\r\n  if (state.zoom >= 1) {\r\n    mainCanvas.style.imageRendering = \"pixelated\";\r\n  } else {\r\n    mainCanvas.style.imageRendering = \"smooth\";\r\n  }\r\n  \r\n  // Redraw crop overlay whenever transform changes\r\n  drawCropOverlay();\r\n}\r\n\r\n// Full redraw - updates canvas content\r\nexport function redrawCanvas() {\r\n  if (!state.currentImage) return;\r\n  \r\n  // Clear and redraw base image\r\n  ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);\r\n  const imageData = new ImageData(\r\n    new Uint8ClampedArray(state.currentImage.data),\r\n    state.currentImage.width,\r\n    state.currentImage.height,\r\n  );\r\n  ctx.putImageData(imageData, 0, 0);\r\n  \r\n  drawCropOverlay();\r\n}\r\n\r\n// Draw crop overlay with darkened mask and handles\r\nexport function drawCropOverlay() {\r\n  if (!state.currentImage || !state.cropRegion) {\r\n    cropCtx.clearRect(0, 0, cropOverlay.width, cropOverlay.height);\r\n    return;\r\n  }\r\n  \r\n  cropCtx.clearRect(0, 0, cropOverlay.width, cropOverlay.height);\r\n  \r\n  // Draw darkened mask over entire image\r\n  cropCtx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\r\n  cropCtx.fillRect(0, 0, state.currentImage.width, state.currentImage.height);\r\n  \r\n  // Clear the crop region (composite mode)\r\n  cropCtx.globalCompositeOperation = \"destination-out\";\r\n  cropCtx.fillStyle = \"rgba(0, 0, 0, 1)\";\r\n  cropCtx.fillRect(\r\n    state.cropRegion.x,\r\n    state.cropRegion.y,\r\n    state.cropRegion.width,\r\n    state.cropRegion.height,\r\n  );\r\n  cropCtx.globalCompositeOperation = \"source-over\";\r\n  \r\n  // Draw crop rectangle border\r\n  cropCtx.strokeStyle = \"#4f46e5\";\r\n  cropCtx.lineWidth = 3 / state.zoom;\r\n  cropCtx.strokeRect(\r\n    state.cropRegion.x,\r\n    state.cropRegion.y,\r\n    state.cropRegion.width,\r\n    state.cropRegion.height,\r\n  );\r\n  \r\n  // Draw handles - 4 corners + 4 edges\r\n  const handleSize = 10 / state.zoom;\r\n  cropCtx.fillStyle = \"#4f46e5\";\r\n  \r\n  const cx = state.cropRegion.x;\r\n  const cy = state.cropRegion.y;\r\n  const cw = state.cropRegion.width;\r\n  const ch = state.cropRegion.height;\r\n  \r\n  const handles = [\r\n    // Corners\r\n    [cx, cy],                     // top-left\r\n    [cx + cw, cy],                // top-right\r\n    [cx, cy + ch],                // bottom-left\r\n    [cx + cw, cy + ch],           // bottom-right\r\n    // Edges\r\n    [cx + cw / 2, cy],            // top\r\n    [cx + cw, cy + ch / 2],       // right\r\n    [cx + cw / 2, cy + ch],       // bottom\r\n    [cx, cy + ch / 2],            // left\r\n  ];\r\n  \r\n  for (const [x, y] of handles) {\r\n    cropCtx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);\r\n  }\r\n}\r\n\r\nexport function cropImage(\r\n  image: RGBAImage,\r\n  crop: { x: number; y: number; width: number; height: number },\r\n): RGBAImage {\r\n  // Round crop coordinates to integers and ensure they're within bounds\r\n  const x = Math.max(0, Math.min(Math.round(crop.x), image.width - 1));\r\n  const y = Math.max(0, Math.min(Math.round(crop.y), image.height - 1));\r\n  const width = Math.max(1, Math.min(Math.round(crop.width), image.width - x));\r\n  const height = Math.max(1, Math.min(Math.round(crop.height), image.height - y));\r\n  \r\n  const croppedData = new Uint8ClampedArray(width * height * 4);\r\n  \r\n  for (let row = 0; row < height; row++) {\r\n    const srcOffset = ((y + row) * image.width + x) * 4;\r\n    const dstOffset = row * width * 4;\r\n    const copyLength = width * 4;\r\n    \r\n    // Ensure we don't read beyond the source image bounds\r\n    if (srcOffset + copyLength <= image.data.length) {\r\n      croppedData.set(\r\n        image.data.subarray(srcOffset, srcOffset + copyLength),\r\n        dstOffset,\r\n      );\r\n    }\r\n  }\r\n  \r\n  return { width, height, data: croppedData };\r\n}\r\n", "/**\r\n * Palette management and color editor\r\n */\r\n\r\nimport { DEFAULT_PALETTE } from \"../src/formats/palettized.ts\";\r\nimport { u32ToHex, hexToRGBA } from \"./utils.ts\";\r\nimport { state } from \"./state.ts\";\r\nimport { updateFile } from \"./storage.ts\";\r\n\r\n// Local state for color editor\r\nlet colorEditorIndex: number | null = null;\r\nlet eyedropperMode: 'input' | 'output' | null = null;\r\nlet eyedropperActive = false;\r\n\r\n// Callbacks that must be provided by main.ts\r\nlet showStatusCallback: (msg: string, isError?: boolean) => void = () => {};\r\nlet mainCanvasRef: HTMLCanvasElement | null = null;\r\n\r\n// Auto-save palette to the current file's storage\r\nasync function autosavePaletteToFile() {\r\n  if (state.currentFileId) {\r\n    try {\r\n      const palette = JSON.stringify(state.userPalette);\r\n      await updateFile(state.currentFileId, { palette });\r\n      console.log(\"Auto-saved palette to file storage\");\r\n    } catch (err) {\r\n      console.error(\"Failed to auto-save palette:\", err);\r\n    }\r\n  }\r\n}\r\n\r\nexport function initPaletteModule(callbacks: {\r\n  showStatus: (msg: string, isError?: boolean) => void;\r\n  mainCanvas: HTMLCanvasElement;\r\n}) {\r\n  showStatusCallback = callbacks.showStatus;\r\n  mainCanvasRef = callbacks.mainCanvas;\r\n}\r\n\r\n// IndexedDB for palette storage\r\nexport function initPaletteDB(): Promise<IDBDatabase> {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(\"PalettesDB\", 1);\r\n    request.onerror = () => reject(request.error);\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onupgradeneeded = (event) => {\r\n      const db = (event.target as IDBOpenDBRequest).result;\r\n      if (!db.objectStoreNames.contains(\"palettes\")) {\r\n        db.createObjectStore(\"palettes\", { keyPath: \"name\" });\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nexport async function savePalette(name: string) {\r\n  if (!name || name.trim() === \"\") {\r\n    showStatusCallback(\"Please enter a palette name\", true);\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    const db = await initPaletteDB();\r\n    const transaction = db.transaction([\"palettes\"], \"readwrite\");\r\n    const store = transaction.objectStore(\"palettes\");\r\n    \r\n    await store.put({\r\n      name: name.trim(),\r\n      palette: JSON.parse(JSON.stringify(state.userPalette)),\r\n      timestamp: Date.now(),\r\n    });\r\n    \r\n    showStatusCallback(`\u2713 Palette \"${name.trim()}\" saved`);\r\n  } catch (error) {\r\n    showStatusCallback(`Error saving palette: ${error}`, true);\r\n  }\r\n}\r\n\r\nexport async function loadPalette(name?: string) {\r\n  try {\r\n    const db = await initPaletteDB();\r\n    const transaction = db.transaction([\"palettes\"], \"readonly\");\r\n    const store = transaction.objectStore(\"palettes\");\r\n    \r\n    if (name) {\r\n      const request = store.get(name);\r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = () => {\r\n          if (request.result) {\r\n            state.userPalette.length = 0;\r\n            state.userPalette.push(...request.result.palette);\r\n            state.currentPaletteName = name;\r\n            renderPaletteUI();\r\n            showStatusCallback(`\u2713 Loaded palette \"${name}\"`);\r\n            resolve(request.result);\r\n          } else {\r\n            showStatusCallback(`Palette \"${name}\" not found`, true);\r\n            reject(new Error(\"Not found\"));\r\n          }\r\n        };\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } else {\r\n      // List all palettes for selection\r\n      const allRequest = store.getAll();\r\n      return new Promise((resolve, reject) => {\r\n        allRequest.onsuccess = () => {\r\n          const palettes = allRequest.result;\r\n          if (palettes.length === 0) {\r\n            showStatusCallback(\"No saved palettes\", true);\r\n            resolve([]);\r\n            return;\r\n          }\r\n          \r\n          // Create selection dialog\r\n          const names = palettes.map((p: { name: string }) => p.name).join(\"\\n\");\r\n          const selected = prompt(`Available palettes:\\n${names}\\n\\nEnter name to load:`);\r\n          \r\n          if (selected && palettes.some((p: { name: string }) => p.name === selected)) {\r\n            loadPalette(selected);\r\n          }\r\n          resolve(palettes);\r\n        };\r\n        allRequest.onerror = () => reject(allRequest.error);\r\n      });\r\n    }\r\n  } catch (error) {\r\n    showStatusCallback(`Error loading palette: ${error}`, true);\r\n  }\r\n}\r\n\r\nexport async function setDefaultPalette() {\r\n  const name = state.currentPaletteName || prompt(\"Enter name for this palette:\");\r\n  if (!name) return;\r\n  \r\n  localStorage.setItem(\"defaultPalette\", name);\r\n  await savePalette(name);\r\n  showStatusCallback(`\u2713 Set \"${name}\" as default palette`);\r\n}\r\n\r\nexport async function loadDefaultPalette() {\r\n  const defaultName = localStorage.getItem(\"defaultPalette\");\r\n  if (defaultName) {\r\n    try {\r\n      await loadPalette(defaultName);\r\n      showStatusCallback(`\u2713 Loaded default palette \"${defaultName}\"`);\r\n    } catch {\r\n      showStatusCallback(\"Default palette not found\", true);\r\n    }\r\n  }\r\n}\r\n\r\nexport function renderPaletteUI() {\r\n  const paletteDisplay = document.getElementById(\"paletteDisplay\") as HTMLDivElement;\r\n  if (!paletteDisplay) {\r\n    console.error(\"paletteDisplay not found in DOM!\");\r\n    return;\r\n  }\r\n  paletteDisplay.innerHTML = \"\";\r\n  \r\n  state.userPalette.forEach((color, index) => {\r\n    const item = document.createElement(\"div\");\r\n    item.style.cssText = \"display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem; border-bottom: 1px solid #3a3a3a; cursor: pointer; transition: background 0.2s;\";\r\n    item.onmouseover = () => item.style.background = \"#333\";\r\n    item.onmouseout = () => item.style.background = \"transparent\";\r\n    item.onclick = () => openColorEditor(index);\r\n    \r\n    // Input color swatch\r\n    const inputSwatch = document.createElement(\"div\");\r\n    inputSwatch.style.cssText = `width: 24px; height: 24px; border-radius: 4px; border: 2px solid ${index === 0 ? \"#4f46e5\" : \"#3a3a3a\"}; background: ${color.inputColor}; flex-shrink: 0;`;\r\n    item.appendChild(inputSwatch);\r\n    \r\n    // Status indicator and output\r\n    if (color.mapToBg) {\r\n      const statusIcon = document.createElement(\"span\");\r\n      statusIcon.textContent = \"\u2715\";\r\n      statusIcon.style.cssText = \"font-size: 0.9rem; color: #ef4444; flex-shrink: 0; width: 16px; text-align: center;\";\r\n      statusIcon.title = \"Remove\";\r\n      item.appendChild(statusIcon);\r\n    } else if (color.inputColor.toLowerCase() !== color.outputColor.toLowerCase()) {\r\n      const arrow = document.createElement(\"span\");\r\n      arrow.textContent = \"\u2192\";\r\n      arrow.style.cssText = \"font-size: 0.9rem; color: #999; flex-shrink: 0;\";\r\n      item.appendChild(arrow);\r\n      \r\n      const outputSwatch = document.createElement(\"div\");\r\n      outputSwatch.style.cssText = `width: 24px; height: 24px; border-radius: 4px; border: 2px solid ${index === 0 ? \"#4f46e5\" : \"#3a3a3a\"}; background: ${color.outputColor}; flex-shrink: 0;`;\r\n      item.appendChild(outputSwatch);\r\n    }\r\n    \r\n    // Hex value\r\n    const hexLabel = document.createElement(\"div\");\r\n    hexLabel.style.cssText = \"font-family: 'Courier New', monospace; font-size: 0.8rem; color: #aaa; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis;\";\r\n    hexLabel.textContent = color.inputColor.toUpperCase();\r\n    hexLabel.title = color.inputColor.toUpperCase();\r\n    item.appendChild(hexLabel);\r\n    \r\n    // Index indicator\r\n    if (index === 0) {\r\n      const bgLabel = document.createElement(\"span\");\r\n      bgLabel.textContent = \"BG\";\r\n      bgLabel.style.cssText = \"font-size: 0.7rem; color: #4f46e5; font-weight: 600; flex-shrink: 0; padding: 0.1rem 0.3rem; background: rgba(79, 70, 229, 0.2); border-radius: 3px;\";\r\n      item.appendChild(bgLabel);\r\n    }\r\n    \r\n    paletteDisplay.appendChild(item);\r\n  });\r\n}\r\n\r\nfunction openColorEditor(index: number) {\r\n  colorEditorIndex = index;\r\n  const color = state.userPalette[index];\r\n  \r\n  // Create or get color editor modal\r\n  let modal = document.getElementById(\"colorEditorModal\");\r\n  if (!modal) {\r\n    modal = document.createElement(\"div\");\r\n    modal.id = \"colorEditorModal\";\r\n    modal.style.cssText = `\r\n      position: fixed; top: 0; left: 0; right: 0; bottom: 0;\r\n      background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px);\r\n      z-index: 3000; display: flex; align-items: center; justify-content: center;\r\n    `;\r\n    document.body.appendChild(modal);\r\n  }\r\n  \r\n  modal.innerHTML = `\r\n    <div style=\"background: #1a1a1a; border: 2px solid #4f46e5; border-radius: 8px; padding: 1.5rem; min-width: 400px; max-width: 500px;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;\">\r\n        <h3 style=\"margin: 0; color: #fff;\">Edit Color ${index}${index === 0 ? ' (Background)' : ''}</h3>\r\n        <button id=\"closeColorEditor\" style=\"background: none; border: none; color: #999; font-size: 1.5rem; cursor: pointer; padding: 0; width: 32px; height: 32px;\">\u00D7</button>\r\n      </div>\r\n      \r\n      <div style=\"display: flex; flex-direction: column; gap: 1.25rem;\">\r\n        <!-- Input Color -->\r\n        <div style=\"display: flex; flex-direction: column; gap: 0.5rem;\">\r\n          <label style=\"color: #aaa; font-size: 0.9rem; font-weight: 500;\">Input Color (from document)</label>\r\n          <div style=\"display: flex; gap: 0.5rem; align-items: center;\">\r\n            <div style=\"width: 48px; height: 48px; border-radius: 6px; border: 2px solid #3a3a3a; background: ${color.inputColor}; flex-shrink: 0;\"></div>\r\n            <input type=\"text\" id=\"inputColorHex\" value=\"${color.inputColor}\" maxlength=\"7\" \r\n              style=\"flex: 1; padding: 0.75rem; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #fff; font-family: 'Courier New', monospace; font-size: 1rem;\">\r\n            <button id=\"eyedropperInput\" style=\"padding: 0.75rem; background: #4f46e5; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 1.2rem;\" title=\"Pick from canvas\">\uD83D\uDCA7</button>\r\n          </div>\r\n        </div>\r\n        \r\n        <!-- Output Options -->\r\n        <div style=\"display: flex; flex-direction: column; gap: 0.5rem;\">\r\n          <label style=\"color: #aaa; font-size: 0.9rem; font-weight: 500;\">Output (in vectorized result)</label>\r\n          \r\n          <div style=\"display: flex; gap: 0.75rem; margin-bottom: 0.5rem;\">\r\n            <label style=\"display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #fff;\">\r\n              <input type=\"radio\" name=\"outputMode\" value=\"same\" ${!color.mapToBg && color.inputColor === color.outputColor ? 'checked' : ''} style=\"cursor: pointer;\">\r\n              <span>Keep same color</span>\r\n            </label>\r\n            <label style=\"display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #fff;\">\r\n              <input type=\"radio\" name=\"outputMode\" value=\"different\" ${!color.mapToBg && color.inputColor !== color.outputColor ? 'checked' : ''} style=\"cursor: pointer;\">\r\n              <span>Transform to:</span>\r\n            </label>\r\n            <label style=\"display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #fff;\">\r\n              <input type=\"radio\" name=\"outputMode\" value=\"remove\" ${color.mapToBg ? 'checked' : ''} style=\"cursor: pointer;\">\r\n              <span style=\"color: #ef4444;\">Remove</span>\r\n            </label>\r\n          </div>\r\n          \r\n          <div id=\"outputColorSection\" style=\"display: flex; gap: 0.5rem; align-items: center; ${color.mapToBg || color.inputColor === color.outputColor ? 'opacity: 0.4; pointer-events: none;' : ''}\">\r\n            <div style=\"width: 48px; height: 48px; border-radius: 6px; border: 2px solid #3a3a3a; background: ${color.outputColor}; flex-shrink: 0;\"></div>\r\n            <input type=\"text\" id=\"outputColorHex\" value=\"${color.outputColor}\" maxlength=\"7\" \r\n              style=\"flex: 1; padding: 0.75rem; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #fff; font-family: 'Courier New', monospace; font-size: 1rem;\">\r\n            <button id=\"eyedropperOutput\" style=\"padding: 0.75rem; background: #4f46e5; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 1.2rem;\" title=\"Pick from canvas\">\uD83D\uDCA7</button>\r\n          </div>\r\n        </div>\r\n        \r\n        <!-- Action Buttons -->\r\n        <div style=\"display: flex; gap: 0.75rem; margin-top: 0.5rem;\">\r\n          <button id=\"saveColorEdit\" style=\"flex: 1; padding: 0.75rem; background: #4f46e5; border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600;\">Save</button>\r\n          ${index !== 0 ? '<button id=\"deleteColor\" style=\"padding: 0.75rem 1.25rem; background: #ef4444; border: none; border-radius: 4px; color: white; cursor: pointer;\">Delete</button>' : ''}\r\n          <button id=\"cancelColorEdit\" style=\"padding: 0.75rem 1.25rem; background: #3a3a3a; border: none; border-radius: 4px; color: white; cursor: pointer;\">Cancel</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `;\r\n  \r\n  modal.style.display = \"flex\";\r\n  \r\n  // Setup event listeners\r\n  const inputHexField = document.getElementById(\"inputColorHex\") as HTMLInputElement;\r\n  const outputHexField = document.getElementById(\"outputColorHex\") as HTMLInputElement;\r\n  const outputSection = document.getElementById(\"outputColorSection\") as HTMLDivElement;\r\n  const outputModeRadios = document.getElementsByName(\"outputMode\") as NodeListOf<HTMLInputElement>;\r\n  \r\n  // Update output section visibility based on mode\r\n  outputModeRadios.forEach(radio => {\r\n    radio.addEventListener(\"change\", () => {\r\n      if (radio.value === \"different\") {\r\n        outputSection.style.opacity = \"1\";\r\n        outputSection.style.pointerEvents = \"auto\";\r\n      } else {\r\n        outputSection.style.opacity = \"0.4\";\r\n        outputSection.style.pointerEvents = \"none\";\r\n      }\r\n    });\r\n  });\r\n  \r\n  // Eyedropper buttons\r\n  document.getElementById(\"eyedropperInput\")!.addEventListener(\"click\", () => {\r\n    eyedropperMode = 'input';\r\n    activateEyedropper();\r\n    modal!.style.display = \"none\";\r\n  });\r\n  \r\n  document.getElementById(\"eyedropperOutput\")!.addEventListener(\"click\", () => {\r\n    eyedropperMode = 'output';\r\n    activateEyedropper();\r\n    modal!.style.display = \"none\";\r\n  });\r\n  \r\n  // Save button\r\n  document.getElementById(\"saveColorEdit\")!.addEventListener(\"click\", () => {\r\n    const inputColor = inputHexField.value;\r\n    const outputColor = outputHexField.value;\r\n    const selectedMode = Array.from(outputModeRadios).find(r => r.checked)?.value;\r\n    \r\n    if (!/^#[0-9A-Fa-f]{6}$/.test(inputColor)) {\r\n      alert(\"Invalid input color format. Use #RRGGBB\");\r\n      return;\r\n    }\r\n    \r\n    if (selectedMode === 'different' && !/^#[0-9A-Fa-f]{6}$/.test(outputColor)) {\r\n      alert(\"Invalid output color format. Use #RRGGBB\");\r\n      return;\r\n    }\r\n    \r\n    state.userPalette[index].inputColor = inputColor;\r\n    \r\n    if (selectedMode === 'remove') {\r\n      state.userPalette[index].mapToBg = true;\r\n      state.userPalette[index].outputColor = inputColor; // Keep it same for display\r\n    } else if (selectedMode === 'different') {\r\n      state.userPalette[index].mapToBg = false;\r\n      state.userPalette[index].outputColor = outputColor;\r\n    } else { // same\r\n      state.userPalette[index].mapToBg = false;\r\n      state.userPalette[index].outputColor = inputColor;\r\n    }\r\n    \r\n    renderPaletteUI();\r\n    autosavePaletteToFile();\r\n    closeColorEditor();\r\n  });\r\n  \r\n  // Delete button\r\n  const deleteBtn = document.getElementById(\"deleteColor\");\r\n  if (deleteBtn) {\r\n    deleteBtn.addEventListener(\"click\", () => {\r\n      if (index !== 0 && confirm(\"Delete this color?\")) {\r\n        state.userPalette.splice(index, 1);\r\n        renderPaletteUI();\r\n        autosavePaletteToFile();\r\n        closeColorEditor();\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Cancel/Close buttons\r\n  document.getElementById(\"cancelColorEdit\")!.addEventListener(\"click\", closeColorEditor);\r\n  document.getElementById(\"closeColorEditor\")!.addEventListener(\"click\", closeColorEditor);\r\n  \r\n  // Click outside to close\r\n  modal.addEventListener(\"click\", (e) => {\r\n    if (e.target === modal) closeColorEditor();\r\n  });\r\n}\r\n\r\nfunction closeColorEditor() {\r\n  const modal = document.getElementById(\"colorEditorModal\");\r\n  if (modal) modal.style.display = \"none\";\r\n  colorEditorIndex = null;\r\n  eyedropperMode = null;\r\n}\r\n\r\nexport function addPaletteColor() {\r\n  if (state.userPalette.length >= 16) {\r\n    showStatusCallback(\"Maximum 16 colors allowed\", true);\r\n    return;\r\n  }\r\n  \r\n  const newIndex = state.userPalette.length;\r\n  state.userPalette.push({\r\n    inputColor: \"#808080\",\r\n    outputColor: \"#808080\",\r\n    mapToBg: false,\r\n  });\r\n  \r\n  renderPaletteUI();\r\n  autosavePaletteToFile();\r\n  \r\n  // Immediately open editor for the new color\r\n  openColorEditor(newIndex);\r\n}\r\n\r\nexport function resetPaletteToDefault() {\r\n  state.userPalette.length = 0;\r\n  Array.from(DEFAULT_PALETTE).forEach(color => {\r\n    state.userPalette.push({\r\n      inputColor: u32ToHex(color),\r\n      outputColor: u32ToHex(color),\r\n      mapToBg: false,\r\n    });\r\n  });\r\n  renderPaletteUI();\r\n  autosavePaletteToFile();\r\n  showStatusCallback(\"Palette reset to default\");\r\n}\r\n\r\nfunction activateEyedropper() {\r\n  if (!state.currentImage) {\r\n    showStatusCallback(\"No image loaded\", true);\r\n    return;\r\n  }\r\n  \r\n  if (!mainCanvasRef) {\r\n    showStatusCallback(\"Canvas not initialized\", true);\r\n    return;\r\n  }\r\n  \r\n  eyedropperActive = true;\r\n  document.body.classList.add(\"eyedropper-active\");\r\n  mainCanvasRef.style.cursor = \"crosshair\";\r\n  showStatusCallback(\"\uD83D\uDCA7 Click on the image to pick a color (ESC to cancel)\");\r\n}\r\n\r\nfunction deactivateEyedropper() {\r\n  if (!mainCanvasRef) return;\r\n  \r\n  eyedropperActive = false;\r\n  document.body.classList.remove(\"eyedropper-active\");\r\n  mainCanvasRef.style.cursor = \"\";\r\n  showStatusCallback(\"Eyedropper cancelled\");\r\n}\r\n\r\nexport function pickColorFromCanvas(x: number, y: number) {\r\n  if (!state.currentImage || !mainCanvasRef) return;\r\n  \r\n  // Convert canvas coordinates to image coordinates\r\n  const rect = mainCanvasRef.getBoundingClientRect();\r\n  const scaleX = state.currentImage.width / rect.width;\r\n  const scaleY = state.currentImage.height / rect.height;\r\n  const imgX = Math.floor((x - rect.left) * scaleX);\r\n  const imgY = Math.floor((y - rect.top) * scaleY);\r\n  \r\n  // Check bounds\r\n  if (imgX < 0 || imgX >= state.currentImage.width || imgY < 0 || imgY >= state.currentImage.height) {\r\n    return;\r\n  }\r\n  \r\n  // Get pixel color\r\n  const pixelIndex = (imgY * state.currentImage.width + imgX) * 4;\r\n  const r = state.currentImage.data[pixelIndex];\r\n  const g = state.currentImage.data[pixelIndex + 1];\r\n  const b = state.currentImage.data[pixelIndex + 2];\r\n  \r\n  const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\r\n  \r\n  deactivateEyedropper();\r\n  \r\n  // If we're in color editor mode, update the color editor\r\n  if (colorEditorIndex !== null && eyedropperMode) {\r\n    if (eyedropperMode === 'input') {\r\n      state.userPalette[colorEditorIndex].inputColor = hex;\r\n    } else if (eyedropperMode === 'output') {\r\n      state.userPalette[colorEditorIndex].outputColor = hex;\r\n      state.userPalette[colorEditorIndex].mapToBg = false; // Ensure it's not set to remove\r\n    }\r\n    autosavePaletteToFile();\r\n    // Reopen the color editor with updated values\r\n    openColorEditor(colorEditorIndex);\r\n    showStatusCallback(`Picked ${hex.toUpperCase()}`);\r\n  } else {\r\n    // Old behavior: add to palette\r\n    addColorToPalette(hex);\r\n    showStatusCallback(`Added ${hex.toUpperCase()} to palette`);\r\n  }\r\n}\r\n\r\nfunction addColorToPalette(hex: string) {\r\n  if (state.userPalette.length >= 16) {\r\n    showStatusCallback(\"Maximum 16 colors - remove one first\", true);\r\n    return;\r\n  }\r\n  \r\n  state.userPalette.push({\r\n    inputColor: hex,\r\n    outputColor: hex,\r\n    mapToBg: false,\r\n  });\r\n  \r\n  renderPaletteUI();\r\n  showStatusCallback(`Added ${hex} to palette`);\r\n}\r\n\r\n// Convert state.userPalette to RGBA format for GPU processing\r\nexport function buildPaletteRGBA(): Uint8ClampedArray {\r\n  const palette = new Uint8ClampedArray(16 * 4);\r\n  \r\n  for (let i = 0; i < state.userPalette.length && i < 16; i++) {\r\n    const color = state.userPalette[i];\r\n    // Use INPUT color for matching - GPU will find nearest input color\r\n    // The palette stored with the result contains OUTPUT colors for display\r\n    const [r, g, b, a] = hexToRGBA(color.inputColor);\r\n    \r\n    palette[i * 4] = r;\r\n    palette[i * 4 + 1] = g;\r\n    palette[i * 4 + 2] = b;\r\n    palette[i * 4 + 3] = a;\r\n  }\r\n  \r\n  // Fill remaining slots with background color\r\n  for (let i = state.userPalette.length; i < 16; i++) {\r\n    const [r, g, b, a] = hexToRGBA(state.userPalette[0].inputColor);\r\n    palette[i * 4] = r;\r\n    palette[i * 4 + 1] = g;\r\n    palette[i * 4 + 2] = b;\r\n    palette[i * 4 + 3] = a;\r\n  }\r\n  \r\n  return palette;\r\n}\r\n\r\n// Check if eyedropper is active (for event handling in main.ts)\r\nexport function isEyedropperActive(): boolean {\r\n  return eyedropperActive;\r\n}\r\n\r\n// Force deactivate (e.g., on ESC key)\r\nexport function forceDeactivateEyedropper() {\r\n  if (eyedropperActive) {\r\n    deactivateEyedropper();\r\n  }\r\n}\r\n", "/**\r\n * Incremental segmentation algorithm for vectorization\r\n * Converts ordered polyline points to line and arc segments\r\n * Based on greedy segment growing with incremental line and circle fitting\r\n */\r\n\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface Segment {\r\n  startIndex: number;\r\n  endIndex: number;\r\n  type: \"line\" | \"arc\" | \"polyline\";\r\n  // Projected endpoints for fitted segments (on the fitted curve)\r\n  // For unfitted polylines, these are undefined and raw skeleton pixels are used\r\n  projectedStart?: Point;\r\n  projectedEnd?: Point;\r\n  // For lines: store fitted direction and centroid\r\n  lineFit?: {\r\n    centroid: Point;\r\n    direction: Point;\r\n    error: number;\r\n  };\r\n  // For arcs: store fitted center and radius\r\n  circleFit?: {\r\n    center: Point;\r\n    radius: number;\r\n    error: number;\r\n    sweepAngle: number;\r\n    clockwise: boolean; // Direction of arc travel\r\n  };\r\n}\r\n\r\n// Tunable parameters\r\nconst MAX_ERROR = 0.75; // absolute distance tolerance (pixels) for median/majority\r\nconst MAX_ERROR_P90 = 1; // absolute distance tolerance (pixels) at 90th percentile\r\nconst MIN_POINTS = 5; // minimum points for a valid fit\r\nconst LOOKAHEAD_POINTS = 2; // hysteresis to prevent jitter\r\nconst ERROR_PERCENTILE = 0.9; // Use 90th percentile for outlier tolerance\r\nconst MIN_RADIUS = 2.0; // minimum valid circle radius\r\nconst MAX_RADIUS = 10000.0; // maximum valid circle radius (treat as line)\r\nconst ARC_PREFERENCE_FACTOR = 1.2; // prefer arcs when error is similar\r\nconst MIN_SWEEP_ANGLE = Math.PI / 6; // minimum sweep angle for arcs (30 degrees)\r\n\r\n/**\r\n * Calculate the nth percentile of an array of values\r\n */\r\nfunction percentile(values: number[], p: number): number {\r\n  if (values.length === 0) return 0;\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const index = Math.floor(sorted.length * p);\r\n  return sorted[Math.min(index, sorted.length - 1)];\r\n}\r\n\r\n/**\r\n * Incremental line fit state using Total Least Squares (TLS)\r\n */\r\nclass IncrementalLineFit {\r\n  private n = 0;\r\n  private sumX = 0;\r\n  private sumY = 0;\r\n  private sumXX = 0;\r\n  private sumYY = 0;\r\n  private sumXY = 0;\r\n\r\n  addPoint(p: Point): void {\r\n    this.n++;\r\n    this.sumX += p.x;\r\n    this.sumY += p.y;\r\n    this.sumXX += p.x * p.x;\r\n    this.sumYY += p.y * p.y;\r\n    this.sumXY += p.x * p.y;\r\n  }\r\n\r\n  getCount(): number {\r\n    return this.n;\r\n  }\r\n\r\n  /**\r\n   * Compute line fit and return perpendicular distance to a point\r\n   */\r\n  distanceToPoint(p: Point): number {\r\n    if (this.n < 2) return 0;\r\n\r\n    const { centroid, direction } = this.getFit();\r\n\r\n    // Vector from centroid to point\r\n    const dx = p.x - centroid.x;\r\n    const dy = p.y - centroid.y;\r\n\r\n    // Perpendicular distance: |v \u00D7 n| where n is perpendicular to direction\r\n    const perpX = -direction.y;\r\n    const perpY = direction.x;\r\n\r\n    return Math.abs(dx * perpX + dy * perpY);\r\n  }\r\n\r\n  getFit(): { centroid: Point; direction: Point } {\r\n    if (this.n < 2) {\r\n      return {\r\n        centroid: { x: 0, y: 0 },\r\n        direction: { x: 1, y: 0 },\r\n      };\r\n    }\r\n\r\n    // Compute mean (centroid)\r\n    const meanX = this.sumX / this.n;\r\n    const meanY = this.sumY / this.n;\r\n\r\n    // Compute covariance matrix\r\n    const covXX = this.sumXX / this.n - meanX * meanX;\r\n    const covYY = this.sumYY / this.n - meanY * meanY;\r\n    const covXY = this.sumXY / this.n - meanX * meanY;\r\n\r\n    // Find dominant eigenvector (PCA direction)\r\n    const trace = covXX + covYY;\r\n    const det = covXX * covYY - covXY * covXY;\r\n    const lambda1 = (trace + Math.sqrt(trace * trace - 4 * det)) / 2;\r\n\r\n    let dirX, dirY;\r\n    if (Math.abs(covXY) > 1e-10) {\r\n      dirX = lambda1 - covYY;\r\n      dirY = covXY;\r\n    } else if (covXX > covYY) {\r\n      dirX = 1;\r\n      dirY = 0;\r\n    } else {\r\n      dirX = 0;\r\n      dirY = 1;\r\n    }\r\n\r\n    const length = Math.sqrt(dirX * dirX + dirY * dirY);\r\n    if (length > 1e-10) {\r\n      dirX /= length;\r\n      dirY /= length;\r\n    }\r\n\r\n    return {\r\n      centroid: { x: meanX, y: meanY },\r\n      direction: { x: dirX, y: dirY },\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Incremental circle fit using algebraic least squares\r\n * Based on Pratt/Taubin method\r\n */\r\nclass IncrementalCircleFit {\r\n  private n = 0;\r\n  private sumX = 0;\r\n  private sumY = 0;\r\n  private sumXX = 0;\r\n  private sumYY = 0;\r\n  private sumXY = 0;\r\n  private sumR2 = 0; // \u03A3(x\u00B2+y\u00B2)\r\n  private sumXR2 = 0; // \u03A3x(x\u00B2+y\u00B2)\r\n  private sumYR2 = 0; // \u03A3y(x\u00B2+y\u00B2)\r\n\r\n  addPoint(p: Point): void {\r\n    this.n++;\r\n    const r2 = p.x * p.x + p.y * p.y;\r\n    this.sumX += p.x;\r\n    this.sumY += p.y;\r\n    this.sumXX += p.x * p.x;\r\n    this.sumYY += p.y * p.y;\r\n    this.sumXY += p.x * p.y;\r\n    this.sumR2 += r2;\r\n    this.sumXR2 += p.x * r2;\r\n    this.sumYR2 += p.y * r2;\r\n  }\r\n\r\n  getCount(): number {\r\n    return this.n;\r\n  }\r\n\r\n  /**\r\n   * Compute circle fit and return distance to point\r\n   */\r\n  distanceToPoint(p: Point): number {\r\n    if (this.n < 3) return 0;\r\n\r\n    const { center, radius, valid } = this.getFit();\r\n    if (!valid) return Infinity;\r\n\r\n    // Distance: ||p - center| - radius|\r\n    const dx = p.x - center.x;\r\n    const dy = p.y - center.y;\r\n    const distToCenter = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    return Math.abs(distToCenter - radius);\r\n  }\r\n\r\n  getFit(): { center: Point; radius: number; valid: boolean } {\r\n    if (this.n < 3) {\r\n      return { center: { x: 0, y: 0 }, radius: 0, valid: false };\r\n    }\r\n\r\n    // Solve the algebraic circle fit\r\n    // System: [A] * [cx, cy, c] = [b]\r\n    // where (x-cx)\u00B2 + (y-cy)\u00B2 = r\u00B2 becomes: x\u00B2+y\u00B2 = 2cx*x + 2cy*y + c\r\n\r\n    const n = this.n;\r\n\r\n    // Build matrix elements\r\n    const a11 = this.sumXX;\r\n    const a12 = this.sumXY;\r\n    const a13 = this.sumX;\r\n\r\n    const a21 = this.sumXY;\r\n    const a22 = this.sumYY;\r\n    const a23 = this.sumY;\r\n\r\n    const a31 = this.sumX;\r\n    const a32 = this.sumY;\r\n    const a33 = n;\r\n\r\n    const b1 = this.sumXR2;\r\n    const b2 = this.sumYR2;\r\n    const b3 = this.sumR2;\r\n\r\n    // Solve 3x3 system using Cramer's rule\r\n    const det = a11 * (a22 * a33 - a23 * a32) -\r\n      a12 * (a21 * a33 - a23 * a31) +\r\n      a13 * (a21 * a32 - a22 * a31);\r\n\r\n    if (Math.abs(det) < 1e-10) {\r\n      return { center: { x: 0, y: 0 }, radius: 0, valid: false };\r\n    }\r\n\r\n    const det1 = b1 * (a22 * a33 - a23 * a32) -\r\n      a12 * (b2 * a33 - a23 * b3) +\r\n      a13 * (b2 * a32 - a22 * b3);\r\n\r\n    const det2 = a11 * (b2 * a33 - a23 * b3) -\r\n      b1 * (a21 * a33 - a23 * a31) +\r\n      a13 * (a21 * b3 - b2 * a31);\r\n\r\n    const det3 = a11 * (a22 * b3 - b2 * a32) -\r\n      a12 * (a21 * b3 - b2 * a31) +\r\n      b1 * (a21 * a32 - a22 * a31);\r\n\r\n    const cx = det1 / det / 2;\r\n    const cy = det2 / det / 2;\r\n    const c = det3 / det;\r\n\r\n    const radius = Math.sqrt(cx * cx + cy * cy + c);\r\n\r\n    // Validate radius\r\n    const valid = radius >= MIN_RADIUS && radius <= MAX_RADIUS;\r\n\r\n    return {\r\n      center: { x: cx, y: cy },\r\n      radius,\r\n      valid,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Segment a path into line and arc segments using greedy incremental fitting\r\n */\r\nexport function segmentPath(points: Point[], isClosed: boolean): Segment[] {\r\n  const N = points.length;\r\n  if (N < 2) return [];\r\n\r\n  const segments: Segment[] = [];\r\n  let i = 0;\r\n\r\n  while (i < N) {\r\n    const segStart = i;\r\n    const lineFit = new IncrementalLineFit();\r\n    const circleFit = new IncrementalCircleFit();\r\n\r\n    const lineErrors: number[] = [];\r\n    const circleErrors: number[] = [];\r\n    let j = i;\r\n\r\n    // Grow segment as long as one of the fits is valid\r\n    while (j < N) {\r\n      lineFit.addPoint(points[j]);\r\n      circleFit.addPoint(points[j]);\r\n\r\n      if (lineFit.getCount() < MIN_POINTS) {\r\n        j++;\r\n        continue;\r\n      }\r\n\r\n      // Recalculate errors for ALL points in the segment with the updated fit\r\n      lineErrors.length = 0;\r\n      circleErrors.length = 0;\r\n      for (let k = segStart; k <= j; k++) {\r\n        lineErrors.push(lineFit.distanceToPoint(points[k]));\r\n        circleErrors.push(circleFit.distanceToPoint(points[k]));\r\n      }\r\n\r\n      // Calculate median (50th) and 90th percentile errors\r\n      const medianLineError = percentile(lineErrors, 0.5);\r\n      const medianCircleError = percentile(circleErrors, 0.5);\r\n      const percentileLineError = percentile(lineErrors, ERROR_PERCENTILE);\r\n      const percentileCircleError = percentile(circleErrors, ERROR_PERCENTILE);\r\n\r\n      // Continue if at least one fit is within tolerance\r\n      // Require both median <= MAX_ERROR and 90th percentile <= MAX_ERROR_P90\r\n      const lineOk = medianLineError <= MAX_ERROR &&\r\n        percentileLineError <= MAX_ERROR_P90;\r\n      const circleOk = medianCircleError <= MAX_ERROR &&\r\n        percentileCircleError <= MAX_ERROR_P90;\r\n\r\n      // Debug logging for segment growing\r\n      if (j - segStart > 10 && j % 5 === 0) {\r\n        console.log(`[Segment ${segStart}-${j}] Points: ${j - segStart + 1}`);\r\n        console.log(\r\n          `  Line: median=${medianLineError.toFixed(3)}px (${\r\n            lineOk ? \"\u2713\" : \"\u2717\"\r\n          }), p90=${percentileLineError.toFixed(3)}px`,\r\n        );\r\n        console.log(\r\n          `  Circle: median=${medianCircleError.toFixed(3)}px (${\r\n            circleOk ? \"\u2713\" : \"\u2717\"\r\n          }), p90=${percentileCircleError.toFixed(3)}px`,\r\n        );\r\n        if (circleFit.getCount() >= MIN_POINTS) {\r\n          const circleFitResult = circleFit.getFit();\r\n          if (circleFitResult.valid) {\r\n            console.log(\r\n              `  Circle fit: center=(${circleFitResult.center.x.toFixed(1)}, ${\r\n                circleFitResult.center.y.toFixed(1)\r\n              }), radius=${circleFitResult.radius.toFixed(1)}px`,\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Stop if fits are getting worse - if neither fit has good median anymore, stop even if p90 is ok\r\n      // This prevents creating long segments with mediocre fits\r\n      const lineMedianBad = medianLineError > MAX_ERROR;\r\n      const circleMedianBad = medianCircleError > MAX_ERROR;\r\n\r\n      if (lineOk || circleOk) {\r\n        // Allow continuing if at least one fit is fully within tolerance\r\n        // But stop if both medians are bad (even if one p90 is still ok)\r\n        if (lineMedianBad && circleMedianBad) {\r\n          console.log(\r\n            `[Segment ${segStart}-${j}] STOPPED - both median errors exceeded ${MAX_ERROR}px`,\r\n          );\r\n          break;\r\n        }\r\n        j++;\r\n        continue;\r\n      }\r\n\r\n      // Both fits failed - stop growing\r\n      console.log(\r\n        `[Segment ${segStart}-${j}] STOPPED - both fits exceeded tolerance`,\r\n      );\r\n      break;\r\n    }\r\n\r\n    // Determine segment end based on where we stopped and path end proximity\r\n    let segEnd: number;\r\n\r\n    // Check if we're at or very close to the end of the path\r\n    if (j >= N - 1) {\r\n      // Reached the end naturally - use the last point\r\n      segEnd = N - 1;\r\n      console.log(\r\n        `[Segment reached end] ${segStart}-${segEnd} (${\r\n          segEnd - segStart + 1\r\n        } points)`,\r\n      );\r\n    } else if (N - 1 - j <= LOOKAHEAD_POINTS + 2) {\r\n      // Close to the end - try extending to the end if fit is still good\r\n      const extendedLineFit = new IncrementalLineFit();\r\n      const extendedCircleFit = new IncrementalCircleFit();\r\n      const extendedLineErrors: number[] = [];\r\n      const extendedCircleErrors: number[] = [];\r\n\r\n      for (let k = segStart; k < N; k++) {\r\n        extendedLineFit.addPoint(points[k]);\r\n        extendedCircleFit.addPoint(points[k]);\r\n      }\r\n\r\n      for (let k = segStart; k < N; k++) {\r\n        extendedLineErrors.push(extendedLineFit.distanceToPoint(points[k]));\r\n        extendedCircleErrors.push(extendedCircleFit.distanceToPoint(points[k]));\r\n      }\r\n\r\n      const medianLineError = percentile(extendedLineErrors, 0.5);\r\n      const medianCircleError = percentile(extendedCircleErrors, 0.5);\r\n      const p90LineError = percentile(extendedLineErrors, ERROR_PERCENTILE);\r\n      const p90CircleError = percentile(extendedCircleErrors, ERROR_PERCENTILE);\r\n\r\n      const lineOk = medianLineError <= MAX_ERROR &&\r\n        p90LineError <= MAX_ERROR_P90;\r\n      const circleOk = medianCircleError <= MAX_ERROR &&\r\n        p90CircleError <= MAX_ERROR_P90;\r\n\r\n      if (lineOk || circleOk) {\r\n        segEnd = N - 1;\r\n        console.log(\r\n          `[Segment extended to end] ${segStart}-${segEnd} (${\r\n            segEnd - segStart + 1\r\n          } points, fit still good)`,\r\n        );\r\n      } else {\r\n        // Can't extend - use normal backup\r\n        segEnd = Math.max(j - LOOKAHEAD_POINTS, segStart + MIN_POINTS - 1);\r\n        console.log(\r\n          `[Segment near end, can't extend] ${segStart}-${segEnd} (${\r\n            segEnd - segStart + 1\r\n          } points, ${N - 1 - segEnd} points remain)`,\r\n        );\r\n      }\r\n    } else {\r\n      // Normal case: back up by lookahead points\r\n      segEnd = Math.max(j - LOOKAHEAD_POINTS, segStart + MIN_POINTS - 1);\r\n    }\r\n\r\n    console.log(\r\n      `[Segment finalized] ${segStart}-${segEnd} (${\r\n        segEnd - segStart + 1\r\n      } points, backed up ${j - segEnd} points)`,\r\n    );\r\n\r\n    // Create segment (classification happens later)\r\n    segments.push({\r\n      startIndex: segStart,\r\n      endIndex: Math.min(segEnd, N - 1),\r\n      type: \"line\", // Will be classified later\r\n    });\r\n\r\n    i = segEnd + 1;\r\n  }\r\n\r\n  // For open paths, try extending first/last segments to path boundaries\r\n  if (!isClosed && segments.length > 0) {\r\n    const extended = extendBoundarySegments(points, segments);\r\n\r\n    // Handle closed paths by attempting to merge first and last segments\r\n    if (isClosed && extended.length >= 2) {\r\n      const merged = reconcileClosedPath(points, extended);\r\n      return merged;\r\n    }\r\n\r\n    return extended;\r\n  }\r\n\r\n  // Handle closed paths by attempting to merge first and last segments\r\n  if (isClosed && segments.length >= 2) {\r\n    const merged = reconcileClosedPath(points, segments);\r\n    return merged;\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\n/**\r\n * Helper: Try extending a segment boundary incrementally, stopping when fit degrades\r\n * Tests both line and arc fits since segment type isn't determined yet\r\n */\r\nfunction tryExtendBoundary(\r\n  points: Point[],\r\n  startIndex: number,\r\n  endIndex: number,\r\n  direction: \"start\" | \"end\",\r\n  targetIndex: number,\r\n): number {\r\n  // Calculate baseline error\r\n  const baselinePoints: Point[] = [];\r\n  for (let i = startIndex; i <= endIndex; i++) {\r\n    baselinePoints.push(points[i]);\r\n  }\r\n  const baselineFit = new IncrementalLineFit();\r\n  for (const p of baselinePoints) {\r\n    baselineFit.addPoint(p);\r\n  }\r\n  const baselineErrors = baselinePoints.map((p) =>\r\n    baselineFit.distanceToPoint(p)\r\n  );\r\n  let bestError = percentile(baselineErrors, 0.5);\r\n  let bestIndex = direction === \"start\" ? startIndex : endIndex;\r\n\r\n  // Determine iteration parameters based on direction\r\n  const step = direction === \"start\" ? -1 : 1;\r\n  const shouldContinue = direction === \"start\"\r\n    ? (idx: number) => idx >= targetIndex\r\n    : (idx: number) => idx < targetIndex;\r\n\r\n  // Try extending incrementally\r\n  for (\r\n    let testIdx = bestIndex + step;\r\n    shouldContinue(testIdx);\r\n    testIdx += step\r\n  ) {\r\n    const testPoints: Point[] = [];\r\n    const testStart = direction === \"start\" ? testIdx : startIndex;\r\n    const testEnd = direction === \"end\" ? testIdx : endIndex;\r\n\r\n    for (let i = testStart; i <= testEnd; i++) {\r\n      testPoints.push(points[i]);\r\n    }\r\n\r\n    // Test both line and arc fits\r\n    const lineFit = new IncrementalLineFit();\r\n    const circleFit = new IncrementalCircleFit();\r\n    for (const p of testPoints) {\r\n      lineFit.addPoint(p);\r\n      circleFit.addPoint(p);\r\n    }\r\n\r\n    const lineErrors = testPoints.map((p) => lineFit.distanceToPoint(p));\r\n    const circleErrors = testPoints.map((p) => circleFit.distanceToPoint(p));\r\n\r\n    const lineMedian = percentile(lineErrors, 0.5);\r\n    const circleMedian = percentile(circleErrors, 0.5);\r\n    const lineP90 = percentile(lineErrors, ERROR_PERCENTILE);\r\n    const circleP90 = percentile(circleErrors, ERROR_PERCENTILE);\r\n\r\n    const circleResult = circleFit.getFit();\r\n    const lineOk = lineMedian <= MAX_ERROR && lineP90 <= MAX_ERROR_P90;\r\n    const circleOk = circleResult.valid && circleMedian <= MAX_ERROR &&\r\n      circleP90 <= MAX_ERROR_P90;\r\n\r\n    // Use whichever fit is better\r\n    const testMedian = (lineOk && circleOk)\r\n      ? Math.min(lineMedian, circleMedian)\r\n      : lineOk\r\n      ? lineMedian\r\n      : circleOk\r\n      ? circleMedian\r\n      : Infinity;\r\n\r\n    // Accept if it improves or maintains fit within tolerance\r\n    if (testMedian <= bestError && testMedian !== Infinity) {\r\n      bestIndex = testIdx;\r\n      bestError = testMedian;\r\n    } else {\r\n      // Stop extending if fit degrades\r\n      break;\r\n    }\r\n  }\r\n\r\n  return bestIndex;\r\n}\r\n\r\n/**\r\n * Extend first and last segments of open paths to reach path boundaries (indices 0 and N-1)\r\n */\r\nfunction extendBoundarySegments(\r\n  points: Point[],\r\n  segments: Segment[],\r\n): Segment[] {\r\n  if (segments.length === 0) return segments;\r\n\r\n  const N = points.length;\r\n  const result = [...segments];\r\n\r\n  // Try extending first segment toward index 0\r\n  if (result[0].startIndex > 0) {\r\n    const seg = result[0];\r\n    const bestStartIndex = tryExtendBoundary(\r\n      points,\r\n      seg.startIndex,\r\n      seg.endIndex,\r\n      \"start\",\r\n      0,\r\n    );\r\n\r\n    if (bestStartIndex < seg.startIndex) {\r\n      result[0] = { ...seg, startIndex: bestStartIndex };\r\n      console.log(\r\n        `[Extended first segment toward path start] ${bestStartIndex}-${seg.endIndex} (was ${seg.startIndex}-${seg.endIndex})`,\r\n      );\r\n    }\r\n  }\r\n\r\n  // Try extending last segment toward index N-1\r\n  const lastIdx = result.length - 1;\r\n  if (result[lastIdx].endIndex < N - 1) {\r\n    const seg = result[lastIdx];\r\n    const bestEndIndex = tryExtendBoundary(\r\n      points,\r\n      seg.startIndex,\r\n      seg.endIndex,\r\n      \"end\",\r\n      N,\r\n    );\r\n\r\n    if (bestEndIndex > seg.endIndex) {\r\n      result[lastIdx] = { ...seg, endIndex: bestEndIndex };\r\n      console.log(\r\n        `[Extended last segment toward path end] ${seg.startIndex}-${bestEndIndex} (was ${seg.startIndex}-${seg.endIndex})`,\r\n      );\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Reconcile closed paths by attempting to merge first and last segments\r\n */\r\nfunction reconcileClosedPath(points: Point[], segments: Segment[]): Segment[] {\r\n  if (segments.length < 2) return segments;\r\n\r\n  const first = segments[0];\r\n  const last = segments[segments.length - 1];\r\n\r\n  // Collect wrapped points from last.startIndex to first.endIndex\r\n  const wrappedPoints: Point[] = [];\r\n  for (let i = last.startIndex; i < points.length; i++) {\r\n    wrappedPoints.push(points[i]);\r\n  }\r\n  for (let i = 0; i <= first.endIndex; i++) {\r\n    wrappedPoints.push(points[i]);\r\n  }\r\n\r\n  if (wrappedPoints.length < MIN_POINTS) return segments;\r\n\r\n  // Try fitting both line and circle to merged segment\r\n  const lineFit = new IncrementalLineFit();\r\n  const circleFit = new IncrementalCircleFit();\r\n  const lineErrors: number[] = [];\r\n  const circleErrors: number[] = [];\r\n\r\n  for (const p of wrappedPoints) {\r\n    lineFit.addPoint(p);\r\n    circleFit.addPoint(p);\r\n  }\r\n\r\n  for (const p of wrappedPoints) {\r\n    lineErrors.push(lineFit.distanceToPoint(p));\r\n    circleErrors.push(circleFit.distanceToPoint(p));\r\n  }\r\n\r\n  const medianLineError = percentile(lineErrors, 0.5);\r\n  const medianCircleError = percentile(circleErrors, 0.5);\r\n  const p90LineError = percentile(lineErrors, ERROR_PERCENTILE);\r\n  const p90CircleError = percentile(circleErrors, ERROR_PERCENTILE);\r\n\r\n  const lineOk = medianLineError <= MAX_ERROR && p90LineError <= MAX_ERROR_P90;\r\n  const circleOk = medianCircleError <= MAX_ERROR &&\r\n    p90CircleError <= MAX_ERROR_P90;\r\n\r\n  // If either fit is within tolerance, merge the segments\r\n  if (lineOk || circleOk) {\r\n    console.log(\r\n      `[Closed path] Merging first and last segments: ${last.startIndex}-${first.endIndex} (${wrappedPoints.length} points)`,\r\n    );\r\n    const newSegment: Segment = {\r\n      startIndex: last.startIndex,\r\n      endIndex: first.endIndex,\r\n      type: \"line\", // Will be classified later\r\n    };\r\n\r\n    // Remove first and last, prepend merged segment\r\n    return [newSegment, ...segments.slice(1, -1)];\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\n/**\r\n * Classify segments as line or arc based on fit quality\r\n */\r\nexport function classifySegments(\r\n  points: Point[],\r\n  segments: Segment[],\r\n  isClosed: boolean,\r\n): Segment[] {\r\n  return segments.map((seg) => {\r\n    const segPoints = extractSegmentPoints(points, seg, isClosed);\r\n\r\n    if (segPoints.length < MIN_POINTS) {\r\n      return { ...seg, type: \"line\" };\r\n    }\r\n\r\n    // Fit line\r\n    const lineFit = new IncrementalLineFit();\r\n    const lineErrors: number[] = [];\r\n    for (const p of segPoints) {\r\n      lineFit.addPoint(p);\r\n    }\r\n    const lineResult = lineFit.getFit();\r\n    for (const p of segPoints) {\r\n      lineErrors.push(lineFit.distanceToPoint(p));\r\n    }\r\n    const medianLineError = percentile(lineErrors, 0.5);\r\n    const p90LineError = percentile(lineErrors, ERROR_PERCENTILE);\r\n\r\n    // Fit circle\r\n    const circleFit = new IncrementalCircleFit();\r\n    const circleErrors: number[] = [];\r\n    for (const p of segPoints) {\r\n      circleFit.addPoint(p);\r\n    }\r\n    const circleResult = circleFit.getFit();\r\n    let medianCircleError = Infinity;\r\n    let p90CircleError = Infinity;\r\n    let sweepAngle = 0;\r\n    let clockwise = false;\r\n\r\n    if (circleResult.valid) {\r\n      for (const p of segPoints) {\r\n        circleErrors.push(circleFit.distanceToPoint(p));\r\n      }\r\n      medianCircleError = percentile(circleErrors, 0.5);\r\n      p90CircleError = percentile(circleErrors, ERROR_PERCENTILE);\r\n\r\n      // Calculate sweep angle\r\n      const startAngle = Math.atan2(\r\n        segPoints[0].y - circleResult.center.y,\r\n        segPoints[0].x - circleResult.center.x,\r\n      );\r\n      const endAngle = Math.atan2(\r\n        segPoints[segPoints.length - 1].y - circleResult.center.y,\r\n        segPoints[segPoints.length - 1].x - circleResult.center.x,\r\n      );\r\n\r\n      // Calculate angular span traveled and direction\r\n      let totalAngle = 0;\r\n      let cumulativeAngle = 0;\r\n      for (let i = 1; i < segPoints.length; i++) {\r\n        const angle1 = Math.atan2(\r\n          segPoints[i - 1].y - circleResult.center.y,\r\n          segPoints[i - 1].x - circleResult.center.x,\r\n        );\r\n        const angle2 = Math.atan2(\r\n          segPoints[i].y - circleResult.center.y,\r\n          segPoints[i].x - circleResult.center.x,\r\n        );\r\n        let deltaAngle = angle2 - angle1;\r\n\r\n        // Normalize to [-\u03C0, \u03C0]\r\n        while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;\r\n        while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;\r\n\r\n        cumulativeAngle += deltaAngle;\r\n        totalAngle += Math.abs(deltaAngle);\r\n      }\r\n      sweepAngle = totalAngle;\r\n\r\n      // Determine direction based on cumulative angle change\r\n      // In SVG coords (y-axis points down):\r\n      // - Positive cumulative angle = clockwise rotation\r\n      // - Negative cumulative angle = counter-clockwise rotation\r\n      clockwise = cumulativeAngle > 0;\r\n    }\r\n\r\n    // Decide: arc, line, or unfitted?\r\n    // Check if either fit meets tolerance requirements\r\n    const lineWithinTolerance = medianLineError <= MAX_ERROR &&\r\n      p90LineError <= MAX_ERROR_P90;\r\n    const circleWithinTolerance = medianCircleError <= MAX_ERROR &&\r\n      p90CircleError <= MAX_ERROR_P90;\r\n\r\n    // If neither fit is within tolerance, mark as unfitted (keep as pixel polyline)\r\n    if (!lineWithinTolerance && !circleWithinTolerance) {\r\n      console.log(\r\n        `[Classify segment ${seg.startIndex}-${seg.endIndex}] ${segPoints.length} points`,\r\n      );\r\n      console.log(\r\n        `  Line: median=${medianLineError.toFixed(3)}px, p90=${\r\n          p90LineError.toFixed(3)\r\n        }px (\u2717)`,\r\n      );\r\n      console.log(\r\n        `  Circle: median=${medianCircleError.toFixed(3)}px, p90=${\r\n          p90CircleError.toFixed(3)\r\n        }px (\u2717)`,\r\n      );\r\n      console.log(`  \u2192 Classified as: UNFITTED (neither fit within tolerance)`);\r\n\r\n      return {\r\n        ...seg,\r\n        type: \"polyline\", // Keep raw skeleton pixels\r\n      };\r\n    }\r\n\r\n    // Prefer arc if:\r\n    // 1. Circle fit is valid\r\n    // 2. Circle error meets tolerance requirements\r\n    // 3. Circle error is significantly better than line error\r\n    // 4. Sweep angle is sufficient\r\n    const isArc = circleResult.valid &&\r\n      circleWithinTolerance &&\r\n      medianCircleError <= medianLineError * ARC_PREFERENCE_FACTOR &&\r\n      sweepAngle >= MIN_SWEEP_ANGLE;\r\n\r\n    console.log(\r\n      `[Classify segment ${seg.startIndex}-${seg.endIndex}] ${segPoints.length} points`,\r\n    );\r\n    console.log(\r\n      `  Line: median=${medianLineError.toFixed(3)}px, p90=${\r\n        p90LineError.toFixed(3)\r\n      }px`,\r\n    );\r\n    console.log(\r\n      `  Circle: median=${medianCircleError.toFixed(3)}px, p90=${\r\n        p90CircleError.toFixed(3)\r\n      }px, valid=${circleResult.valid}, sweep=${\r\n        (sweepAngle * 180 / Math.PI).toFixed(1)\r\n      }\u00B0`,\r\n    );\r\n    if (circleResult.valid) {\r\n      console.log(\r\n        `  Circle: center=(${circleResult.center.x.toFixed(1)}, ${\r\n          circleResult.center.y.toFixed(1)\r\n        }), radius=${circleResult.radius.toFixed(1)}px`,\r\n      );\r\n    }\r\n    console.log(\r\n      `  \u2192 Classified as: ${isArc ? \"ARC\" : \"LINE\"} (circle ${\r\n        medianCircleError.toFixed(3)\r\n      } vs line ${medianLineError.toFixed(3)} * ${ARC_PREFERENCE_FACTOR})`,\r\n    );\r\n\r\n    if (isArc) {\r\n      // Project start and end points onto fitted circle\r\n      const start = segPoints[0];\r\n      const end = segPoints[segPoints.length - 1];\r\n      const center = circleResult.center;\r\n      const radius = circleResult.radius;\r\n\r\n      // Project start point\r\n      const dx0 = start.x - center.x;\r\n      const dy0 = start.y - center.y;\r\n      const dist0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);\r\n      const projStart = {\r\n        x: center.x + (dx0 / dist0) * radius,\r\n        y: center.y + (dy0 / dist0) * radius,\r\n      };\r\n\r\n      // Project end point\r\n      const dx1 = end.x - center.x;\r\n      const dy1 = end.y - center.y;\r\n      const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\r\n      const projEnd = {\r\n        x: center.x + (dx1 / dist1) * radius,\r\n        y: center.y + (dy1 / dist1) * radius,\r\n      };\r\n\r\n      return {\r\n        ...seg,\r\n        type: \"arc\",\r\n        projectedStart: projStart,\r\n        projectedEnd: projEnd,\r\n        circleFit: {\r\n          center: circleResult.center,\r\n          radius: circleResult.radius,\r\n          error: medianCircleError,\r\n          sweepAngle,\r\n          clockwise,\r\n        },\r\n      };\r\n    } else {\r\n      // Project start and end points onto fitted line\r\n      const start = segPoints[0];\r\n      const end = segPoints[segPoints.length - 1];\r\n      const centroid = lineResult.centroid;\r\n      const direction = lineResult.direction;\r\n\r\n      // Project onto line: P_proj = centroid + t * direction\r\n      // where t = (P - centroid) \u00B7 direction\r\n      const projectPoint = (p: Point) => {\r\n        const vx = p.x - centroid.x;\r\n        const vy = p.y - centroid.y;\r\n        const t = vx * direction.x + vy * direction.y;\r\n        return {\r\n          x: centroid.x + t * direction.x,\r\n          y: centroid.y + t * direction.y,\r\n        };\r\n      };\r\n\r\n      const projStart = projectPoint(start);\r\n      const projEnd = projectPoint(end);\r\n\r\n      return {\r\n        ...seg,\r\n        type: \"line\",\r\n        projectedStart: projStart,\r\n        projectedEnd: projEnd,\r\n        lineFit: {\r\n          centroid: lineResult.centroid,\r\n          direction: lineResult.direction,\r\n          error: medianLineError,\r\n        },\r\n      };\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Extract points for a segment, handling wrap-around for closed paths\r\n */\r\nfunction extractSegmentPoints(\r\n  points: Point[],\r\n  segment: Segment,\r\n  isClosed: boolean,\r\n): Point[] {\r\n  const result: Point[] = [];\r\n\r\n  if (segment.endIndex >= segment.startIndex) {\r\n    // Normal case: no wrap-around\r\n    for (let i = segment.startIndex; i <= segment.endIndex; i++) {\r\n      result.push(points[i]);\r\n    }\r\n  } else if (isClosed) {\r\n    // Wrap-around case for closed paths\r\n    for (let i = segment.startIndex; i < points.length; i++) {\r\n      result.push(points[i]);\r\n    }\r\n    for (let i = 0; i <= segment.endIndex; i++) {\r\n      result.push(points[i]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Refine segment boundaries to minimize fitting error\r\n * Try extending or trimming endpoints to improve fit quality\r\n */\r\nfunction refineSegmentBoundaries(\r\n  points: Point[],\r\n  segments: Segment[],\r\n  isClosed: boolean,\r\n): Segment[] {\r\n  const refined: Segment[] = [];\r\n\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const seg = segments[i];\r\n\r\n    // Only refine fitted segments (line/arc)\r\n    if (seg.type !== \"line\" && seg.type !== \"arc\") {\r\n      refined.push(seg);\r\n      continue;\r\n    }\r\n\r\n    // Get current segment points\r\n    const currentSegPoints = extractSegmentPoints(points, seg, isClosed);\r\n    if (currentSegPoints.length < MIN_POINTS) {\r\n      refined.push(seg);\r\n      continue;\r\n    }\r\n\r\n    let bestStartIndex = seg.startIndex;\r\n    let bestEndIndex = seg.endIndex;\r\n    let bestError = Infinity;\r\n\r\n    // Calculate baseline error\r\n    const baselineFit = seg.type === \"line\"\r\n      ? new IncrementalLineFit()\r\n      : new IncrementalCircleFit();\r\n    for (const p of currentSegPoints) {\r\n      baselineFit.addPoint(p);\r\n    }\r\n    const baselineErrors = currentSegPoints.map((p) =>\r\n      baselineFit.distanceToPoint(p)\r\n    );\r\n    bestError = percentile(baselineErrors, 0.5);\r\n\r\n    // Check if boundary points fit well\r\n    const startPointError = baselineErrors[0];\r\n    const endPointError = baselineErrors[baselineErrors.length - 1];\r\n\r\n    const adjustment_range = 5; // Max points to adjust\r\n\r\n    // Determine if this segment is at a path boundary (only for open paths)\r\n    const isFirstSegment = i === 0;\r\n    const isLastSegment = i === segments.length - 1;\r\n\r\n    // Phase 1: Find optimal start index by testing extensions/trims independently\r\n    // Look for local minima: keep extending as long as error decreases or stays similar\r\n    let optimalStartIndex = seg.startIndex;\r\n    let bestStartError = bestError;\r\n\r\n    // Don't trim from start if the start point already fits well\r\n    const canTrimStart = startPointError > MAX_ERROR;\r\n\r\n    // Try extending/trimming start\r\n    for (\r\n      let startDelta = -adjustment_range;\r\n      startDelta <= adjustment_range;\r\n      startDelta++\r\n    ) {\r\n      if (startDelta === 0) continue;\r\n\r\n      // Skip trimming if start fits well\r\n      if (startDelta > 0 && !canTrimStart) continue;\r\n\r\n      const newStartIndex = seg.startIndex + startDelta;\r\n\r\n      // Ensure index is within bounds\r\n      if (newStartIndex < 0 || newStartIndex >= points.length) continue;\r\n\r\n      // Ensure we don't overlap with previous segment\r\n      if (i > 0 && !isClosed) {\r\n        const prevSegEnd = refined[i - 1].endIndex;\r\n        if (newStartIndex <= prevSegEnd) continue;\r\n      }\r\n\r\n      // Test this start index with current end index\r\n      const testSegLength = seg.endIndex >= newStartIndex\r\n        ? seg.endIndex - newStartIndex + 1\r\n        : (points.length - newStartIndex) + seg.endIndex + 1;\r\n      if (testSegLength < MIN_POINTS) continue;\r\n\r\n      const testPoints = extractSegmentPoints(\r\n        points,\r\n        { startIndex: newStartIndex, endIndex: seg.endIndex, type: seg.type },\r\n        isClosed,\r\n      );\r\n\r\n      if (testPoints.length < MIN_POINTS) continue;\r\n\r\n      const testFit = seg.type === \"line\"\r\n        ? new IncrementalLineFit()\r\n        : new IncrementalCircleFit();\r\n      for (const p of testPoints) {\r\n        testFit.addPoint(p);\r\n      }\r\n\r\n      if (seg.type === \"arc\") {\r\n        const circleFit = testFit as IncrementalCircleFit;\r\n        const result = circleFit.getFit();\r\n        if (!result.valid) continue;\r\n      }\r\n\r\n      const testErrors = testPoints.map((p) => testFit.distanceToPoint(p));\r\n      const testMedian = percentile(testErrors, 0.5);\r\n      const testP90 = percentile(testErrors, ERROR_PERCENTILE);\r\n\r\n      // Accept if error improves or stays very similar (within 5%)\r\n      // This finds local minima for extensions\r\n      if (\r\n        testMedian <= MAX_ERROR &&\r\n        testP90 <= MAX_ERROR_P90 &&\r\n        testMedian <= bestStartError * 1.05\r\n      ) {\r\n        // For extensions (negative delta), require actual improvement\r\n        // For trims (positive delta), allow if it improves\r\n        if (startDelta < 0 && testMedian < bestStartError) {\r\n          optimalStartIndex = newStartIndex;\r\n          bestStartError = testMedian;\r\n        } else if (startDelta > 0 && testMedian < bestStartError) {\r\n          optimalStartIndex = newStartIndex;\r\n          bestStartError = testMedian;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Phase 2: Find optimal end index using the optimal start index\r\n    let optimalEndIndex = seg.endIndex;\r\n    let bestEndError = bestStartError;\r\n\r\n    // Don't trim from end if the end point already fits well\r\n    const canTrimEnd = endPointError > MAX_ERROR;\r\n\r\n    // Try extending/trimming end\r\n    for (\r\n      let endDelta = -adjustment_range;\r\n      endDelta <= adjustment_range;\r\n      endDelta++\r\n    ) {\r\n      if (endDelta === 0) continue;\r\n\r\n      // Skip trimming if end fits well\r\n      if (endDelta < 0 && !canTrimEnd) continue;\r\n\r\n      const newEndIndex = seg.endIndex + endDelta;\r\n\r\n      // Ensure index is within bounds\r\n      if (newEndIndex < 0 || newEndIndex >= points.length) continue;\r\n\r\n      // Ensure we don't overlap with next segment\r\n      if (i < segments.length - 1 && !isClosed) {\r\n        const nextSegStart = segments[i + 1].startIndex;\r\n        if (newEndIndex >= nextSegStart) continue;\r\n      }\r\n\r\n      // Test this end index with optimal start index\r\n      const testSegLength = newEndIndex >= optimalStartIndex\r\n        ? newEndIndex - optimalStartIndex + 1\r\n        : (points.length - optimalStartIndex) + newEndIndex + 1;\r\n      if (testSegLength < MIN_POINTS) continue;\r\n\r\n      const testPoints = extractSegmentPoints(\r\n        points,\r\n        {\r\n          startIndex: optimalStartIndex,\r\n          endIndex: newEndIndex,\r\n          type: seg.type,\r\n        },\r\n        isClosed,\r\n      );\r\n\r\n      if (testPoints.length < MIN_POINTS) continue;\r\n\r\n      const testFit = seg.type === \"line\"\r\n        ? new IncrementalLineFit()\r\n        : new IncrementalCircleFit();\r\n      for (const p of testPoints) {\r\n        testFit.addPoint(p);\r\n      }\r\n\r\n      if (seg.type === \"arc\") {\r\n        const circleFit = testFit as IncrementalCircleFit;\r\n        const result = circleFit.getFit();\r\n        if (!result.valid) continue;\r\n      }\r\n\r\n      const testErrors = testPoints.map((p) => testFit.distanceToPoint(p));\r\n      const testMedian = percentile(testErrors, 0.5);\r\n      const testP90 = percentile(testErrors, ERROR_PERCENTILE);\r\n\r\n      // Accept if error improves or stays very similar (within 5%)\r\n      if (\r\n        testMedian <= MAX_ERROR &&\r\n        testP90 <= MAX_ERROR_P90 &&\r\n        testMedian <= bestEndError * 1.05\r\n      ) {\r\n        // For extensions (positive delta), require actual improvement\r\n        // For trims (negative delta), allow if it improves\r\n        if (endDelta > 0 && testMedian < bestEndError) {\r\n          optimalEndIndex = newEndIndex;\r\n          bestEndError = testMedian;\r\n        } else if (endDelta < 0 && testMedian < bestEndError) {\r\n          optimalEndIndex = newEndIndex;\r\n          bestEndError = testMedian;\r\n        }\r\n      }\r\n    }\r\n\r\n    bestStartIndex = optimalStartIndex;\r\n    bestEndIndex = optimalEndIndex;\r\n    bestError = bestEndError;\r\n\r\n    // Update segment if we found improvement\r\n    // But enforce continuity: refined segments must be adjacent (no gaps)\r\n    if (bestStartIndex !== seg.startIndex || bestEndIndex !== seg.endIndex) {\r\n      // Check for gaps with previous segment\r\n      if (i > 0) {\r\n        const prevEnd = refined[i - 1].endIndex;\r\n        // Ensure no gap: new segment must start at prevEnd+1 or earlier\r\n        if (bestStartIndex > prevEnd + 1) {\r\n          // Would create a gap - adjust start to maintain continuity\r\n          bestStartIndex = prevEnd + 1;\r\n          console.log(\r\n            `[Refine segment ${seg.startIndex}-${seg.endIndex}] Gap detected, adjusted start to ${bestStartIndex}`,\r\n          );\r\n        }\r\n      }\r\n\r\n      console.log(\r\n        `[Refine segment ${seg.startIndex}-${seg.endIndex}] \u2192 [${bestStartIndex}-${bestEndIndex}] (error ${\r\n          bestError.toFixed(3)\r\n        }px)`,\r\n      );\r\n      refined.push({\r\n        ...seg,\r\n        startIndex: bestStartIndex,\r\n        endIndex: bestEndIndex,\r\n      });\r\n    } else {\r\n      refined.push(seg);\r\n    }\r\n  }\r\n\r\n  return refined;\r\n}\r\n\r\n/**\r\n * Find intersection point between two line segments (infinite lines)\r\n */\r\nfunction lineLineIntersection(\r\n  line1: { centroid: Point; direction: Point },\r\n  line2: { centroid: Point; direction: Point },\r\n): Point | null {\r\n  const { centroid: c1, direction: d1 } = line1;\r\n  const { centroid: c2, direction: d2 } = line2;\r\n\r\n  // Solve: c1 + t*d1 = c2 + s*d2\r\n  // In matrix form: [d1x -d2x][t] = [c2x - c1x]\r\n  //                 [d1y -d2y][s]   [c2y - c1y]\r\n\r\n  const det = d1.x * (-d2.y) - d1.y * (-d2.x);\r\n  if (Math.abs(det) < 1e-10) return null; // Parallel lines\r\n\r\n  const dx = c2.x - c1.x;\r\n  const dy = c2.y - c1.y;\r\n\r\n  const t = (dx * (-d2.y) - dy * (-d2.x)) / det;\r\n\r\n  return {\r\n    x: c1.x + t * d1.x,\r\n    y: c1.y + t * d1.y,\r\n  };\r\n}\r\n\r\n/**\r\n * Find intersection points between a line and a circle\r\n */\r\nfunction lineCircleIntersection(\r\n  line: { centroid: Point; direction: Point },\r\n  circle: { center: Point; radius: number },\r\n): Point[] {\r\n  const { centroid, direction } = line;\r\n  const { center, radius } = circle;\r\n\r\n  // Parametric line: P = centroid + t * direction\r\n  // Circle: |P - center|^2 = radius^2\r\n  // Substitute and solve quadratic for t\r\n\r\n  const dx = centroid.x - center.x;\r\n  const dy = centroid.y - center.y;\r\n\r\n  const a = direction.x * direction.x + direction.y * direction.y;\r\n  const b = 2 * (dx * direction.x + dy * direction.y);\r\n  const c = dx * dx + dy * dy - radius * radius;\r\n\r\n  const discriminant = b * b - 4 * a * c;\r\n  if (discriminant < 0) return []; // No intersection\r\n\r\n  const sqrtDisc = Math.sqrt(discriminant);\r\n  const t1 = (-b - sqrtDisc) / (2 * a);\r\n  const t2 = (-b + sqrtDisc) / (2 * a);\r\n\r\n  const result: Point[] = [];\r\n  result.push({\r\n    x: centroid.x + t1 * direction.x,\r\n    y: centroid.y + t1 * direction.y,\r\n  });\r\n  if (discriminant > 1e-10) {\r\n    result.push({\r\n      x: centroid.x + t2 * direction.x,\r\n      y: centroid.y + t2 * direction.y,\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Find intersection points between two circles\r\n */\r\nfunction circleCircleIntersection(\r\n  circle1: { center: Point; radius: number },\r\n  circle2: { center: Point; radius: number },\r\n): Point[] {\r\n  const { center: c1, radius: r1 } = circle1;\r\n  const { center: c2, radius: r2 } = circle2;\r\n\r\n  const dx = c2.x - c1.x;\r\n  const dy = c2.y - c1.y;\r\n  const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  // Check if circles are too far apart or one contains the other\r\n  if (dist > r1 + r2 || dist < Math.abs(r1 - r2) || dist < 1e-10) {\r\n    return [];\r\n  }\r\n\r\n  // Find intersection points\r\n  const a = (r1 * r1 - r2 * r2 + dist * dist) / (2 * dist);\r\n  const h = Math.sqrt(r1 * r1 - a * a);\r\n\r\n  const px = c1.x + a * (dx / dist);\r\n  const py = c1.y + a * (dy / dist);\r\n\r\n  const result: Point[] = [];\r\n  result.push({\r\n    x: px + h * (-dy / dist),\r\n    y: py + h * (dx / dist),\r\n  });\r\n\r\n  if (h > 1e-10) {\r\n    result.push({\r\n      x: px - h * (-dy / dist),\r\n      y: py - h * (dx / dist),\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Choose the closest intersection point to a reference point\r\n */\r\nfunction closestIntersection(\r\n  intersections: Point[],\r\n  reference: Point,\r\n): Point | null {\r\n  if (intersections.length === 0) return null;\r\n\r\n  let closest = intersections[0];\r\n  let minDist = Infinity;\r\n\r\n  for (const pt of intersections) {\r\n    const dx = pt.x - reference.x;\r\n    const dy = pt.y - reference.y;\r\n    const dist = dx * dx + dy * dy;\r\n    if (dist < minDist) {\r\n      minDist = dist;\r\n      closest = pt;\r\n    }\r\n  }\r\n\r\n  return closest;\r\n}\r\n\r\n/**\r\n * Refine segment connections by finding intersections and bridging gaps\r\n */\r\nfunction refineSegmentConnections(\r\n  points: Point[],\r\n  segments: Segment[],\r\n  isClosed: boolean,\r\n): Segment[] {\r\n  if (segments.length < 2) return segments;\r\n\r\n  // Make a working copy since we'll modify segments in place\r\n  const workingSegments = segments.map((s) => ({ ...s }));\r\n  const result: Segment[] = [];\r\n  const MAX_EXTENSION_ERROR = 0.75; // Same as MAX_ERROR\r\n  const MIN_BRIDGE_SIZE = 3; // Minimum points for a bridge segment\r\n\r\n  for (let i = 0; i < workingSegments.length; i++) {\r\n    const seg = workingSegments[i];\r\n    const isLastSegment = i === workingSegments.length - 1;\r\n    const nextSeg = !isLastSegment\r\n      ? workingSegments[i + 1]\r\n      : (isClosed ? workingSegments[0] : null);\r\n\r\n    result.push(seg);\r\n\r\n    if (!nextSeg) continue;\r\n\r\n    // Check if there's a gap between segments (or if they're adjacent)\r\n    // For closed paths wrapping from last segment to first, calculate wrap-around gap\r\n    const gapSize = (isLastSegment && isClosed)\r\n      ? (points.length - 1 - seg.endIndex) + nextSeg.startIndex\r\n      : nextSeg.startIndex - seg.endIndex - 1;\r\n\r\n    const nextSegIdx = isLastSegment && isClosed ? 0 : i + 1;\r\n\r\n    // Process intersection for adjacent or gapped segments\r\n    if (gapSize < 0) continue; // Skip overlapping segments\r\n\r\n    if (gapSize === 0) {\r\n      console.log(\r\n        `[Refine connections] Adjacent segments ${i} [${seg.startIndex}-${seg.endIndex}] and ${nextSegIdx} [${nextSeg.startIndex}-${nextSeg.endIndex}]`,\r\n      );\r\n    } else {\r\n      console.log(\r\n        `[Refine connections] Gap between seg ${i} [${seg.startIndex}-${seg.endIndex}] and seg ${nextSegIdx} [${nextSeg.startIndex}-${nextSeg.endIndex}]: ${gapSize} points`,\r\n      );\r\n    }\r\n\r\n    // Try to find intersection point\r\n    let intersection: Point | null = null;\r\n\r\n    if (\r\n      seg.type === \"line\" && nextSeg.type === \"line\" && seg.lineFit &&\r\n      nextSeg.lineFit\r\n    ) {\r\n      intersection = lineLineIntersection(seg.lineFit, nextSeg.lineFit);\r\n    } else if (\r\n      seg.type === \"line\" && nextSeg.type === \"arc\" && seg.lineFit &&\r\n      nextSeg.circleFit\r\n    ) {\r\n      const intersections = lineCircleIntersection(\r\n        seg.lineFit,\r\n        nextSeg.circleFit,\r\n      );\r\n      const gapMidpoint = points[seg.endIndex];\r\n      intersection = closestIntersection(intersections, gapMidpoint);\r\n    } else if (\r\n      seg.type === \"arc\" && nextSeg.type === \"line\" && seg.circleFit &&\r\n      nextSeg.lineFit\r\n    ) {\r\n      const intersections = lineCircleIntersection(\r\n        nextSeg.lineFit,\r\n        seg.circleFit,\r\n      );\r\n      const gapMidpoint = points[seg.endIndex];\r\n      intersection = closestIntersection(intersections, gapMidpoint);\r\n    } else if (\r\n      seg.type === \"arc\" && nextSeg.type === \"arc\" && seg.circleFit &&\r\n      nextSeg.circleFit\r\n    ) {\r\n      const intersections = circleCircleIntersection(\r\n        seg.circleFit,\r\n        nextSeg.circleFit,\r\n      );\r\n      const gapMidpoint = points[seg.endIndex];\r\n      intersection = closestIntersection(intersections, gapMidpoint);\r\n    }\r\n\r\n    if (intersection) {\r\n      console.log(\r\n        `[Refine connections] Found intersection at (${\r\n          intersection.x.toFixed(1)\r\n        }, ${intersection.y.toFixed(1)})`,\r\n      );\r\n\r\n      // Test if extending both segments to the intersection improves fit\r\n      const segPoints = extractSegmentPoints(points, seg, isClosed);\r\n      const nextSegPoints = extractSegmentPoints(points, nextSeg, isClosed);\r\n\r\n      // Calculate error for extending seg to intersection\r\n      let segExtensionError = 0;\r\n      if (seg.type === \"line\" && seg.lineFit) {\r\n        const dx = intersection.x - seg.lineFit.centroid.x;\r\n        const dy = intersection.y - seg.lineFit.centroid.y;\r\n        const perpX = -seg.lineFit.direction.y;\r\n        const perpY = seg.lineFit.direction.x;\r\n        segExtensionError = Math.abs(dx * perpX + dy * perpY);\r\n      } else if (seg.type === \"arc\" && seg.circleFit) {\r\n        const dx = intersection.x - seg.circleFit.center.x;\r\n        const dy = intersection.y - seg.circleFit.center.y;\r\n        const distToCenter = Math.sqrt(dx * dx + dy * dy);\r\n        segExtensionError = Math.abs(distToCenter - seg.circleFit.radius);\r\n      }\r\n\r\n      // Calculate error for extending nextSeg to intersection\r\n      let nextSegExtensionError = 0;\r\n      if (nextSeg.type === \"line\" && nextSeg.lineFit) {\r\n        const dx = intersection.x - nextSeg.lineFit.centroid.x;\r\n        const dy = intersection.y - nextSeg.lineFit.centroid.y;\r\n        const perpX = -nextSeg.lineFit.direction.y;\r\n        const perpY = nextSeg.lineFit.direction.x;\r\n        nextSegExtensionError = Math.abs(dx * perpX + dy * perpY);\r\n      } else if (nextSeg.type === \"arc\" && nextSeg.circleFit) {\r\n        const dx = intersection.x - nextSeg.circleFit.center.x;\r\n        const dy = intersection.y - nextSeg.circleFit.center.y;\r\n        const distToCenter = Math.sqrt(dx * dx + dy * dy);\r\n        nextSegExtensionError = Math.abs(\r\n          distToCenter - nextSeg.circleFit.radius,\r\n        );\r\n      }\r\n\r\n      const maxExtensionError = Math.max(\r\n        segExtensionError,\r\n        nextSegExtensionError,\r\n      );\r\n      console.log(\r\n        `[Refine connections] Extension errors: seg=${\r\n          segExtensionError.toFixed(3)\r\n        }px, nextSeg=${nextSegExtensionError.toFixed(3)}px, max=${\r\n          maxExtensionError.toFixed(3)\r\n        }px`,\r\n      );\r\n\r\n      // If extension error is acceptable, use intersection\r\n      if (maxExtensionError <= MAX_EXTENSION_ERROR) {\r\n        console.log(`[Refine connections] Using intersection (good fit)`);\r\n        // Update current segment to use intersection as projected end\r\n        seg.projectedEnd = intersection;\r\n        result[result.length - 1] = seg;\r\n\r\n        // Update next segment to use intersection as projected start\r\n        nextSeg.projectedStart = intersection;\r\n        // For wrap-around, also update result[0] since we already pushed it\r\n        if (isLastSegment && isClosed) {\r\n          result[0] = nextSeg;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Extension error is too high - try adding a bridge segment with expanded fit\r\n      if (gapSize >= MIN_BRIDGE_SIZE) {\r\n        console.log(\r\n          `[Refine connections] Extension error too high, trying expanded bridge for ${gapSize} gap points`,\r\n        );\r\n\r\n        const bridgeStartIdx = seg.endIndex + 1;\r\n        const bridgeEndIdx = nextSeg.startIndex - 1;\r\n\r\n        // Expand to include surrounding pixels from adjacent segments for better fit\r\n        const EXPAND_SIZE = Math.min(\r\n          5,\r\n          Math.floor((seg.endIndex - seg.startIndex) / 3),\r\n        );\r\n        const expandedStartIdx = Math.max(\r\n          seg.startIndex,\r\n          seg.endIndex - EXPAND_SIZE + 1,\r\n        );\r\n        const expandedEndIdx = Math.min(\r\n          nextSeg.endIndex,\r\n          nextSeg.startIndex + EXPAND_SIZE - 1,\r\n        );\r\n\r\n        console.log(\r\n          `[Refine connections] Expanded range: [${expandedStartIdx}-${expandedEndIdx}] (${\r\n            expandedEndIdx - expandedStartIdx + 1\r\n          } points including ${gapSize} gap points)`,\r\n        );\r\n\r\n        // Fit line and arc to the expanded range\r\n        const expandedLineFit = new IncrementalLineFit();\r\n        const expandedCircleFit = new IncrementalCircleFit();\r\n\r\n        for (let j = expandedStartIdx; j <= expandedEndIdx; j++) {\r\n          expandedLineFit.addPoint(points[j]);\r\n          expandedCircleFit.addPoint(points[j]);\r\n        }\r\n\r\n        // Calculate errors for the gap points only\r\n        const expandedLineErrors: number[] = [];\r\n        const expandedCircleErrors: number[] = [];\r\n        for (let j = bridgeStartIdx; j <= bridgeEndIdx; j++) {\r\n          expandedLineErrors.push(expandedLineFit.distanceToPoint(points[j]));\r\n          expandedCircleErrors.push(\r\n            expandedCircleFit.distanceToPoint(points[j]),\r\n          );\r\n        }\r\n\r\n        const lineError = percentile(expandedLineErrors, 0.5);\r\n        const circleFitResult = expandedCircleFit.getFit();\r\n        const circleError = circleFitResult.valid\r\n          ? percentile(expandedCircleErrors, 0.5)\r\n          : Infinity;\r\n\r\n        console.log(\r\n          `[Refine connections] Expanded fit errors: line=${\r\n            lineError.toFixed(3)\r\n          }px, circle=${circleError.toFixed(3)}px`,\r\n        );\r\n\r\n        // Check if the expanded fit is acceptable\r\n        if (lineError <= MAX_ERROR || circleError <= MAX_ERROR) {\r\n          // Try intersecting expanded bridge with neighbors\r\n          const useLine = lineError <= circleError;\r\n          const bridgeLineFit = useLine ? expandedLineFit.getFit() : null;\r\n          const bridgeCircleFit = !useLine && circleFitResult.valid\r\n            ? {\r\n              center: circleFitResult.center,\r\n              radius: circleFitResult.radius,\r\n            }\r\n            : null;\r\n\r\n          // Try intersection with seg\r\n          let bridgeStartPoint: Point | null = null;\r\n          if (seg.type === \"line\" && bridgeLineFit && seg.lineFit) {\r\n            bridgeStartPoint = lineLineIntersection(seg.lineFit, bridgeLineFit);\r\n          } else if (seg.type === \"line\" && bridgeCircleFit && seg.lineFit) {\r\n            const intersections = lineCircleIntersection(\r\n              seg.lineFit,\r\n              bridgeCircleFit,\r\n            );\r\n            bridgeStartPoint = closestIntersection(\r\n              intersections,\r\n              points[seg.endIndex],\r\n            );\r\n          } else if (seg.type === \"arc\" && bridgeLineFit && seg.circleFit) {\r\n            const intersections = lineCircleIntersection(\r\n              bridgeLineFit,\r\n              seg.circleFit,\r\n            );\r\n            bridgeStartPoint = closestIntersection(\r\n              intersections,\r\n              points[seg.endIndex],\r\n            );\r\n          } else if (\r\n            seg.type === \"arc\" && bridgeCircleFit && seg.circleFit\r\n          ) {\r\n            const intersections = circleCircleIntersection(\r\n              seg.circleFit,\r\n              bridgeCircleFit,\r\n            );\r\n            bridgeStartPoint = closestIntersection(\r\n              intersections,\r\n              points[seg.endIndex],\r\n            );\r\n          }\r\n\r\n          // Try intersection with nextSeg\r\n          let bridgeEndPoint: Point | null = null;\r\n          if (nextSeg.type === \"line\" && bridgeLineFit && nextSeg.lineFit) {\r\n            bridgeEndPoint = lineLineIntersection(\r\n              bridgeLineFit,\r\n              nextSeg.lineFit,\r\n            );\r\n          } else if (\r\n            nextSeg.type === \"line\" && bridgeCircleFit && nextSeg.lineFit\r\n          ) {\r\n            const intersections = lineCircleIntersection(\r\n              nextSeg.lineFit,\r\n              bridgeCircleFit,\r\n            );\r\n            bridgeEndPoint = closestIntersection(\r\n              intersections,\r\n              points[nextSeg.startIndex],\r\n            );\r\n          } else if (\r\n            nextSeg.type === \"arc\" && bridgeLineFit && nextSeg.circleFit\r\n          ) {\r\n            const intersections = lineCircleIntersection(\r\n              bridgeLineFit,\r\n              nextSeg.circleFit,\r\n            );\r\n            bridgeEndPoint = closestIntersection(\r\n              intersections,\r\n              points[nextSeg.startIndex],\r\n            );\r\n          } else if (\r\n            nextSeg.type === \"arc\" && bridgeCircleFit && nextSeg.circleFit\r\n          ) {\r\n            const intersections = circleCircleIntersection(\r\n              bridgeCircleFit,\r\n              nextSeg.circleFit,\r\n            );\r\n            bridgeEndPoint = closestIntersection(\r\n              intersections,\r\n              points[nextSeg.startIndex],\r\n            );\r\n          }\r\n\r\n          // If we found good intersections, use them\r\n          if (bridgeStartPoint && bridgeEndPoint) {\r\n            console.log(\r\n              `[Refine connections] Found bridge intersections: start=(${\r\n                bridgeStartPoint.x.toFixed(1)\r\n              }, ${bridgeStartPoint.y.toFixed(1)}), end=(${\r\n                bridgeEndPoint.x.toFixed(1)\r\n              }, ${bridgeEndPoint.y.toFixed(1)})`,\r\n            );\r\n\r\n            // Update segments with intersections\r\n            seg.projectedEnd = bridgeStartPoint;\r\n            result[result.length - 1] = seg;\r\n\r\n            // Add bridge segment with intersection endpoints\r\n            const bridgeSeg: Segment = {\r\n              startIndex: bridgeStartIdx,\r\n              endIndex: bridgeEndIdx,\r\n              type: useLine ? \"line\" : \"arc\",\r\n              projectedStart: bridgeStartPoint,\r\n              projectedEnd: bridgeEndPoint,\r\n            };\r\n\r\n            if (useLine) {\r\n              bridgeSeg.lineFit = {\r\n                ...bridgeLineFit!,\r\n                error: lineError,\r\n              };\r\n            } else {\r\n              bridgeSeg.circleFit = {\r\n                center: circleFitResult.center,\r\n                radius: circleFitResult.radius,\r\n                error: circleError,\r\n                sweepAngle: 0,\r\n                clockwise: false,\r\n              };\r\n            }\r\n\r\n            result.push(bridgeSeg);\r\n\r\n            // Update next segment\r\n            nextSeg.projectedStart = bridgeEndPoint;\r\n            if (isLastSegment && isClosed) {\r\n              result[0] = nextSeg;\r\n            }\r\n\r\n            console.log(\r\n              `[Refine connections] Added expanded bridge [${bridgeStartIdx}-${bridgeEndIdx}] with intersections`,\r\n            );\r\n            continue;\r\n          } else {\r\n            console.log(\r\n              `[Refine connections] Could not find valid intersections for bridge, leaving as gap`,\r\n            );\r\n          }\r\n        } else {\r\n          console.log(\r\n            `[Refine connections] Expanded bridge fit too poor (line=${\r\n              lineError.toFixed(3)\r\n            }px, circle=${circleError.toFixed(3)}px), leaving as gap`,\r\n          );\r\n        }\r\n      } else {\r\n        console.log(\r\n          `[Refine connections] Gap too small (${gapSize} < ${MIN_BRIDGE_SIZE}), leaving unfitted`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Fit additional segments to unfit pixels (boundary gaps and interior gaps)\r\n * Handles gaps at start/end of open paths and gaps between segments\r\n */\r\nfunction fitBoundaryGaps(\r\n  points: Point[],\r\n  segments: Segment[],\r\n  isClosed: boolean,\r\n): Segment[] {\r\n  if (segments.length === 0) return segments;\r\n\r\n  const N = points.length;\r\n  const MIN_GAP_SIZE = 3; // minimum unfit pixels to attempt fitting\r\n  const MIN_FIT_SIZE = 3; // minimum segment size (allow shorter than first pass)\r\n\r\n  const result: Segment[] = [];\r\n\r\n  // For open paths: check for gap at start (points 0 to first segment start)\r\n  if (!isClosed) {\r\n    const firstSeg = segments[0];\r\n    const startGapSize = firstSeg.startIndex;\r\n\r\n    if (startGapSize > 0) {\r\n      console.log(\r\n        `[Fit boundary gap] Start gap: ${startGapSize} points (0-${\r\n          firstSeg.startIndex - 1\r\n        })`,\r\n      );\r\n\r\n      // If gap is too small to fit (< MIN_FIT_SIZE), just add as unfitted polyline\r\n      if (startGapSize < MIN_FIT_SIZE) {\r\n        console.log(\r\n          `[Fit boundary gap] Start gap too small to fit, marking as unfitted polyline [0-${\r\n            firstSeg.startIndex - 1\r\n          }]`,\r\n        );\r\n        result.push({\r\n          startIndex: 0,\r\n          endIndex: firstSeg.startIndex - 1,\r\n          type: \"polyline\",\r\n        });\r\n      } else {\r\n        // Try fitting a segment to these points\r\n        // Start from the gap and try to grow it\r\n        let bestSeg: Segment | null = null;\r\n        let bestError = Infinity;\r\n\r\n        // Try different end points (at least MIN_FIT_SIZE points)\r\n        for (let endIdx = MIN_FIT_SIZE - 1; endIdx < startGapSize; endIdx++) {\r\n          const lineFit = new IncrementalLineFit();\r\n          const circleFit = new IncrementalCircleFit();\r\n\r\n          // Add all points from 0 to endIdx\r\n          for (let i = 0; i <= endIdx; i++) {\r\n            lineFit.addPoint(points[i]);\r\n            circleFit.addPoint(points[i]);\r\n          }\r\n\r\n          // Calculate errors manually\r\n          const lineErrors: number[] = [];\r\n          const circleErrors: number[] = [];\r\n          for (let i = 0; i <= endIdx; i++) {\r\n            lineErrors.push(lineFit.distanceToPoint(points[i]));\r\n            circleErrors.push(circleFit.distanceToPoint(points[i]));\r\n          }\r\n\r\n          const lineError = percentile(lineErrors, 0.5);\r\n          const circleFitResult = circleFit.getFit();\r\n          const circleError = circleFitResult.valid\r\n            ? percentile(circleErrors, 0.5)\r\n            : Infinity;\r\n          const error = Math.min(lineError, circleError);\r\n\r\n          console.log(\r\n            `[Fit boundary gap] Trying start [0-${endIdx}] (${\r\n              endIdx + 1\r\n            } points): lineError=${lineError.toFixed(3)}px, circleError=${\r\n              circleError.toFixed(3)\r\n            }px, best=${error.toFixed(3)}px`,\r\n          );\r\n\r\n          // Accept if it's a reasonable fit - prefer longer segments that still fit well\r\n          if (error <= MAX_ERROR) {\r\n            bestError = error;\r\n            bestSeg = {\r\n              startIndex: 0,\r\n              endIndex: endIdx,\r\n              type: \"line\", // will be classified later\r\n            };\r\n          }\r\n        }\r\n\r\n        if (bestSeg) {\r\n          console.log(\r\n            `[Fit boundary gap] Added start segment [0-${bestSeg.endIndex}] (error ${\r\n              bestError.toFixed(3)\r\n            }px)`,\r\n          );\r\n          result.push(bestSeg);\r\n        } else {\r\n          // Couldn't fit well, add entire gap as polyline\r\n          console.log(\r\n            `[Fit boundary gap] Could not fit start gap, marking as unfitted polyline [0-${\r\n              firstSeg.startIndex - 1\r\n            }]`,\r\n          );\r\n          result.push({\r\n            startIndex: 0,\r\n            endIndex: firstSeg.startIndex - 1,\r\n            type: \"polyline\",\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add all existing segments and check for interior gaps\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const seg = segments[i];\r\n\r\n    // Check for gap before this segment\r\n    const expectedStart = result.length > 0\r\n      ? result[result.length - 1].endIndex + 1\r\n      : 0;\r\n    const gapSize = seg.startIndex - expectedStart;\r\n\r\n    if (gapSize > 0) {\r\n      console.log(\r\n        `[Fit boundary gap] Interior gap: ${gapSize} points (${expectedStart}-${\r\n          seg.startIndex - 1\r\n        })`,\r\n      );\r\n\r\n      // If gap is too small to fit (< MIN_FIT_SIZE), just add as unfitted polyline\r\n      if (gapSize < MIN_FIT_SIZE) {\r\n        console.log(\r\n          `[Fit boundary gap] Gap too small to fit, marking as unfitted polyline [${expectedStart}-${\r\n            seg.startIndex - 1\r\n          }]`,\r\n        );\r\n        result.push({\r\n          startIndex: expectedStart,\r\n          endIndex: seg.startIndex - 1,\r\n          type: \"polyline\",\r\n        });\r\n      } else {\r\n        // Try fitting a segment to these points\r\n        let bestGapSeg: Segment | null = null;\r\n        let bestError = Infinity;\r\n\r\n        // Try different segment boundaries (at least MIN_FIT_SIZE points)\r\n        for (\r\n          let endIdx = expectedStart + MIN_FIT_SIZE - 1;\r\n          endIdx < seg.startIndex;\r\n          endIdx++\r\n        ) {\r\n          for (\r\n            let startIdx = expectedStart;\r\n            startIdx <= endIdx - MIN_FIT_SIZE + 1;\r\n            startIdx++\r\n          ) {\r\n            const lineFit = new IncrementalLineFit();\r\n            const circleFit = new IncrementalCircleFit();\r\n\r\n            // Add all points from startIdx to endIdx\r\n            for (let j = startIdx; j <= endIdx; j++) {\r\n              lineFit.addPoint(points[j]);\r\n              circleFit.addPoint(points[j]);\r\n            }\r\n\r\n            // Calculate errors manually\r\n            const lineErrors: number[] = [];\r\n            const circleErrors: number[] = [];\r\n            for (let j = startIdx; j <= endIdx; j++) {\r\n              lineErrors.push(lineFit.distanceToPoint(points[j]));\r\n              circleErrors.push(circleFit.distanceToPoint(points[j]));\r\n            }\r\n\r\n            const lineError = percentile(lineErrors, 0.5);\r\n            const circleFitResult = circleFit.getFit();\r\n            const circleError = circleFitResult.valid\r\n              ? percentile(circleErrors, 0.5)\r\n              : Infinity;\r\n            const error = Math.min(lineError, circleError);\r\n\r\n            // Accept if it's a reasonable fit - prefer longer segments that still fit well\r\n            if (error <= MAX_ERROR) {\r\n              bestError = error;\r\n              bestGapSeg = {\r\n                startIndex: startIdx,\r\n                endIndex: endIdx,\r\n                type: \"line\", // will be classified later\r\n              };\r\n            }\r\n          }\r\n        }\r\n\r\n        if (bestGapSeg) {\r\n          console.log(\r\n            `[Fit boundary gap] Added interior segment [${bestGapSeg.startIndex}-${bestGapSeg.endIndex}] (error ${\r\n              bestError.toFixed(3)\r\n            }px)`,\r\n          );\r\n          result.push(bestGapSeg);\r\n        } else {\r\n          // Mark gap as unfitted polyline\r\n          console.log(\r\n            `[Fit boundary gap] Marking interior gap as unfitted polyline [${expectedStart}-${\r\n              seg.startIndex - 1\r\n            }]`,\r\n          );\r\n          result.push({\r\n            startIndex: expectedStart,\r\n            endIndex: seg.startIndex - 1,\r\n            type: \"polyline\",\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    result.push(seg);\r\n  }\r\n\r\n  // For open paths: check for gap at end (last segment end to N-1)\r\n  if (!isClosed) {\r\n    const lastResultSeg = result[result.length - 1];\r\n    const endGapSize = N - 1 - lastResultSeg.endIndex;\r\n\r\n    if (endGapSize > 0) {\r\n      console.log(\r\n        `[Fit boundary gap] End gap: ${endGapSize} points (${\r\n          lastResultSeg.endIndex + 1\r\n        }-${N - 1})`,\r\n      );\r\n\r\n      // If gap is too small to fit (< MIN_FIT_SIZE), just add as unfitted polyline\r\n      if (endGapSize < MIN_FIT_SIZE) {\r\n        console.log(\r\n          `[Fit boundary gap] End gap too small to fit, marking as unfitted polyline [${\r\n            lastResultSeg.endIndex + 1\r\n          }-${N - 1}]`,\r\n        );\r\n        result.push({\r\n          startIndex: lastResultSeg.endIndex + 1,\r\n          endIndex: N - 1,\r\n          type: \"polyline\",\r\n        });\r\n      } else {\r\n        // Try fitting a segment to these points\r\n        let bestSeg: Segment | null = null;\r\n        let bestError = Infinity;\r\n\r\n        // Try different start points (at least MIN_FIT_SIZE points)\r\n        for (\r\n          let startIdx = N - MIN_FIT_SIZE;\r\n          startIdx > lastResultSeg.endIndex;\r\n          startIdx--\r\n        ) {\r\n          const lineFit = new IncrementalLineFit();\r\n          const circleFit = new IncrementalCircleFit();\r\n\r\n          // Add all points from startIdx to N-1\r\n          for (let i = startIdx; i < N; i++) {\r\n            lineFit.addPoint(points[i]);\r\n            circleFit.addPoint(points[i]);\r\n          }\r\n\r\n          // Calculate errors manually\r\n          const lineErrors: number[] = [];\r\n          const circleErrors: number[] = [];\r\n          for (let i = startIdx; i < N; i++) {\r\n            lineErrors.push(lineFit.distanceToPoint(points[i]));\r\n            circleErrors.push(circleFit.distanceToPoint(points[i]));\r\n          }\r\n\r\n          const lineError = percentile(lineErrors, 0.5);\r\n          const circleFitResult = circleFit.getFit();\r\n          const circleError = circleFitResult.valid\r\n            ? percentile(circleErrors, 0.5)\r\n            : Infinity;\r\n          const error = Math.min(lineError, circleError);\r\n\r\n          // Accept if it's a reasonable fit - prefer longer segments that still fit well\r\n          if (error <= MAX_ERROR) {\r\n            bestError = error;\r\n            bestSeg = {\r\n              startIndex: startIdx,\r\n              endIndex: N - 1,\r\n              type: \"line\", // will be classified later\r\n            };\r\n          }\r\n        }\r\n\r\n        if (bestSeg) {\r\n          console.log(\r\n            `[Fit boundary gap] Added end segment [${bestSeg.startIndex}-${\r\n              N - 1\r\n            }] (error ${bestError.toFixed(3)}px)`,\r\n          );\r\n          result.push(bestSeg);\r\n        } else {\r\n          // Couldn't fit well, add entire gap as polyline\r\n          console.log(\r\n            `[Fit boundary gap] Could not fit end gap, marking as unfitted polyline [${\r\n              lastResultSeg.endIndex + 1\r\n            }-${N - 1}]`,\r\n          );\r\n          result.push({\r\n            startIndex: lastResultSeg.endIndex + 1,\r\n            endIndex: N - 1,\r\n            type: \"polyline\",\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Main entry point: segment and classify a path\r\n */\r\nexport function vectorizeWithIncrementalSegmentation(\r\n  points: Point[],\r\n  isClosed: boolean,\r\n): Segment[] {\r\n  console.log(\r\n    `\\n=== Vectorizing path: ${points.length} points, ${\r\n      isClosed ? \"closed\" : \"open\"\r\n    } ===`,\r\n  );\r\n\r\n  const segments = segmentPath(points, isClosed);\r\n  console.log(`  After segmentPath: ${segments.length} segments`);\r\n  segments.forEach((s, i) =>\r\n    console.log(`    Seg ${i}: [${s.startIndex}-${s.endIndex}]`)\r\n  );\r\n\r\n  const classified = classifySegments(points, segments, isClosed);\r\n  console.log(`  After classification: ${classified.length} segments`);\r\n  classified.forEach((s, i) =>\r\n    console.log(\r\n      `    Seg ${i}: [${s.startIndex}-${s.endIndex}] type=${s.type}`,\r\n    )\r\n  );\r\n\r\n  const refined = refineSegmentBoundaries(points, classified, isClosed);\r\n  console.log(`  After refinement: ${refined.length} segments`);\r\n  refined.forEach((s, i) =>\r\n    console.log(\r\n      `    Seg ${i}: [${s.startIndex}-${s.endIndex}] type=${s.type}`,\r\n    )\r\n  );\r\n\r\n  const withBoundaryFits = fitBoundaryGaps(points, refined, isClosed);\r\n  console.log(\r\n    `  After boundary gap fitting: ${withBoundaryFits.length} segments`,\r\n  );\r\n  withBoundaryFits.forEach((s, i) =>\r\n    console.log(\r\n      `    Seg ${i}: [${s.startIndex}-${s.endIndex}] type=${s.type}`,\r\n    )\r\n  );\r\n\r\n  const classified2 = classifySegments(points, withBoundaryFits, isClosed);\r\n  console.log(`  After gap classification: ${classified2.length} segments`);\r\n  classified2.forEach((s, i) =>\r\n    console.log(\r\n      `    Seg ${i}: [${s.startIndex}-${s.endIndex}] type=${s.type}`,\r\n    )\r\n  );\r\n\r\n  const connected = refineSegmentConnections(points, classified2, isClosed);\r\n  console.log(`  After connection refinement: ${connected.length} segments`);\r\n  connected.forEach((s, i) =>\r\n    console.log(\r\n      `    Seg ${i}: [${s.startIndex}-${s.endIndex}] type=${s.type}`,\r\n    )\r\n  );\r\n\r\n  // Note: We don't re-classify after connection refinement because it would\r\n  // recalculate projectedStart/projectedEnd and erase our intersection points\r\n  // The segments are already classified and just have updated projected endpoints\r\n  console.log(`  Final: ${connected.length} segments`);\r\n  connected.forEach((s, i) =>\r\n    console.log(\r\n      `    Seg ${i}: [${s.startIndex}-${s.endIndex}] type=${s.type}`,\r\n    )\r\n  );\r\n\r\n  return connected;\r\n}\r\n", "/**\r\n * Vectorization module - converts skeletonized binary images to vector paths\r\n */\r\n\r\nimport type { BinaryImage } from \"../src/formats/binary.ts\";\r\nimport { vectorizeWithIncrementalSegmentation } from \"./incremental_segmentation.ts\";\r\nimport type { Segment } from \"./incremental_segmentation.ts\";\r\n\r\nexport interface Vertex {\r\n  x: number;\r\n  y: number;\r\n  id: number; // Only used during tracing\r\n  neighbors: number[]; // Only used during tracing\r\n}\r\n\r\nexport interface VectorPath {\r\n  vertices: number[]; // Vertex IDs during tracing\r\n  closed: boolean;\r\n}\r\n\r\nexport interface Circle {\r\n  cx: number;\r\n  cy: number;\r\n  radius: number;\r\n}\r\n\r\nexport interface SimplifiedPath {\r\n  points: Array<{ x: number; y: number }>; // Just coordinates after simplification\r\n  closed: boolean;\r\n  circle?: Circle; // If this path represents a circle\r\n  segments?: Segment[]; // Segment information for rendering arcs\r\n}\r\n\r\nexport interface VectorizedImage {\r\n  width: number;\r\n  height: number;\r\n  paths: SimplifiedPath[]; // Use SimplifiedPath after vectorization\r\n}\r\n\r\n/**\r\n * Convert a skeletonized binary image to vertices and connected paths\r\n * Single-pass algorithm that traces complete paths\r\n */\r\nexport function vectorizeSkeleton(binary: BinaryImage): VectorizedImage {\r\n  const { width, height } = binary;\r\n\r\n  // Helper to get vertex ID from coordinates\r\n  const getVertexId = (x: number, y: number) => y * width + x;\r\n\r\n  const paths: VectorPath[] = [];\r\n  const visited = new Set<number>();\r\n  const vertices = new Map<number, Vertex>();\r\n\r\n  // Helper to get unvisited neighbors (cardinal first, then diagonal)\r\n  const getUnvisitedNeighbors = (\r\n    x: number,\r\n    y: number,\r\n  ): Array<[number, number]> => {\r\n    const neighbors: Array<[number, number]> = [];\r\n\r\n    // Cardinal directions first\r\n    const cardinalOffsets: Array<[number, number]> = [[0, -1], [1, 0], [0, 1], [\r\n      -1,\r\n      0,\r\n    ]];\r\n    for (const [dx, dy] of cardinalOffsets) {\r\n      const nx = x + dx;\r\n      const ny = y + dy;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        const nId = getVertexId(nx, ny);\r\n        if (isPixelSet(binary, nx, ny) && !visited.has(nId)) {\r\n          neighbors.push([nx, ny]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Then diagonals (only if no stair-step path exists)\r\n    const diagonalOffsets: Array<[number, number]> = [[-1, -1], [1, -1], [\r\n      -1,\r\n      1,\r\n    ], [1, 1]];\r\n    for (const [dx, dy] of diagonalOffsets) {\r\n      const nx = x + dx;\r\n      const ny = y + dy;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        const nId = getVertexId(nx, ny);\r\n        if (isPixelSet(binary, nx, ny) && !visited.has(nId)) {\r\n          // Check if there's a stair-step path to this diagonal\r\n          const hasStairStep = cardinalOffsets.some(([cdx, cdy]) => {\r\n            const cx = x + cdx;\r\n            const cy = y + cdy;\r\n            if (\r\n              cx >= 0 && cx < width && cy >= 0 && cy < height &&\r\n              isPixelSet(binary, cx, cy)\r\n            ) {\r\n              const dcx = nx - cx;\r\n              const dcy = ny - cy;\r\n              return Math.abs(dcx) + Math.abs(dcy) === 1;\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (!hasStairStep) {\r\n            neighbors.push([nx, ny]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return neighbors;\r\n  };\r\n\r\n  // Helper to extend path in one direction\r\n  const extendPath = (pathVertices: number[], forward: boolean): void => {\r\n    while (true) {\r\n      const currentId = forward\r\n        ? pathVertices[pathVertices.length - 1]\r\n        : pathVertices[0];\r\n      const currentVertex = vertices.get(currentId);\r\n      if (!currentVertex) break;\r\n\r\n      const neighbors = getUnvisitedNeighbors(currentVertex.x, currentVertex.y);\r\n\r\n      // Stop if no neighbors\r\n      if (neighbors.length === 0) break;\r\n\r\n      // Always continue into the first available neighbor\r\n      // (even at junctions - this ensures paths connect through junction points)\r\n      const [nx, ny] = neighbors[0];\r\n      const nextId = getVertexId(nx, ny);\r\n\r\n      // Add vertex to map if not already there\r\n      if (!vertices.has(nextId)) {\r\n        vertices.set(nextId, { x: nx, y: ny, id: nextId, neighbors: [] });\r\n      }\r\n\r\n      visited.add(nextId);\r\n\r\n      if (forward) {\r\n        pathVertices.push(nextId);\r\n      } else {\r\n        pathVertices.unshift(nextId);\r\n      }\r\n\r\n      // After adding the next pixel, if IT has multiple unvisited neighbors, stop\r\n      // (it's a junction and will be the start point for other paths)\r\n      const nextNeighbors = getUnvisitedNeighbors(nx, ny);\r\n      if (nextNeighbors.length > 1) break;\r\n    }\r\n  };\r\n\r\n  // Iterate through all pixels to find paths\r\n  // Optimize by checking entire bytes at once\r\n  let totalPixels = 0;\r\n\r\n  for (let byteIdx = 0; byteIdx < binary.data.length; byteIdx++) {\r\n    const byte = binary.data[byteIdx];\r\n    if (byte === 0) continue; // Skip empty bytes\r\n\r\n    // Check each bit in this byte\r\n    const startPixelIdx = byteIdx * 8;\r\n    for (let bitIdx = 0; bitIdx < 8; bitIdx++) {\r\n      if ((byte & (1 << (7 - bitIdx))) === 0) continue;\r\n\r\n      const pixelIdx = startPixelIdx + bitIdx;\r\n      const x = pixelIdx % width;\r\n      const y = Math.floor(pixelIdx / width);\r\n\r\n      if (y >= height) break; // Past end of image\r\n\r\n      totalPixels++;\r\n      const id = getVertexId(x, y);\r\n      if (visited.has(id)) continue;\r\n\r\n      // Start a new path\r\n      const pathVertices: number[] = [id];\r\n      visited.add(id);\r\n\r\n      // Add vertex to map if not already there\r\n      if (!vertices.has(id)) {\r\n        vertices.set(id, { x, y, id, neighbors: [] });\r\n      }\r\n\r\n      // Extend in both directions\r\n      extendPath(pathVertices, true); // Extend forward\r\n      extendPath(pathVertices, false); // Extend backward\r\n\r\n      // Add all paths, even single pixels (they're isolated points)\r\n      paths.push({\r\n        vertices: pathVertices,\r\n        closed: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  console.log(\r\n    `Vectorization: ${totalPixels} skeleton pixels, visited ${visited.size}, traced ${paths.length} paths`,\r\n  );\r\n\r\n  // Mark paths as closed if endpoints are within 1 pixel\r\n  for (const path of paths) {\r\n    if (path.vertices.length >= 3) {\r\n      const startV = vertices.get(path.vertices[0])!;\r\n      const endV = vertices.get(path.vertices[path.vertices.length - 1])!;\r\n      if (\r\n        Math.abs(startV.x - endV.x) <= 1 && Math.abs(startV.y - endV.y) <= 1\r\n      ) {\r\n        path.closed = true;\r\n        if (startV.x !== endV.x || startV.y !== endV.y) {\r\n          // If endpoints are different but close, connect them\r\n          path.vertices.push(path.vertices[0]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // DISABLED: Douglas-Peucker and Segmented Linear Regression\r\n  // // First, run a light Douglas-Peucker pass to simplify trivial cases (skip circles)\r\n  // const dpPaths = paths.map((path, i) =>\r\n  //   circleResults[i] ? path : douglasPeucker(path, vertices, 0.1)\r\n  // );\r\n  // const totalDPBefore = paths.reduce((sum, p) => sum + p.vertices.length, 0);\r\n  // const totalDPAfter = dpPaths.reduce((sum, p) => sum + p.vertices.length, 0);\r\n  // console.log(\r\n  //   `Vectorization: DP pass simplified from ${totalDPBefore} to ${totalDPAfter} vertices`,\r\n  // );\r\n  //\r\n  // // Apply segmented linear regression to simplify paths (skip circles)\r\n  // const simplifiedPaths = dpPaths.map((path, i) =>\r\n  //   circleResults[i]\r\n  //     ? path\r\n  //     : segmentedLinearRegression(path, vertices, width, 0.75)\r\n  // );\r\n  //\r\n  // const totalVerticesBefore = dpPaths.reduce(\r\n  //   (sum, p) => sum + p.vertices.length,\r\n  //   0,\r\n  // );\r\n  // const totalVerticesAfter = simplifiedPaths.reduce(\r\n  //   (sum, p) => sum + p.vertices.length,\r\n  //   0,\r\n  // );\r\n  // console.log(\r\n  //   `Vectorization: SLR simplified from ${totalVerticesBefore} to ${totalVerticesAfter} vertices (${\r\n  //     ((1 - totalVerticesAfter / totalVerticesBefore) * 100).toFixed(1)\r\n  //   }% reduction)`,\r\n  // );\r\n\r\n  // Apply incremental segmentation with line and arc fitting\r\n  const totalVerticesBefore = paths.reduce(\r\n    (sum, p) => sum + p.vertices.length,\r\n    0,\r\n  );\r\n\r\n  const segmentedPaths: Array<{ segments: Segment[]; closed: boolean }> = paths\r\n    .map((path) => {\r\n      const points = path.vertices.map((id) => {\r\n        const v = vertices.get(id);\r\n        return v ? { x: v.x, y: v.y } : { x: 0, y: 0 };\r\n      });\r\n      const segments = vectorizeWithIncrementalSegmentation(\r\n        points,\r\n        path.closed,\r\n      );\r\n      return { segments, closed: path.closed };\r\n    });\r\n\r\n  const totalSegments = segmentedPaths.reduce(\r\n    (sum, p) => sum + p.segments.length,\r\n    0,\r\n  );\r\n  const totalArcs = segmentedPaths.reduce(\r\n    (sum, p) => sum + p.segments.filter((s) => s.type === \"arc\").length,\r\n    0,\r\n  );\r\n  console.log(\r\n    `Vectorization: Incremental segmentation created ${totalSegments} segments (${totalArcs} arcs, ${\r\n      totalSegments - totalArcs\r\n    } lines) from ${totalVerticesBefore} vertices`,\r\n  );\r\n\r\n  // Convert segments back to SimplifiedPath format\r\n  const simplifiedPaths = segmentedPaths.map((pathData, pathIdx) => {\r\n    const originalPath = paths[pathIdx];\r\n    const resultVertices: number[] = [];\r\n\r\n    for (let i = 0; i < pathData.segments.length; i++) {\r\n      const seg = pathData.segments[i];\r\n      const points = originalPath.vertices.slice(\r\n        seg.startIndex,\r\n        seg.endIndex + 1,\r\n      );\r\n\r\n      // Add start point\r\n      if (resultVertices.length === 0) {\r\n        resultVertices.push(points[0]);\r\n      }\r\n\r\n      // For fitted segments (arc/line): just keep endpoints - data stores the fit parameters\r\n      // For unfitted segments (polyline): keep all skeleton pixels\r\n      if (seg.type === \"arc\" || seg.type === \"line\") {\r\n        resultVertices.push(points[points.length - 1]);\r\n      } else {\r\n        // Unfitted segment - keep all skeleton pixels\r\n        for (let k = 1; k < points.length; k++) {\r\n          resultVertices.push(points[k]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      vertices: resultVertices,\r\n      closed: originalPath.closed,\r\n    };\r\n  });\r\n\r\n  const totalVerticesAfter = simplifiedPaths.reduce(\r\n    (sum, p) => sum + p.vertices.length,\r\n    0,\r\n  );\r\n  console.log(\r\n    `Vectorization: Simplified to ${totalVerticesAfter} vertices (${\r\n      ((1 - totalVerticesAfter / totalVerticesBefore) * 100).toFixed(1)\r\n    }% reduction)`,\r\n  );\r\n\r\n  // Convert to SimplifiedPath (just coordinates, no IDs)\r\n  const finalPaths: SimplifiedPath[] = simplifiedPaths.map((path, i) => {\r\n    const pathSegments = segmentedPaths[i];\r\n    const originalPath = paths[i];\r\n\r\n    // DEBUG: Show original skeleton pixels\r\n    const originalSkeletonPoints = originalPath.vertices.map((id) => {\r\n      const v = vertices.get(id);\r\n      return v ? { x: v.x, y: v.y } : { x: 0, y: 0 };\r\n    });\r\n    console.log(`\\n=== PATH ${i} DEBUG ===`);\r\n    console.log(`Original skeleton: ${originalSkeletonPoints.length} pixels`);\r\n    console.log(\r\n      `  Points: ${\r\n        originalSkeletonPoints.slice(0, 10).map((p) => `(${p.x},${p.y})`).join(\r\n          \" \",\r\n        )\r\n      }${originalSkeletonPoints.length > 10 ? \"...\" : \"\"}`,\r\n    );\r\n\r\n    // Helper to extract segment points with wrap-around support\r\n    const extractSegmentPoints = (\r\n      startIdx: number,\r\n      endIdx: number,\r\n    ): Array<{ x: number; y: number }> => {\r\n      const result: Array<{ x: number; y: number }> = [];\r\n      if (endIdx >= startIdx) {\r\n        // Normal case\r\n        for (let i = startIdx; i <= endIdx; i++) {\r\n          result.push(originalSkeletonPoints[i]);\r\n        }\r\n      } else if (path.closed) {\r\n        // Wrap-around case for closed paths\r\n        for (let i = startIdx; i < originalSkeletonPoints.length; i++) {\r\n          result.push(originalSkeletonPoints[i]);\r\n        }\r\n        for (let i = 0; i <= endIdx; i++) {\r\n          result.push(originalSkeletonPoints[i]);\r\n        }\r\n      }\r\n      return result;\r\n    };\r\n\r\n    // DEBUG: Show segments from incremental segmentation\r\n    console.log(\r\n      `Segments from incremental segmentation: ${pathSegments.segments.length}`,\r\n    );\r\n    pathSegments.segments.forEach((seg, idx) => {\r\n      const segPoints = extractSegmentPoints(seg.startIndex, seg.endIndex);\r\n      console.log(\r\n        `  Seg ${idx}: [${seg.startIndex}-${seg.endIndex}] type=${seg.type}, ${segPoints.length} skeleton pixels`,\r\n      );\r\n      console.log(\r\n        `    Skeleton: ${segPoints.map((p) => `(${p.x},${p.y})`).join(\" \")}`,\r\n      );\r\n      if (seg.projectedStart) {\r\n        console.log(\r\n          `    Projected start: (${seg.projectedStart.x.toFixed(2)}, ${\r\n            seg.projectedStart.y.toFixed(2)\r\n          })`,\r\n        );\r\n      }\r\n      if (seg.projectedEnd) {\r\n        console.log(\r\n          `    Projected end: (${seg.projectedEnd.x.toFixed(2)}, ${\r\n            seg.projectedEnd.y.toFixed(2)\r\n          })`,\r\n        );\r\n      }\r\n    });\r\n\r\n    // Build points array from segment endpoints (projected or skeleton pixels)\r\n    const points: Array<{ x: number; y: number }> = [];\r\n    const adjustedSegments: Segment[] = [];\r\n\r\n    for (let segIdx = 0; segIdx < pathSegments.segments.length; segIdx++) {\r\n      const seg = pathSegments.segments[segIdx];\r\n\r\n      // Get skeleton points for this segment (with wrap-around support)\r\n      const skeletonPoints = extractSegmentPoints(seg.startIndex, seg.endIndex);\r\n\r\n      if (seg.type === \"arc\" || seg.type === \"line\") {\r\n        // Fitted segment: use projected endpoints if available\r\n        if (seg.projectedStart && seg.projectedEnd) {\r\n          let segmentStartIdx: number;\r\n\r\n          if (points.length === 0) {\r\n            // First segment: add both start and end\r\n            points.push(seg.projectedStart);\r\n            segmentStartIdx = 0;\r\n            points.push(seg.projectedEnd);\r\n          } else {\r\n            // Subsequent segments: check if start matches previous end\r\n            const lastPoint = points[points.length - 1];\r\n            const startMatches =\r\n              Math.abs(lastPoint.x - seg.projectedStart.x) < 0.01 &&\r\n              Math.abs(lastPoint.y - seg.projectedStart.y) < 0.01;\r\n\r\n            if (!startMatches) {\r\n              // Gap between segments - add the projected start\r\n              points.push(seg.projectedStart);\r\n              segmentStartIdx = points.length - 1;\r\n            } else {\r\n              // Start matches previous end - reuse that point\r\n              segmentStartIdx = points.length - 1;\r\n            }\r\n            points.push(seg.projectedEnd);\r\n          }\r\n\r\n          adjustedSegments.push({\r\n            ...seg,\r\n            startIndex: segmentStartIdx,\r\n            endIndex: points.length - 1,\r\n          });\r\n        } else {\r\n          // Fitted segment but no projected endpoints - fallback to skeleton pixels\r\n          let segmentStartIdx: number;\r\n\r\n          if (points.length === 0) {\r\n            segmentStartIdx = 0;\r\n            points.push(...skeletonPoints);\r\n          } else {\r\n            const lastPoint = points[points.length - 1];\r\n            const firstSkeletonPoint = skeletonPoints[0];\r\n            if (\r\n              lastPoint.x === firstSkeletonPoint.x &&\r\n              lastPoint.y === firstSkeletonPoint.y\r\n            ) {\r\n              segmentStartIdx = points.length - 1;\r\n              points.push(...skeletonPoints.slice(1));\r\n            } else {\r\n              segmentStartIdx = points.length;\r\n              points.push(...skeletonPoints);\r\n            }\r\n          }\r\n\r\n          adjustedSegments.push({\r\n            ...seg,\r\n            startIndex: segmentStartIdx,\r\n            endIndex: points.length - 1,\r\n          });\r\n        }\r\n      } else {\r\n        // Unfitted segment (polyline): use skeleton pixels\r\n        let segmentStartIdx: number;\r\n\r\n        if (points.length === 0) {\r\n          // First segment: add all skeleton points\r\n          segmentStartIdx = 0;\r\n          points.push(...skeletonPoints);\r\n        } else {\r\n          // Subsequent segments: skip first point if it matches the last point in the array\r\n          const lastPoint = points[points.length - 1];\r\n          const firstSkeletonPoint = skeletonPoints[0];\r\n          if (\r\n            lastPoint.x === firstSkeletonPoint.x &&\r\n            lastPoint.y === firstSkeletonPoint.y\r\n          ) {\r\n            segmentStartIdx = points.length - 1;\r\n            points.push(...skeletonPoints.slice(1));\r\n          } else {\r\n            segmentStartIdx = points.length;\r\n            points.push(...skeletonPoints);\r\n          }\r\n        }\r\n\r\n        adjustedSegments.push({\r\n          ...seg,\r\n          startIndex: segmentStartIdx,\r\n          endIndex: points.length - 1,\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log(`Final output points: ${points.length}`);\r\n    console.log(\r\n      `  Points: ${\r\n        points.slice(0, 10).map((p) => `(${p.x.toFixed(2)},${p.y.toFixed(2)})`)\r\n          .join(\" \")\r\n      }${points.length > 10 ? \"...\" : \"\"}`,\r\n    );\r\n    console.log(`Adjusted segments: ${adjustedSegments.length}`);\r\n    adjustedSegments.forEach((seg, idx) => {\r\n      const segPoints = points.slice(seg.startIndex, seg.endIndex + 1);\r\n      console.log(\r\n        `  Segment ${idx}: [${seg.startIndex}-${seg.endIndex}] type=${seg.type}, ${segPoints.length} points`,\r\n      );\r\n      console.log(\r\n        `    Output: ${\r\n          segPoints.map((p) => `(${p.x.toFixed(2)},${p.y.toFixed(2)})`).join(\r\n            \" \",\r\n          )\r\n        }`,\r\n      );\r\n    });\r\n\r\n    return {\r\n      points,\r\n      closed: path.closed,\r\n      segments: adjustedSegments,\r\n    };\r\n  });\r\n\r\n  return {\r\n    width,\r\n    height,\r\n    paths: finalPaths,\r\n  };\r\n}\r\n\r\n/**\r\n * Segmented Linear Regression with continuous weighting\r\n * Recursively fits lines to path segments, splitting at worst outliers\r\n * Exported for testing\r\n */\r\nexport function segmentedLinearRegression(\r\n  path: VectorPath,\r\n  vertices: Map<number, Vertex>,\r\n  width: number,\r\n  epsilon: number,\r\n): VectorPath {\r\n  if (path.vertices.length <= 2) {\r\n    return path;\r\n  }\r\n\r\n  let coords = path.vertices.map((id) => vertices.get(id)!);\r\n\r\n  // For closed paths, remove the duplicate endpoint before processing\r\n  let wasClosed = path.closed;\r\n  if (wasClosed && coords.length > 2) {\r\n    const first = coords[0];\r\n    const last = coords[coords.length - 1];\r\n    if (first.x === last.x && first.y === last.y) {\r\n      coords = coords.slice(0, -1); // Remove duplicate endpoint\r\n\r\n      // Reorder the path to start at the point furthest from the centroid\r\n      // This provides a better split point for the recursive algorithm\r\n      if (coords.length > 2) {\r\n        const cx = coords.reduce((sum, p) => sum + p.x, 0) / coords.length;\r\n        const cy = coords.reduce((sum, p) => sum + p.y, 0) / coords.length;\r\n\r\n        let maxDist = 0;\r\n        let maxDistIndex = 0;\r\n\r\n        for (let i = 0; i < coords.length; i++) {\r\n          const dx = coords[i].x - cx;\r\n          const dy = coords[i].y - cy;\r\n          const dist = dx * dx + dy * dy; // No need for sqrt, just comparing\r\n\r\n          if (dist > maxDist) {\r\n            maxDist = dist;\r\n            maxDistIndex = i;\r\n          }\r\n        }\r\n\r\n        // Rotate the array so the furthest point is first\r\n        coords = [\r\n          ...coords.slice(maxDistIndex),\r\n          ...coords.slice(0, maxDistIndex),\r\n        ];\r\n      }\r\n    }\r\n  }\r\n\r\n  const simplified = slrRecursive(coords, epsilon, width, wasClosed);\r\n\r\n  // Add any new projected vertices to the map\r\n  for (const vertex of simplified) {\r\n    if (!vertices.has(vertex.id)) {\r\n      vertices.set(vertex.id, vertex);\r\n    }\r\n  }\r\n\r\n  // For closed paths, add back the duplicate endpoint\r\n  const resultVertices = simplified.map((v) => v.id);\r\n  if (wasClosed && simplified.length > 0) {\r\n    resultVertices.push(simplified[0].id); // Close the path\r\n  }\r\n\r\n  return {\r\n    vertices: resultVertices,\r\n    closed: wasClosed,\r\n  };\r\n}\r\n\r\nfunction slrRecursive(\r\n  points: Vertex[],\r\n  epsilon: number,\r\n  width: number,\r\n  isClosed: boolean = false,\r\n): Vertex[] {\r\n  if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Fit a line to all segments using continuous weighting\r\n  const { direction, centroid, maxError } = fitLineToSegments(points);\r\n\r\n  if (maxError <= epsilon) {\r\n    // Good fit - project endpoints onto fitted line\r\n    const start = points[0];\r\n    const end = points[points.length - 1];\r\n\r\n    // Project onto line through centroid with given direction\r\n    const projStart = projectOntoLine(start, centroid, direction);\r\n    const projEnd = projectOntoLine(end, centroid, direction);\r\n\r\n    // debug output: show points, centroid, direction,\r\n    if (false) {\r\n      console.log(\r\n        `\\n=== SLR: Good fit (error ${maxError.toFixed(2)} <= ${epsilon}) ===`,\r\n      );\r\n      console.log(`Points: ${points.map((p) => `(${p.x},${p.y})`).join(\", \")}`);\r\n      console.log(\r\n        `Centroid: (${centroid.x.toFixed(2)}, ${centroid.y.toFixed(2)})`,\r\n      );\r\n      console.log(\r\n        `Direction: (${direction.x.toFixed(3)}, ${direction.y.toFixed(3)})`,\r\n      );\r\n      console.log(\r\n        `Projected start: (${projStart.x.toFixed(2)}, ${\r\n          projStart.y.toFixed(2)\r\n        })`,\r\n      );\r\n      console.log(\r\n        `Projected end: (${projEnd.x.toFixed(2)}, ${projEnd.y.toFixed(2)})`,\r\n      );\r\n    }\r\n\r\n    // Create new vertices for projected endpoints\r\n    const startId = projStart.y * width + projStart.x;\r\n    const endId = projEnd.y * width + projEnd.x;\r\n\r\n    return [\r\n      { ...projStart, id: startId, neighbors: [] },\r\n      { ...projEnd, id: endId, neighbors: [] },\r\n    ];\r\n  }\r\n\r\n  // Line doesn't fit well enough - split using DP method\r\n  // Find worst outlier from straight line between endpoints\r\n  const start = points[0];\r\n  const end = points[points.length - 1];\r\n\r\n  let maxDist = 0;\r\n  let maxDistIndex = 1;\r\n\r\n  // Calculate perpendicular distance from each interior point to line segment\r\n  const dx = end.x - start.x;\r\n  const dy = end.y - start.y;\r\n  const lineLen = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  if (lineLen < 1e-10) {\r\n    // Degenerate case: start and end are the same point\r\n    return [start, end];\r\n  }\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const p = points[i];\r\n    // Perpendicular distance from point to line\r\n    const dist = Math.abs(\r\n      (end.y - start.y) * p.x - (end.x - start.x) * p.y + end.x * start.y -\r\n        end.y * start.x,\r\n    ) / lineLen;\r\n\r\n    if (dist > maxDist) {\r\n      maxDist = dist;\r\n      maxDistIndex = i;\r\n    }\r\n  }\r\n\r\n  // Split at the worst outlier\r\n  const left = slrRecursive(\r\n    points.slice(0, maxDistIndex + 1),\r\n    epsilon,\r\n    width,\r\n    false,\r\n  );\r\n  const right = slrRecursive(points.slice(maxDistIndex), epsilon, width, false);\r\n\r\n  // Merge with intersection\r\n  if (left.length > 1 && right.length > 1) {\r\n    // Find intersection of the two line segments\r\n    const intersection = findLineIntersection(\r\n      left[left.length - 2],\r\n      left[left.length - 1],\r\n      right[0],\r\n      right[1],\r\n    );\r\n\r\n    if (intersection) {\r\n      const intId = intersection.y * width + intersection.x;\r\n      const intVertex = { ...intersection, id: intId, neighbors: [] };\r\n\r\n      return [\r\n        ...left.slice(0, -1),\r\n        intVertex,\r\n        ...right.slice(1),\r\n      ];\r\n    }\r\n  }\r\n\r\n  // Fallback: simple concatenation without duplicate middle point\r\n  return [...left.slice(0, -1), ...right];\r\n}\r\n\r\n/**\r\n * Fit a line to path segments using continuous weighting\r\n */\r\nexport function fitLineToSegments(points: Vertex[]): {\r\n  direction: { x: number; y: number };\r\n  centroid: { x: number; y: number };\r\n  maxError: number;\r\n  maxErrorIndex: number;\r\n} {\r\n  // Compute continuous centroid weighted by segment lengths\r\n  let totalLength = 0;\r\n  let weightedCx = 0;\r\n  let weightedCy = 0;\r\n\r\n  for (let i = 0; i < points.length - 1; i++) {\r\n    const A = points[i];\r\n    const B = points[i + 1];\r\n    const dx = B.x - A.x;\r\n    const dy = B.y - A.y;\r\n    const L = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    const segmentCentroid = {\r\n      x: (A.x + B.x) / 2,\r\n      y: (A.y + B.y) / 2,\r\n    };\r\n\r\n    totalLength += L;\r\n    weightedCx += L * segmentCentroid.x;\r\n    weightedCy += L * segmentCentroid.y;\r\n  }\r\n\r\n  const centroid = {\r\n    x: weightedCx / totalLength,\r\n    y: weightedCy / totalLength,\r\n  };\r\n\r\n  // Compute continuous second moment / covariance tensor\r\n  let covXX = 0;\r\n  let covXY = 0;\r\n  let covYY = 0;\r\n\r\n  for (let i = 0; i < points.length - 1; i++) {\r\n    const A = points[i];\r\n    const B = points[i + 1];\r\n    const dx = B.x - A.x;\r\n    const dy = B.y - A.y;\r\n    const L = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Relative positions from overall centroid\r\n    const Ax = A.x - centroid.x;\r\n    const Ay = A.y - centroid.y;\r\n    const Bx = B.x - centroid.x;\r\n    const By = B.y - centroid.y;\r\n\r\n    // Segment contribution to covariance: (L/3) * [AA^T + AB^T + BB^T]\r\n    // This is the integral along the line segment from A to B\r\n    covXX += (L / 3) * (Ax * Ax + Ax * Bx + Bx * Bx);\r\n    covXY += (L / 3) * (Ax * Ay + Ax * By + Bx * By);\r\n    covYY += (L / 3) * (Ay * Ay + Ay * By + By * By);\r\n  }\r\n\r\n  // Eigenvalue decomposition to get principal direction\r\n  const trace = covXX + covYY;\r\n  const det = covXX * covYY - covXY * covXY;\r\n  const lambda1 = trace / 2 + Math.sqrt(Math.max(0, trace * trace / 4 - det));\r\n\r\n  // Eigenvector for largest eigenvalue\r\n  let dx, dy;\r\n  if (Math.abs(covXY) > 1e-10) {\r\n    dx = lambda1 - covYY;\r\n    dy = covXY;\r\n  } else if (covXX > covYY) {\r\n    dx = 1;\r\n    dy = 0;\r\n  } else {\r\n    dx = 0;\r\n    dy = 1;\r\n  }\r\n\r\n  // Normalize direction\r\n  const dirLength = Math.sqrt(dx * dx + dy * dy);\r\n  dx /= dirLength;\r\n  dy /= dirLength;\r\n\r\n  const direction = { x: dx, y: dy };\r\n\r\n  // Calculate max perpendicular error (excluding endpoints)\r\n  let maxError = 0;\r\n  let maxErrorIndex = 1; // Start at 1 to skip first endpoint\r\n\r\n  for (let i = 1; i < points.length - 1; i++) { // Exclude first and last points\r\n    const p = points[i];\r\n    const vx = p.x - centroid.x;\r\n    const vy = p.y - centroid.y;\r\n    const error = Math.abs(vx * dy - vy * dx); // Perpendicular distance\r\n\r\n    if (error > maxError) {\r\n      maxError = error;\r\n      maxErrorIndex = i;\r\n    }\r\n  }\r\n\r\n  return { direction, centroid, maxError, maxErrorIndex };\r\n}\r\n\r\n/**\r\n * Project a point onto a line defined by a point and direction\r\n */\r\nfunction projectOntoLine(\r\n  point: { x: number; y: number },\r\n  linePoint: { x: number; y: number },\r\n  direction: { x: number; y: number },\r\n): { x: number; y: number } {\r\n  const vx = point.x - linePoint.x;\r\n  const vy = point.y - linePoint.y;\r\n  const t = vx * direction.x + vy * direction.y;\r\n\r\n  return {\r\n    x: linePoint.x + t * direction.x,\r\n    y: linePoint.y + t * direction.y,\r\n  };\r\n}\r\n\r\n/**\r\n * Find intersection of two line segments defined by their endpoints\r\n */\r\nfunction findLineIntersection(\r\n  a1: { x: number; y: number },\r\n  a2: { x: number; y: number },\r\n  b1: { x: number; y: number },\r\n  b2: { x: number; y: number },\r\n): { x: number; y: number } | null {\r\n  const dx1 = a2.x - a1.x;\r\n  const dy1 = a2.y - a1.y;\r\n  const dx2 = b2.x - b1.x;\r\n  const dy2 = b2.y - b1.y;\r\n\r\n  const denom = dx1 * dy2 - dy1 * dx2;\r\n\r\n  if (Math.abs(denom) < 1e-10) {\r\n    // Parallel or collinear - return midpoint of closest endpoints\r\n    return {\r\n      x: Math.round((a2.x + b1.x) / 2),\r\n      y: Math.round((a2.y + b1.y) / 2),\r\n    };\r\n  }\r\n\r\n  const dx3 = b1.x - a1.x;\r\n  const dy3 = b1.y - a1.y;\r\n\r\n  const t = (dx3 * dy2 - dy3 * dx2) / denom;\r\n\r\n  return {\r\n    x: Math.round(a1.x + t * dx1),\r\n    y: Math.round(a1.y + t * dy1),\r\n  };\r\n}\r\n\r\n/**\r\n * Douglas-Peucker algorithm to simplify a path by removing unnecessary vertices\r\n */\r\nfunction douglasPeucker(\r\n  path: VectorPath,\r\n  vertices: Map<number, Vertex>,\r\n  epsilon: number,\r\n): VectorPath {\r\n  if (path.vertices.length <= 2) {\r\n    return path;\r\n  }\r\n\r\n  const vertexCoords = path.vertices.map((id) => vertices.get(id)!);\r\n  const simplified = douglasPeuckerRecursive(vertexCoords, epsilon);\r\n\r\n  return {\r\n    vertices: simplified.map((v) => v.id),\r\n    closed: path.closed,\r\n  };\r\n}\r\n\r\nfunction douglasPeuckerRecursive(points: Vertex[], epsilon: number): Vertex[] {\r\n  if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find the point with the maximum distance from the line\r\n  let maxDistance = 0;\r\n  let maxIndex = 0;\r\n  const start = points[0];\r\n  const end = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], start, end);\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      maxIndex = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    const left = douglasPeuckerRecursive(\r\n      points.slice(0, maxIndex + 1),\r\n      epsilon,\r\n    );\r\n    const right = douglasPeuckerRecursive(points.slice(maxIndex), epsilon);\r\n\r\n    // Concatenate, removing duplicate middle point\r\n    return [...left.slice(0, -1), ...right];\r\n  } else {\r\n    // All points are close to the line, keep only endpoints\r\n    return [start, end];\r\n  }\r\n}\r\n\r\nfunction perpendicularDistance(\r\n  point: Vertex,\r\n  lineStart: Vertex,\r\n  lineEnd: Vertex,\r\n): number {\r\n  const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // If the line segment is a point, return distance to that point\r\n  if (dx === 0 && dy === 0) {\r\n    return Math.sqrt(\r\n      (point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2,\r\n    );\r\n  }\r\n\r\n  // Calculate perpendicular distance using cross product\r\n  const numerator = Math.abs(\r\n    dy * point.x - dx * point.y + lineEnd.x * lineStart.y -\r\n      lineEnd.y * lineStart.x,\r\n  );\r\n  const denominator = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  return numerator / denominator;\r\n}\r\n\r\n/**\r\n * Trace a path between two vertices, following the skeleton\r\n */\r\n/**\r\n * Check if a pixel is set in a binary image\r\n */\r\nfunction isPixelSet(binary: BinaryImage, x: number, y: number): boolean {\r\n  const pixelIndex = y * binary.width + x;\r\n  const byteIndex = Math.floor(pixelIndex / 8);\r\n  const bitIndex = 7 - (pixelIndex % 8);\r\n\r\n  if (byteIndex >= binary.data.length) return false;\r\n\r\n  return (binary.data[byteIndex] & (1 << bitIndex)) !== 0;\r\n}\r\n\r\n/**\r\n * Calculate if an arc should use the large-arc-flag based on sweep angle\r\n */\r\nfunction calculateArcFlags(\r\n  sweepAngle: number,\r\n  clockwise: boolean,\r\n): { largeArc: number; sweep: number } {\r\n  // Large arc flag is 1 if sweep angle > 180 degrees\r\n  const largeArc = sweepAngle > Math.PI ? 1 : 0;\r\n\r\n  // SVG sweep flag: 1 for clockwise, 0 for counter-clockwise\r\n  const sweep = clockwise ? 1 : 0;\r\n\r\n  return { largeArc, sweep };\r\n}\r\n\r\n/**\r\n * Render vectorized image as SVG overlay on top of canvas\r\n */\r\nexport function renderVectorizedToSVG(\r\n  vectorized: VectorizedImage,\r\n  svgElement: SVGSVGElement,\r\n) {\r\n  const { width, height, paths } = vectorized;\r\n\r\n  // Set SVG size and viewBox to match image\r\n  svgElement.setAttribute(\"width\", width.toString());\r\n  svgElement.setAttribute(\"height\", height.toString());\r\n  svgElement.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\r\n  svgElement.style.display = \"block\";\r\n\r\n  // Clear existing paths\r\n  svgElement.innerHTML = \"\";\r\n\r\n  // Draw each path as an SVG path element\r\n  for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {\r\n    const path = paths[pathIdx];\r\n\r\n    if (path.segments && path.segments.length > 0) {\r\n      // Render path with segments (lines and arcs) - each segment as separate SVG path\r\n      if (path.points.length === 0) continue;\r\n\r\n      // Create a group for this path\r\n      const pathGroup = document.createElementNS(\r\n        \"http://www.w3.org/2000/svg\",\r\n        \"g\",\r\n      );\r\n      pathGroup.setAttribute(\"id\", `path-${pathIdx}`);\r\n\r\n      // Add comment for path\r\n      const pathComment = document.createComment(\r\n        ` Path ${pathIdx}: ${path.segments.length} segments, ${\r\n          path.closed ? \"closed\" : \"open\"\r\n        } `,\r\n      );\r\n      svgElement.appendChild(pathComment);\r\n\r\n      // Process each segment as a separate SVG path\r\n      for (let segIdx = 0; segIdx < path.segments.length; segIdx++) {\r\n        const segment = path.segments[segIdx];\r\n        const segPoints = path.points.slice(\r\n          segment.startIndex,\r\n          segment.endIndex + 1,\r\n        );\r\n\r\n        if (segPoints.length === 0) continue;\r\n\r\n        // Start from the actual first point in the segment\r\n        const startPoint = segPoints[0];\r\n        let segmentPathData = `M ${startPoint.x + 0.5} ${startPoint.y + 0.5}`;\r\n\r\n        if (segment.type === \"line\" && segment.projectedEnd) {\r\n          // Line segment: draw to projected endpoint (if we have 2+ points)\r\n          if (segPoints.length > 1) {\r\n            const endPoint = segPoints[segPoints.length - 1];\r\n            segmentPathData += ` L ${endPoint.x + 0.5} ${endPoint.y + 0.5}`;\r\n          }\r\n        } else if (\r\n          segment.type === \"arc\" && segment.circleFit &&\r\n          segment.projectedStart && segment.projectedEnd\r\n        ) {\r\n          // Arc segment: render as polyline approximation using projected endpoints\r\n          const center = segment.circleFit.center;\r\n          const radius = segment.circleFit.radius;\r\n          const clockwise = segment.circleFit.clockwise;\r\n\r\n          // Calculate angles from projected endpoints (not skeleton points)\r\n          const startAngle = Math.atan2(\r\n            segment.projectedStart.y - center.y,\r\n            segment.projectedStart.x - center.x,\r\n          );\r\n          const endAngle = Math.atan2(\r\n            segment.projectedEnd.y - center.y,\r\n            segment.projectedEnd.x - center.x,\r\n          );\r\n\r\n          // Calculate sweep angle between projected endpoints\r\n          let sweepAngle = clockwise\r\n            ? (endAngle - startAngle)\r\n            : (startAngle - endAngle);\r\n\r\n          // Normalize to [0, 2\u03C0]\r\n          if (sweepAngle < 0) sweepAngle += 2 * Math.PI;\r\n          if (sweepAngle > 2 * Math.PI) sweepAngle -= 2 * Math.PI;\r\n\r\n          // Generate points every ~2 degrees for smooth appearance\r\n          const numPoints = Math.max(3, Math.ceil(sweepAngle / (Math.PI / 90)));\r\n          for (let i = 1; i <= numPoints; i++) {\r\n            const t = i / numPoints;\r\n            const angle = clockwise\r\n              ? startAngle + t * sweepAngle\r\n              : startAngle - t * sweepAngle;\r\n            const px = center.x + radius * Math.cos(angle);\r\n            const py = center.y + radius * Math.sin(angle);\r\n            segmentPathData += ` L ${px + 0.5} ${py + 0.5}`;\r\n          }\r\n        } else {\r\n          // Unfitted segment (polyline): render as pixel-level polyline\r\n          for (let i = 1; i < segPoints.length; i++) {\r\n            const point = segPoints[i];\r\n            segmentPathData += ` L ${point.x + 0.5} ${point.y + 0.5}`;\r\n          }\r\n        }\r\n\r\n        // Add comment for segment\r\n        const segmentComment = document.createComment(\r\n          ` Segment ${segIdx}: type=${segment.type}, points=[${segment.startIndex}-${segment.endIndex}]${\r\n            segment.circleFit\r\n              ? `, center=(${segment.circleFit.center.x.toFixed(1)},${\r\n                segment.circleFit.center.y.toFixed(1)\r\n              }), radius=${segment.circleFit.radius.toFixed(1)}, sweep=${\r\n                (segment.circleFit.sweepAngle * 180 / Math.PI).toFixed(1)\r\n              }\u00B0`\r\n              : \"\"\r\n          } `,\r\n        );\r\n        pathGroup.appendChild(segmentComment);\r\n\r\n        const pathElement = document.createElementNS(\r\n          \"http://www.w3.org/2000/svg\",\r\n          \"path\",\r\n        );\r\n        pathElement.setAttribute(\"d\", segmentPathData);\r\n        pathElement.setAttribute(\"fill\", \"none\");\r\n        pathElement.setAttribute(\"stroke\", \"red\");\r\n        pathElement.setAttribute(\"stroke-width\", \"0.5\");\r\n        pathElement.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n        pathElement.setAttribute(\"data-segment-type\", segment.type);\r\n        pathElement.setAttribute(\"data-segment-index\", segIdx.toString());\r\n        pathGroup.appendChild(pathElement);\r\n      }\r\n\r\n      svgElement.appendChild(pathGroup);\r\n    } else {\r\n      // Fallback: Render as simple polyline (legacy paths without segments)\r\n      if (path.points.length === 0) continue;\r\n\r\n      const firstPoint = path.points[0];\r\n      let pathData = `M ${firstPoint.x + 0.5} ${firstPoint.y + 0.5}`;\r\n\r\n      for (let i = 1; i < path.points.length; i++) {\r\n        const point = path.points[i];\r\n        pathData += ` L ${point.x + 0.5} ${point.y + 0.5}`;\r\n      }\r\n\r\n      if (path.closed) {\r\n        pathData += \" Z\";\r\n      }\r\n\r\n      const pathElement = document.createElementNS(\r\n        \"http://www.w3.org/2000/svg\",\r\n        \"path\",\r\n      );\r\n      pathElement.setAttribute(\"d\", pathData);\r\n      pathElement.setAttribute(\"fill\", \"none\");\r\n      pathElement.setAttribute(\"stroke\", \"red\");\r\n      pathElement.setAttribute(\"stroke-width\", \"0.5\");\r\n      pathElement.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n      svgElement.appendChild(pathElement);\r\n    }\r\n  }\r\n\r\n  // Draw vertices as circles\r\n  for (const path of paths) {\r\n    if (path.segments && path.segments.length > 0) {\r\n      // For segmented paths, draw projected segment endpoints (green) and unfitted skeleton pixels (light blue)\r\n      const drawnVertices = new Set<string>();\r\n\r\n      for (const segment of path.segments) {\r\n        if (segment.type === \"polyline\") {\r\n          // Draw skeleton pixels for unfitted segments (polylines) in light blue\r\n          const segPoints = path.points.slice(\r\n            segment.startIndex,\r\n            segment.endIndex + 1,\r\n          );\r\n          for (const point of segPoints) {\r\n            const key = `${point.x},${point.y}`;\r\n            if (!drawnVertices.has(key)) {\r\n              drawnVertices.add(key);\r\n              const circle = document.createElementNS(\r\n                \"http://www.w3.org/2000/svg\",\r\n                \"circle\",\r\n              );\r\n              circle.setAttribute(\"cx\", (point.x + 0.5).toString());\r\n              circle.setAttribute(\"cy\", (point.y + 0.5).toString());\r\n              circle.setAttribute(\"r\", \"0.5\");\r\n              circle.setAttribute(\"fill\", \"#4169e1\"); // Royal blue for unfitted skeleton pixels\r\n              circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n              svgElement.appendChild(circle);\r\n            }\r\n          }\r\n        } else if (\r\n          (segment.type === \"line\" || segment.type === \"arc\") &&\r\n          segment.projectedStart && segment.projectedEnd\r\n        ) {\r\n          // Draw projected endpoints for fitted segments (green)\r\n          const startKey = `${segment.projectedStart.x.toFixed(3)},${\r\n            segment.projectedStart.y.toFixed(3)\r\n          }`;\r\n          if (!drawnVertices.has(startKey)) {\r\n            drawnVertices.add(startKey);\r\n            const circle = document.createElementNS(\r\n              \"http://www.w3.org/2000/svg\",\r\n              \"circle\",\r\n            );\r\n            circle.setAttribute(\r\n              \"cx\",\r\n              (segment.projectedStart.x + 0.5).toString(),\r\n            );\r\n            circle.setAttribute(\r\n              \"cy\",\r\n              (segment.projectedStart.y + 0.5).toString(),\r\n            );\r\n            circle.setAttribute(\"r\", \"0.5\");\r\n            circle.setAttribute(\"fill\", \"#00aa00\");\r\n            circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n            svgElement.appendChild(circle);\r\n          }\r\n\r\n          const endKey = `${segment.projectedEnd.x.toFixed(3)},${\r\n            segment.projectedEnd.y.toFixed(3)\r\n          }`;\r\n          if (!drawnVertices.has(endKey)) {\r\n            drawnVertices.add(endKey);\r\n            const circle = document.createElementNS(\r\n              \"http://www.w3.org/2000/svg\",\r\n              \"circle\",\r\n            );\r\n            circle.setAttribute(\r\n              \"cx\",\r\n              (segment.projectedEnd.x + 0.5).toString(),\r\n            );\r\n            circle.setAttribute(\r\n              \"cy\",\r\n              (segment.projectedEnd.y + 0.5).toString(),\r\n            );\r\n            circle.setAttribute(\"r\", \"0.5\");\r\n            circle.setAttribute(\"fill\", \"#00aa00\");\r\n            circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n            svgElement.appendChild(circle);\r\n          }\r\n        } else {\r\n          // Fallback: if line/arc segment has no projected endpoints, draw skeleton pixels in blue\r\n          const segPoints = path.points.slice(\r\n            segment.startIndex,\r\n            segment.endIndex + 1,\r\n          );\r\n          for (const point of segPoints) {\r\n            const key = `${point.x},${point.y}`;\r\n            if (!drawnVertices.has(key)) {\r\n              drawnVertices.add(key);\r\n              const circle = document.createElementNS(\r\n                \"http://www.w3.org/2000/svg\",\r\n                \"circle\",\r\n              );\r\n              circle.setAttribute(\"cx\", (point.x + 0.5).toString());\r\n              circle.setAttribute(\"cy\", (point.y + 0.5).toString());\r\n              circle.setAttribute(\"r\", \"0.5\");\r\n              circle.setAttribute(\"fill\", \"#4169e1\"); // Royal blue for skeleton pixels\r\n              circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n              svgElement.appendChild(circle);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // Fallback: for paths without segments, draw all skeleton pixels\r\n      for (const point of path.points) {\r\n        const circle = document.createElementNS(\r\n          \"http://www.w3.org/2000/svg\",\r\n          \"circle\",\r\n        );\r\n        circle.setAttribute(\"cx\", (point.x + 0.5).toString());\r\n        circle.setAttribute(\"cy\", (point.y + 0.5).toString());\r\n        circle.setAttribute(\"r\", \"0.5\");\r\n        circle.setAttribute(\"fill\", \"#00aa00\");\r\n        circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n        svgElement.appendChild(circle);\r\n      }\r\n    }\r\n  }\r\n}\r\n", "// Browser application entry point - New UI\nimport { loadImageFromFile } from \"../src/pdf/image_load.ts\";\nimport { renderPdfPage } from \"../src/pdf/pdf_render.ts\";\nimport type { CanvasBackend } from \"../src/pdf/pdf_render.ts\";\nimport { cleanupGPU, recombineWithValue } from \"../src/gpu/cleanup_gpu.ts\";\nimport { processValueChannel } from \"../src/gpu/value_process_gpu.ts\";\nimport { palettizeGPU } from \"../src/gpu/palettize_gpu.ts\";\nimport { median3x3GPU } from \"../src/gpu/median_gpu.ts\";\nimport { extractBlackGPU } from \"../src/gpu/extract_black_gpu.ts\";\nimport { bloomFilter3x3GPU } from \"../src/gpu/bloom_gpu.ts\";\nimport { subtractBlackGPU } from \"../src/gpu/subtract_black_gpu.ts\";\nimport { createGPUBuffer, getGPUContext } from \"../src/gpu/gpu_context.ts\";\nimport type { RGBAImage } from \"../src/formats/rgba_image.ts\";\nimport type { PalettizedImage } from \"../src/formats/palettized.ts\";\nimport type { BinaryImage } from \"../src/formats/binary.ts\";\nimport { DEFAULT_PALETTE } from \"../src/formats/palettized.ts\";\nimport {\n  clearAllFiles,\n  deleteFile,\n  getFile,\n  listFiles,\n  saveFile,\n  updateFile,\n} from \"./storage.ts\";\nimport type {\n  AppMode,\n  BaseProcessingStage,\n  PaletteColor,\n  ProcessingStage,\n} from \"./types.ts\";\nimport { hexToRGBA, u32ToHex } from \"./utils.ts\";\nimport { state } from \"./state.ts\";\nimport {\n  adjustCropRegion,\n  cropImage,\n  drawCropOverlay,\n  fitToScreen,\n  getCropHandleAtPoint,\n  getCropSettings,\n  initCanvasElements,\n  loadImage,\n  redrawCanvas,\n  saveCropSettings,\n  setDefaultCrop,\n  updateCropInfo,\n  updateCursorForHandle,\n  updateTransform,\n  updateZoom,\n} from \"./canvas.ts\";\nimport {\n  addPaletteColor,\n  buildPaletteRGBA,\n  forceDeactivateEyedropper,\n  initPaletteDB,\n  initPaletteModule,\n  isEyedropperActive,\n  loadDefaultPalette,\n  loadPalette,\n  pickColorFromCanvas,\n  renderPaletteUI,\n  resetPaletteToDefault,\n  savePalette,\n  setDefaultPalette,\n} from \"./palette.ts\";\nimport { renderVectorizedToSVG, vectorizeSkeleton } from \"./vectorize.ts\";\n\n// Browser canvas backend for PDF rendering\nconst browserCanvasBackend: CanvasBackend = {\n  createCanvas(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n};\n\n// Declare global pdfjsLib from CDN script\n// deno-lint-ignore no-explicit-any\ndeclare const pdfjsLib: any;\n\n// DOM Elements\nconst uploadFileList = document.getElementById(\n  \"uploadFileList\",\n) as HTMLDivElement;\nconst uploadBtn = document.getElementById(\"uploadBtn\") as HTMLButtonElement;\nconst clearAllBtn = document.getElementById(\"clearAllBtn\") as HTMLButtonElement;\nconst fileInput = document.getElementById(\"fileInput\") as HTMLInputElement;\n\nconst uploadScreen = document.getElementById(\"uploadScreen\") as HTMLDivElement;\n\nconst pageSelectionScreen = document.getElementById(\n  \"pageSelectionScreen\",\n) as HTMLDivElement;\nconst pdfFileName = document.getElementById(\n  \"pdfFileName\",\n) as HTMLHeadingElement;\nconst pageGrid = document.getElementById(\"pageGrid\") as HTMLDivElement;\nconst pageStatusText = document.getElementById(\n  \"pageStatusText\",\n) as HTMLDivElement;\nconst backToFilesBtn = document.getElementById(\n  \"backToFilesBtn\",\n) as HTMLButtonElement;\n\nconst cropScreen = document.getElementById(\"cropScreen\") as HTMLDivElement;\nconst canvasContainer = document.getElementById(\n  \"canvasContainer\",\n) as HTMLDivElement;\nconst mainCanvas = document.getElementById(\"mainCanvas\") as HTMLCanvasElement;\nconst ctx = mainCanvas.getContext(\"2d\")!;\nconst cropOverlay = document.getElementById(\"cropOverlay\") as HTMLCanvasElement;\nconst cropCtx = cropOverlay.getContext(\"2d\")!;\n\nconst zoomInBtn = document.getElementById(\"zoomInBtn\") as HTMLButtonElement;\nconst zoomOutBtn = document.getElementById(\"zoomOutBtn\") as HTMLButtonElement;\nconst zoomLevel = document.getElementById(\"zoomLevel\") as HTMLDivElement;\nconst fitToScreenBtn = document.getElementById(\n  \"fitToScreenBtn\",\n) as HTMLButtonElement;\nconst clearCropBtn = document.getElementById(\n  \"clearCropBtn\",\n) as HTMLButtonElement;\nconst cropInfo = document.getElementById(\"cropInfo\") as HTMLDivElement;\nconst processBtn = document.getElementById(\"processBtn\") as HTMLButtonElement;\nconst statusText = document.getElementById(\"statusText\") as HTMLDivElement;\nconst resultsContainer = document.getElementById(\n  \"resultsContainer\",\n) as HTMLDivElement;\n\n// Top navigation elements\nconst navStepFile = document.getElementById(\"navStepFile\") as HTMLDivElement;\nconst navStepPage = document.getElementById(\"navStepPage\") as HTMLDivElement;\nconst navStepConfigure = document.getElementById(\n  \"navStepConfigure\",\n) as HTMLDivElement;\nconst toggleToolbarBtn = document.getElementById(\n  \"toggleToolbarBtn\",\n) as HTMLButtonElement;\nconst cropSidebar = document.getElementById(\"cropSidebar\") as HTMLDivElement;\nconst processSidebar = document.getElementById(\n  \"processSidebar\",\n) as HTMLDivElement;\n\n// Palette editor elements (removed const paletteList - now defined in renderPaletteUI)\nconst paletteName = document.getElementById(\"paletteName\") as HTMLInputElement;\nconst addPaletteColorBtn = document.getElementById(\n  \"addPaletteColorBtn\",\n) as HTMLButtonElement;\nconst resetPaletteBtn = document.getElementById(\n  \"resetPaletteBtn\",\n) as HTMLButtonElement;\nconst savePaletteBtn = document.getElementById(\n  \"savePaletteBtn\",\n) as HTMLButtonElement;\nconst loadPaletteBtn = document.getElementById(\n  \"loadPaletteBtn\",\n) as HTMLButtonElement;\nconst setDefaultPaletteBtn = document.getElementById(\n  \"setDefaultPaletteBtn\",\n) as HTMLButtonElement;\n\nconsole.log(\"Palette buttons:\", {\n  addPaletteColorBtn,\n  resetPaletteBtn,\n  savePaletteBtn,\n  loadPaletteBtn,\n  setDefaultPaletteBtn,\n});\n\nconst processingScreen = document.getElementById(\n  \"processingScreen\",\n) as HTMLDivElement;\nconst processCanvasContainer = document.getElementById(\n  \"processCanvasContainer\",\n) as HTMLDivElement;\nconst processCanvas = document.getElementById(\n  \"processCanvas\",\n) as HTMLCanvasElement;\nconst processCtx = processCanvas.getContext(\"2d\")!;\nconst processSvgOverlay = document.getElementById(\n  \"processSvgOverlay\",\n) as SVGSVGElement;\nconst processZoomInBtn = document.getElementById(\n  \"processZoomInBtn\",\n) as HTMLButtonElement;\nconst processZoomOutBtn = document.getElementById(\n  \"processZoomOutBtn\",\n) as HTMLButtonElement;\nconst processZoomLevel = document.getElementById(\n  \"processZoomLevel\",\n) as HTMLDivElement;\nconst processFitToScreenBtn = document.getElementById(\n  \"processFitToScreenBtn\",\n) as HTMLButtonElement;\nconst processStatusText = document.getElementById(\n  \"processStatusText\",\n) as HTMLDivElement;\n\nconst stageCroppedBtn = document.getElementById(\n  \"stageCroppedBtn\",\n) as HTMLButtonElement;\nconst stageExtractBlackBtn = document.getElementById(\n  \"stageExtractBlackBtn\",\n) as HTMLButtonElement;\nconst stageSubtractBlackBtn = document.getElementById(\n  \"stageSubtractBlackBtn\",\n) as HTMLButtonElement;\nconst stageValueBtn = document.getElementById(\n  \"stageValueBtn\",\n) as HTMLButtonElement;\nconst stageSaturationBtn = document.getElementById(\n  \"stageSaturationBtn\",\n) as HTMLButtonElement;\nconst stageSaturationMedianBtn = document.getElementById(\n  \"stageSaturationMedianBtn\",\n) as HTMLButtonElement;\nconst stageHueBtn = document.getElementById(\"stageHueBtn\") as HTMLButtonElement;\nconst stageHueMedianBtn = document.getElementById(\n  \"stageHueMedianBtn\",\n) as HTMLButtonElement;\nconst stageCleanupBtn = document.getElementById(\n  \"stageCleanupBtn\",\n) as HTMLButtonElement;\nconst stagePalettizedBtn = document.getElementById(\n  \"stagePalettizedBtn\",\n) as HTMLButtonElement;\nconst stageMedianBtn = document.getElementById(\n  \"stageMedianBtn\",\n) as HTMLButtonElement;\nconst colorStagesContainer = document.getElementById(\n  \"colorStagesContainer\",\n) as HTMLDivElement;\nconst vectorOverlayContainer = document.getElementById(\n  \"vectorOverlayContainer\",\n) as HTMLDivElement;\n\n// Initialize canvas and palette modules\ninitCanvasElements({\n  canvasContainer,\n  mainCanvas,\n  ctx,\n  cropOverlay,\n  cropCtx,\n  zoomLevel,\n  cropInfo,\n});\n\ninitPaletteModule({\n  showStatus,\n  mainCanvas,\n});\n\n// Processing screen event handlers\nstageCroppedBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"cropped\"),\n);\nstageExtractBlackBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"extract_black\"),\n);\nstageSubtractBlackBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"subtract_black\"),\n);\nstageValueBtn.addEventListener(\"click\", () => displayProcessingStage(\"value\"));\nstageSaturationBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"saturation\"),\n);\nstageSaturationMedianBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"saturation_median\"),\n);\nstageHueBtn.addEventListener(\"click\", () => displayProcessingStage(\"hue\"));\nstageHueMedianBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"hue_median\"),\n);\nstageCleanupBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"cleanup\"),\n);\nstagePalettizedBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"palettized\"),\n);\nstageMedianBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"median\"),\n);\n\nprocessZoomInBtn.addEventListener(\"click\", () => {\n  state.processZoom = Math.min(10, state.processZoom * 1.2);\n  updateProcessZoom();\n  updateProcessTransform();\n});\n\nprocessZoomOutBtn.addEventListener(\"click\", () => {\n  state.processZoom = Math.max(0.1, state.processZoom / 1.2);\n  updateProcessZoom();\n  updateProcessTransform();\n});\n\nprocessFitToScreenBtn.addEventListener(\"click\", () => {\n  processFitToScreen();\n});\n\n// Navigation step click handlers\nnavStepFile.addEventListener(\"click\", () => {\n  if (!navStepFile.classList.contains(\"disabled\")) {\n    setMode(\"upload\");\n  }\n});\n\nnavStepPage.addEventListener(\"click\", () => {\n  if (!navStepPage.classList.contains(\"disabled\") && state.currentPdfData) {\n    setMode(\"pageSelection\");\n  }\n});\n\n// Sidebar toggle\ntoggleToolbarBtn.addEventListener(\"click\", () => {\n  cropSidebar?.classList.toggle(\"collapsed\");\n  processSidebar?.classList.toggle(\"collapsed\");\n});\n\n// Initialize\nrefreshFileList();\nsetMode(\"upload\");\n\n// File management\nuploadBtn.addEventListener(\"click\", (e) => {\n  e.stopPropagation();\n  fileInput.click();\n});\n\nuploadScreen.addEventListener(\"click\", (e) => {\n  const target = e.target as HTMLElement;\n  // Don't trigger file input if clicking on a file card, button, or inside the files grid\n  if (target.closest(\".file-card\") || target.closest(\".upload-actions\")) {\n    return;\n  }\n  // Only trigger on empty area or the upload-empty placeholder\n  if (target === uploadScreen || target.closest(\".upload-file-list\")) {\n    fileInput.click();\n  }\n});\n\nfileInput.addEventListener(\"change\", (e) => {\n  const files = (e.target as HTMLInputElement).files;\n  if (files && files.length > 0) {\n    handleFileUpload(files[0]);\n  }\n});\n\n// Drag and drop on entire upload screen\nuploadScreen.addEventListener(\"dragover\", (e) => {\n  e.preventDefault();\n  uploadScreen.classList.add(\"drag-over\");\n});\n\nuploadScreen.addEventListener(\"dragleave\", (e) => {\n  if (e.target === uploadScreen) {\n    uploadScreen.classList.remove(\"drag-over\");\n  }\n});\n\nuploadScreen.addEventListener(\"drop\", (e) => {\n  e.preventDefault();\n  uploadScreen.classList.remove(\"drag-over\");\n  const files = e.dataTransfer?.files;\n  if (files && files.length > 0) {\n    handleFileUpload(files[0]);\n  }\n});\n\nclearAllBtn.addEventListener(\"click\", async () => {\n  if (confirm(\"Delete all saved files?\")) {\n    await clearAllFiles();\n    await refreshFileList();\n    showStatus(\"All files cleared\");\n  }\n});\n\nbackToFilesBtn.addEventListener(\"click\", () => {\n  state.currentFileId = null;\n  state.currentPdfData = null;\n  state.currentImage = null;\n  state.cropRegion = null;\n  setMode(\"upload\");\n  refreshFileList();\n});\n\n// Zoom controls\nzoomInBtn.addEventListener(\"click\", () => {\n  state.zoom = Math.min(10, state.zoom * 1.2);\n  updateZoom();\n  updateTransform();\n});\n\nzoomOutBtn.addEventListener(\"click\", () => {\n  state.zoom /= 1.2;\n  updateZoom();\n  redrawCanvas();\n});\n\nfitToScreenBtn.addEventListener(\"click\", () => {\n  fitToScreen();\n});\n\n// Crop controls - crop is always active\nclearCropBtn.addEventListener(\"click\", () => {\n  // Reset to default 10% margin\n  if (state.currentImage) {\n    setDefaultCrop(state.currentImage.width, state.currentImage.height);\n    drawCropOverlay();\n  }\n});\n\nprocessBtn.addEventListener(\"click\", async () => {\n  if (state.currentImage) {\n    await startProcessing();\n  }\n});\n\n// Canvas interaction\ncanvasContainer.addEventListener(\"mousedown\", (e) => {\n  const rect = canvasContainer.getBoundingClientRect();\n  const canvasX = (e.clientX - rect.left - state.panX) / state.zoom;\n  const canvasY = (e.clientY - rect.top - state.panY) / state.zoom;\n\n  // Check if clicking on a crop handle\n  const handle = getCropHandleAtPoint(canvasX, canvasY);\n  if (handle && state.cropRegion) {\n    state.isDraggingCropHandle = true;\n    state.activeCropHandle = handle;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n  } else if (!e.shiftKey) {\n    // Pan with mouse drag (when not shift-clicking)\n    state.isPanning = true;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n    canvasContainer.classList.add(\"grabbing\");\n  }\n});\n\ncanvasContainer.addEventListener(\"mousemove\", (e) => {\n  if (\n    state.isDraggingCropHandle && state.activeCropHandle && state.cropRegion\n  ) {\n    const dx = (e.clientX - state.lastPanX) / state.zoom;\n    const dy = (e.clientY - state.lastPanY) / state.zoom;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n\n    // Adjust crop region based on handle\n    adjustCropRegion(state.activeCropHandle, dx, dy);\n    drawCropOverlay();\n  } else if (state.isPanning) {\n    const dx = e.clientX - state.lastPanX;\n    const dy = e.clientY - state.lastPanY;\n    state.panX += dx;\n    state.panY += dy;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n    updateTransform();\n  } else {\n    // Update cursor based on hover\n    const rect = canvasContainer.getBoundingClientRect();\n    const canvasX = (e.clientX - rect.left - state.panX) / state.zoom;\n    const canvasY = (e.clientY - rect.top - state.panY) / state.zoom;\n    const handle = getCropHandleAtPoint(canvasX, canvasY);\n    updateCursorForHandle(handle);\n  }\n});\n\ncanvasContainer.addEventListener(\"mouseup\", () => {\n  if (state.isDraggingCropHandle) {\n    state.isDraggingCropHandle = false;\n    state.activeCropHandle = null;\n    // Save crop settings\n    if (state.currentImage && state.cropRegion) {\n      saveCropSettings(\n        state.currentImage.width,\n        state.currentImage.height,\n        state.cropRegion,\n      );\n      updateCropInfo();\n    }\n  }\n\n  if (state.isPanning) {\n    state.isPanning = false;\n    canvasContainer.classList.remove(\"grabbing\");\n  }\n});\n\ncanvasContainer.addEventListener(\"mouseleave\", () => {\n  state.isPanning = false;\n  canvasContainer.classList.remove(\"grabbing\");\n});\n\ncanvasContainer.addEventListener(\"wheel\", (e) => {\n  e.preventDefault();\n\n  // Check if this is a pinch state.zoom (ctrlKey) or two-finger pan\n  const isPinchZoom = e.ctrlKey;\n\n  if (isPinchZoom) {\n    // Pinch to state.zoom\n    const rect = canvasContainer.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    // Calculate the point in canvas coordinates before state.zoom\n    const canvasX = (mouseX - state.panX) / state.zoom;\n    const canvasY = (mouseY - state.panY) / state.zoom;\n\n    // Apply state.zoom with constant speed in log space (feels consistent at all state.zoom levels)\n    // Instead of multiplying by a factor, we adjust by a fixed percentage of the current state.zoom\n    const zoomSpeed = 0.01; // Adjust this to change overall state.zoom speed\n    const zoomChange = -e.deltaY * zoomSpeed * state.zoom;\n    const newZoom = Math.max(0.1, Math.min(20, state.zoom + zoomChange));\n\n    // Adjust pan to keep the point under the mouse\n    state.panX = mouseX - canvasX * newZoom;\n    state.panY = mouseY - canvasY * newZoom;\n    state.zoom = newZoom;\n\n    updateZoom();\n    updateTransform();\n  } else {\n    // Two-finger pan (or mouse wheel)\n    state.panX -= e.deltaX;\n    state.panY -= e.deltaY;\n    updateTransform();\n  }\n});\n\n// Processing canvas interaction\nprocessCanvasContainer.addEventListener(\"mousedown\", (e) => {\n  state.isProcessPanning = true;\n  state.lastProcessPanX = e.clientX;\n  state.lastProcessPanY = e.clientY;\n  processCanvasContainer.classList.add(\"grabbing\");\n});\n\nprocessCanvasContainer.addEventListener(\"mousemove\", (e) => {\n  if (state.isProcessPanning) {\n    const dx = e.clientX - state.lastProcessPanX;\n    const dy = e.clientY - state.lastProcessPanY;\n    state.processPanX += dx;\n    state.processPanY += dy;\n    state.lastProcessPanX = e.clientX;\n    state.lastProcessPanY = e.clientY;\n    updateProcessTransform();\n  }\n});\n\nprocessCanvasContainer.addEventListener(\"mouseup\", () => {\n  if (state.isProcessPanning) {\n    state.isProcessPanning = false;\n    processCanvasContainer.classList.remove(\"grabbing\");\n  }\n});\n\nprocessCanvasContainer.addEventListener(\"mouseleave\", () => {\n  state.isProcessPanning = false;\n  processCanvasContainer.classList.remove(\"grabbing\");\n});\n\nprocessCanvasContainer.addEventListener(\"wheel\", (e) => {\n  e.preventDefault();\n\n  const isPinchZoom = e.ctrlKey;\n\n  if (isPinchZoom) {\n    // Pinch to zoom\n    const rect = processCanvasContainer.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    // Get dimensions from either processed image or vectorized image\n    let width = 0, height = 0;\n    const image = state.processedImages.get(state.currentStage);\n    if (image) {\n      width = image.width;\n      height = image.height;\n    } else if (state.currentStage.endsWith(\"_vec\")) {\n      const vectorized = state.vectorizedImages.get(state.currentStage);\n      if (vectorized) {\n        width = vectorized.width;\n        height = vectorized.height;\n      }\n    }\n\n    if (width === 0 || height === 0) return;\n\n    const canvasX = (mouseX - state.processPanX) / state.processZoom;\n    const canvasY = (mouseY - state.processPanY) / state.processZoom;\n\n    const zoomSpeed = 0.005;\n    const zoomChange = -e.deltaY * zoomSpeed * state.processZoom;\n    const newZoom = Math.max(0.1, Math.min(10, state.processZoom + zoomChange));\n\n    state.processPanX = mouseX - canvasX * newZoom;\n    state.processPanY = mouseY - canvasY * newZoom;\n    state.processZoom = newZoom;\n\n    updateProcessZoom();\n    updateProcessTransform();\n  } else {\n    // Two-finger pan (or mouse wheel)\n    state.processPanX -= e.deltaX;\n    state.processPanY -= e.deltaY;\n    updateProcessTransform();\n  }\n});\n\n// Mode management\nfunction updateNavigation(mode: AppMode) {\n  // Update navigation step states\n  navStepFile.classList.remove(\"active\", \"completed\", \"disabled\");\n  navStepPage.classList.remove(\"active\", \"completed\", \"disabled\");\n  navStepConfigure.classList.remove(\"active\", \"completed\", \"disabled\");\n\n  switch (mode) {\n    case \"upload\":\n      navStepFile.classList.add(\"active\");\n      navStepPage.classList.add(\"disabled\");\n      navStepConfigure.classList.add(\"disabled\");\n      break;\n    case \"pageSelection\":\n      navStepFile.classList.add(\"completed\");\n      navStepPage.classList.add(\"active\");\n      navStepConfigure.classList.add(\"disabled\");\n      break;\n    case \"crop\":\n      navStepFile.classList.add(\"completed\");\n      navStepPage.classList.add(\"completed\");\n      navStepConfigure.classList.add(\"active\");\n      break;\n    case \"processing\":\n      navStepFile.classList.add(\"completed\");\n      navStepPage.classList.add(\"completed\");\n      navStepConfigure.classList.add(\"completed\");\n      break;\n  }\n}\n\nfunction setMode(mode: AppMode) {\n  console.log(\"setMode called:\", mode);\n\n  uploadScreen.classList.remove(\"active\");\n  pageSelectionScreen.classList.remove(\"active\");\n  cropScreen.classList.remove(\"active\");\n  processingScreen.classList.remove(\"active\");\n\n  // Clear any inline styles that might override CSS\n  pageSelectionScreen.style.display = \"\";\n\n  switch (mode) {\n    case \"upload\":\n      uploadScreen.classList.add(\"active\");\n      console.log(\"Upload screen activated\");\n      console.log(\n        \"uploadScreen display:\",\n        globalThis.getComputedStyle(uploadScreen).display,\n      );\n      console.log(\n        \"uploadScreen hasClass active:\",\n        uploadScreen.classList.contains(\"active\"),\n      );\n      break;\n    case \"pageSelection\":\n      pageSelectionScreen.classList.add(\"active\");\n      // Force display as a test\n      pageSelectionScreen.style.display = \"flex\";\n      console.log(\n        \"Page selection screen activated, pageGrid children:\",\n        pageGrid.children.length,\n      );\n      console.log(\n        \"pageSelectionScreen display:\",\n        globalThis.getComputedStyle(pageSelectionScreen).display,\n      );\n      console.log(\n        \"pageSelectionScreen visibility:\",\n        globalThis.getComputedStyle(pageSelectionScreen).visibility,\n      );\n      break;\n    case \"crop\":\n      cropScreen.classList.add(\"active\");\n      console.log(\"Crop screen activated\");\n      break;\n    case \"processing\":\n      processingScreen.classList.add(\"active\");\n      console.log(\"Processing screen activated\");\n      break;\n  }\n\n  // Update navigation\n  updateNavigation(mode);\n}\n\nfunction showStatus(message: string, isError = false) {\n  // Update status in whichever screen is currently visible\n  let activeStatusText = statusText;\n  if (pageSelectionScreen.classList.contains(\"active\")) {\n    activeStatusText = pageStatusText;\n  } else if (processingScreen.classList.contains(\"active\")) {\n    activeStatusText = processStatusText;\n  }\n\n  activeStatusText.textContent = message;\n  if (isError) {\n    activeStatusText.classList.add(\"status-error\");\n  } else {\n    activeStatusText.classList.remove(\"status-error\");\n  }\n  console.log(message);\n}\n\n// Palette Storage Functions (IndexedDB)\n\n// Initialize palette DB (default palette will be loaded only if no file is selected)\ninitPaletteDB();\n\nasync function handleFileUpload(file: File) {\n  try {\n    showStatus(`Loading: ${file.name}...`);\n\n    // Save to storage if not already saved\n    if (!state.currentFileId) {\n      try {\n        state.currentFileId = await saveFile(file);\n        console.log(`File saved with ID: ${state.currentFileId}`);\n        // Load default palette for new uploads\n        await loadDefaultPalette();\n        await refreshFileList();\n      } catch (err) {\n        console.error(\"Error saving file:\", err);\n      }\n    }\n\n    if (file.type === \"application/pdf\") {\n      console.log(\"handleFileUpload: Detected PDF, calling loadPdf\");\n      await loadPdf(file);\n      console.log(\n        \"handleFileUpload: loadPdf complete, switching to pageSelection mode\",\n      );\n      setMode(\"pageSelection\");\n    } else {\n      console.log(\"handleFileUpload: Detected image, loading directly\");\n      const image = await loadImageFromFile(file);\n      await loadImage(image, showStatus);\n      setMode(\"crop\");\n    }\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, true);\n    console.error(error);\n  }\n}\n\nasync function loadPdf(file: File) {\n  try {\n    console.log(\"loadPdf: Starting to load\", file.name);\n    const arrayBuffer = await file.arrayBuffer();\n    console.log(\"loadPdf: Got arrayBuffer, length:\", arrayBuffer.byteLength);\n    const copy = new Uint8Array(arrayBuffer.byteLength);\n    copy.set(new Uint8Array(arrayBuffer));\n    state.currentPdfData = copy;\n    console.log(\"loadPdf: Created copy\", copy.length);\n\n    const initialCopy = state.currentPdfData.slice();\n    console.log(\"loadPdf: Calling getDocument\");\n    const loadingTask = pdfjsLib.getDocument({ data: initialCopy });\n    const pdf = await loadingTask.promise;\n    state.pdfPageCount = pdf.numPages;\n    console.log(\"loadPdf: PDF loaded, pages:\", state.pdfPageCount);\n\n    showStatus(`PDF loaded: ${state.pdfPageCount} pages`);\n    console.log(\"loadPdf: About to set pdfFileName, element:\", pdfFileName);\n    try {\n      pdfFileName.textContent = file.name;\n      console.log(\"loadPdf: pdfFileName set successfully\");\n    } catch (e) {\n      console.error(\"loadPdf: Error setting pdfFileName:\", e);\n    }\n    console.log(\"loadPdf: pdfFileName set, about to generate thumbnails\");\n\n    // Generate page thumbnails\n    console.log(\"loadPdf: Generating page thumbnails, clearing pageGrid\");\n    console.log(\"loadPdf: pageGrid element:\", pageGrid);\n    const existingCards = pageGrid.children.length;\n    if (existingCards > 0) {\n      console.log(\n        `[THUMBNAIL] PURGING ${existingCards} existing thumbnail cards from cache`,\n      );\n    }\n    pageGrid.innerHTML = \"\";\n    console.log(\n      \"loadPdf: pageGrid cleared, adding\",\n      state.pdfPageCount,\n      \"cards\",\n    );\n\n    // First pass: get all page dimensions and create cards with proper aspect ratios\n    const pageDimensions: Array<\n      { width: number; height: number; pageLabel: string }\n    > = [];\n\n    // Get page labels from PDF (if available)\n    let pageLabels: string[] | null = null;\n    try {\n      pageLabels = await pdf.getPageLabels();\n    } catch (_e) {\n      // Page labels not available, will use page numbers\n    }\n\n    for (let i = 1; i <= state.pdfPageCount; i++) {\n      const page = await pdf.getPage(i);\n      const viewport = page.getViewport({ scale: 1.0 });\n\n      // Get page label from PDF (e.g., \"i\", \"ii\", \"1\", \"A-1\", etc.)\n      const pageLabel = (pageLabels && pageLabels[i - 1]) || `Page ${i}`;\n\n      pageDimensions.push({\n        width: viewport.width,\n        height: viewport.height,\n        pageLabel,\n      });\n\n      const card = document.createElement(\"div\");\n      card.className = \"page-card\";\n\n      const imageDiv = document.createElement(\"div\");\n      imageDiv.className = \"page-card-image\";\n      imageDiv.textContent = \"\uD83D\uDCC4\";\n\n      // Set aspect ratio immediately so layout is stable\n      const aspectRatio = viewport.width / viewport.height;\n      imageDiv.style.aspectRatio = aspectRatio.toString();\n      imageDiv.style.width = (250 * aspectRatio) + \"px\";\n\n      const label = document.createElement(\"div\");\n      label.className = \"page-card-label\";\n      label.textContent = pageLabel;\n\n      card.appendChild(imageDiv);\n      card.appendChild(label);\n      card.dataset.pageNum = i.toString();\n\n      // Highlight if this is the currently selected page\n      if (i === state.currentSelectedPage) {\n        card.classList.add(\"selected\");\n      }\n\n      card.addEventListener(\"click\", () => {\n        selectPdfPage(i);\n      });\n\n      pageGrid.appendChild(card);\n    }\n\n    // Second pass: render thumbnails with interleaved priority (early pages + largest pages)\n    // Cap at reasonable number for large PDFs (~2-3 screenfuls worth)\n    const MAX_THUMBNAILS = 50;\n    const thumbnailsToRender = Math.min(state.pdfPageCount, MAX_THUMBNAILS);\n\n    // Reset cancellation flag\n    state.cancelThumbnailLoading = false;\n\n    (async () => {\n      // Sort pages by size (largest first)\n      const pagesBySize = Array.from(\n        { length: state.pdfPageCount },\n        (_, i) => i,\n      )\n        .sort((a, b) => {\n          const areaA = pageDimensions[a].width * pageDimensions[a].height;\n          const areaB = pageDimensions[b].width * pageDimensions[b].height;\n          return areaB - areaA;\n        });\n\n      // Interleave: [page 1, page 2, largest], [page 3, page 4, 2nd largest], etc.\n      const renderQueue: number[] = [];\n      const addedPages = new Set<number>();\n      let sequentialIndex = 0;\n      let largestIndex = 0;\n\n      console.log(\n        `[THUMBNAIL] Building render queue for ${thumbnailsToRender} thumbnails out of ${state.pdfPageCount} pages`,\n      );\n\n      while (\n        renderQueue.length < thumbnailsToRender &&\n        (sequentialIndex < state.pdfPageCount ||\n          largestIndex < pagesBySize.length)\n      ) {\n        // Add next 2 sequential pages\n        if (\n          sequentialIndex < state.pdfPageCount &&\n          renderQueue.length < thumbnailsToRender\n        ) {\n          if (!addedPages.has(sequentialIndex)) {\n            renderQueue.push(sequentialIndex);\n            addedPages.add(sequentialIndex);\n          }\n          sequentialIndex++;\n        }\n        if (\n          sequentialIndex < state.pdfPageCount &&\n          renderQueue.length < thumbnailsToRender\n        ) {\n          if (!addedPages.has(sequentialIndex)) {\n            renderQueue.push(sequentialIndex);\n            addedPages.add(sequentialIndex);\n          }\n          sequentialIndex++;\n        }\n\n        // Add next largest page (but skip if already in queue)\n        while (\n          largestIndex < pagesBySize.length &&\n          renderQueue.length < thumbnailsToRender\n        ) {\n          const largestPageIdx = pagesBySize[largestIndex++];\n          if (!addedPages.has(largestPageIdx)) {\n            renderQueue.push(largestPageIdx);\n            addedPages.add(largestPageIdx);\n            break;\n          }\n        }\n      }\n\n      console.log(\n        `[THUMBNAIL] Render queue built with ${renderQueue.length} pages:`,\n        renderQueue.map((idx) => {\n          const pageNum = idx + 1;\n          const label = pageDimensions[idx]?.pageLabel || `Page ${pageNum}`;\n          return `${pageNum}(${label})`;\n        }).join(\", \"),\n      );\n\n      // Render in batches of 3\n      const batchSize = 3;\n      let completed = 0;\n\n      // Store cards array once to avoid re-querying\n      const allCards = Array.from(pageGrid.children);\n\n      for (let i = 0; i < renderQueue.length; i += batchSize) {\n        // Check cancellation flag\n        if (state.cancelThumbnailLoading) {\n          console.log(\n            `[THUMBNAIL] Loading cancelled after ${completed} thumbnails`,\n          );\n          showStatus(`Thumbnail loading cancelled`);\n          return;\n        }\n\n        const batch = [];\n        const batchInfo = [];\n        for (let j = 0; j < batchSize && i + j < renderQueue.length; j++) {\n          const pageIndex = renderQueue[i + j];\n          const pageNum = pageIndex + 1;\n          const pageLabel = pageDimensions[pageIndex]?.pageLabel ||\n            `Page ${pageNum}`;\n\n          // Safely get card and image div\n          if (pageIndex < allCards.length) {\n            const card = allCards[pageIndex];\n            const imageDiv = card.querySelector(\n              \".page-card-image\",\n            ) as HTMLElement;\n            if (imageDiv) {\n              batchInfo.push(`${pageNum}(${pageLabel})`);\n              batch.push(generatePageThumbnail(pageNum, pageLabel, imageDiv));\n            } else {\n              console.warn(\n                `[THUMBNAIL] No imageDiv found for page ${pageNum}(${pageLabel}) at index ${pageIndex}`,\n              );\n            }\n          } else {\n            console.warn(\n              `[THUMBNAIL] Page index ${pageIndex} out of bounds (cards.length=${allCards.length}) for page ${pageNum}`,\n            );\n          }\n        }\n\n        if (batch.length > 0) {\n          console.log(\n            `[THUMBNAIL] Batch ${Math.floor(i / batchSize) + 1}: Rendering ${\n              batchInfo.join(\", \")\n            }`,\n          );\n          await Promise.all(batch);\n          completed += batch.length;\n          console.log(\n            `[THUMBNAIL] Batch complete. Total: ${completed}/${renderQueue.length}`,\n          );\n          const statusMsg = thumbnailsToRender < state.pdfPageCount\n            ? `Loading thumbnails: ${completed}/${thumbnailsToRender} (${state.pdfPageCount} pages total)`\n            : `Loading thumbnails: ${completed}/${state.pdfPageCount}`;\n          showStatus(statusMsg);\n        } else {\n          console.warn(\n            `[THUMBNAIL] Batch ${\n              Math.floor(i / batchSize) + 1\n            }: No valid thumbnails to render`,\n          );\n        }\n      }\n      const finalMsg = thumbnailsToRender < state.pdfPageCount\n        ? `PDF loaded: ${state.pdfPageCount} pages (showing ${thumbnailsToRender} thumbnails)`\n        : `PDF loaded: ${state.pdfPageCount} pages`;\n      showStatus(finalMsg);\n    })();\n  } catch (error) {\n    console.error(\"loadPdf error:\", error);\n    showStatus(`PDF load error: ${(error as Error).message}`, true);\n    throw error;\n  }\n}\n\nasync function generatePageThumbnail(\n  pageNum: number,\n  pageLabel: string,\n  container: HTMLElement,\n) {\n  try {\n    if (!state.currentPdfData) {\n      console.warn(`[THUMBNAIL] No PDF data for page ${pageNum}(${pageLabel})`);\n      return;\n    }\n\n    console.log(`[THUMBNAIL] START rendering page ${pageNum}(${pageLabel})`);\n    const pdfDataCopy = state.currentPdfData.slice();\n    const image = await renderPdfPage(\n      { file: pdfDataCopy, pageNumber: pageNum, scale: 0.4 },\n      browserCanvasBackend,\n      pdfjsLib,\n    );\n    console.log(\n      `[THUMBNAIL] RENDERED page ${pageNum}(${pageLabel}): ${image.width}x${image.height}`,\n    );\n\n    // Set the container's aspect ratio based on actual page dimensions\n    const aspectRatio = image.width / image.height;\n    container.style.aspectRatio = aspectRatio.toString();\n    container.style.width = (250 * aspectRatio) + \"px\";\n\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      const imageData = new ImageData(\n        new Uint8ClampedArray(image.data),\n        image.width,\n        image.height,\n      );\n      ctx.putImageData(imageData, 0, 0);\n\n      const img = document.createElement(\"img\");\n      img.src = canvas.toDataURL();\n      container.innerHTML = \"\";\n      container.appendChild(img);\n      console.log(\n        `[THUMBNAIL] COMPLETE page ${pageNum}(${pageLabel}) - image inserted into DOM`,\n      );\n    }\n  } catch (err) {\n    console.error(\n      `[THUMBNAIL] ERROR generating thumbnail for page ${pageNum}(${pageLabel}):`,\n      err,\n    );\n  }\n}\n\nasync function selectPdfPage(pageNum: number) {\n  try {\n    console.log(\"selectPdfPage: Starting, page:\", pageNum);\n    if (!state.currentPdfData) {\n      console.error(\"selectPdfPage: No PDF data!\");\n      showStatus(\"No PDF loaded\", true);\n      return;\n    }\n\n    // Cancel any ongoing thumbnail loading\n    state.cancelThumbnailLoading = true;\n\n    // Update selected page tracking\n    state.currentSelectedPage = pageNum;\n\n    // Update page card selection highlighting\n    const cards = pageGrid.querySelectorAll(\".page-card\");\n    cards.forEach((card) => card.classList.remove(\"selected\"));\n    const selectedCard = pageGrid.querySelector(`[data-page-num=\"${pageNum}\"]`);\n    if (selectedCard) {\n      selectedCard.classList.add(\"selected\");\n    }\n\n    // Switch to crop screen immediately with loading state\n    setMode(\"crop\");\n\n    // Clear previous canvas content AND hide crop overlay\n    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);\n    cropCtx.clearRect(0, 0, cropOverlay.width, cropOverlay.height);\n    mainCanvas.width = 0;\n    mainCanvas.height = 0;\n    cropOverlay.width = 0;\n    cropOverlay.height = 0;\n    cropOverlay.style.display = \"none\";\n\n    showStatus(`\u23F3 Rendering page ${pageNum} at 200 DPI...`);\n    canvasContainer.style.opacity = \"0.3\";\n\n    // Simulate progress indicator (since PDF.js doesn't provide real progress)\n    let progressDots = 0;\n    const progressInterval = setInterval(() => {\n      progressDots = (progressDots + 1) % 4;\n      showStatus(\n        `\u23F3 Rendering page ${pageNum} at 200 DPI${\".\".repeat(progressDots)}`,\n      );\n    }, 300);\n\n    console.log(\"selectPdfPage: Creating copy\");\n    const pdfDataCopy = state.currentPdfData.slice();\n    console.log(\"selectPdfPage: Calling renderPdfPage\");\n    // Scale 2.778 \u2248 200 DPI (72 * 2.778 \u2248 200)\n    const image = await renderPdfPage(\n      {\n        file: pdfDataCopy,\n        pageNumber: pageNum,\n        scale: 2.778,\n      },\n      browserCanvasBackend,\n      pdfjsLib,\n    );\n    console.log(\"selectPdfPage: Got image\", image.width, \"x\", image.height);\n\n    clearInterval(progressInterval);\n    canvasContainer.style.opacity = \"1\";\n    await loadImage(image, showStatus);\n    showStatus(`\u2713 Page ${pageNum} loaded: ${image.width}\u00D7${image.height}`);\n\n    // Update thumbnail and palette in storage\n    if (state.currentFileId && state.currentImage) {\n      const thumbnail = generateThumbnail(state.currentImage);\n      const palette = JSON.stringify(state.userPalette);\n      await updateFile(state.currentFileId, { thumbnail, palette });\n      await refreshFileList();\n    }\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, true);\n    console.error(error);\n  }\n}\n\n// Helper: Convert RGBA skeleton (grayscale) to binary format\nfunction rgbaToBinary(rgba: RGBAImage): BinaryImage {\n  const { width, height, data } = rgba;\n  const numPixels = width * height;\n  const byteCount = Math.ceil(numPixels / 8);\n  const binaryData = new Uint8Array(byteCount);\n\n  // Convert: white (255) = 0, black (0) = 1\n  for (let pixelIndex = 0; pixelIndex < numPixels; pixelIndex++) {\n    const r = data[pixelIndex * 4];\n\n    // If pixel is black (or dark), set bit to 1\n    if (r < 128) {\n      const bitByteIndex = Math.floor(pixelIndex / 8);\n      const bitIndex = 7 - (pixelIndex % 8); // MSB-first\n      binaryData[bitByteIndex] |= 1 << bitIndex;\n    }\n  }\n\n  return { width, height, data: binaryData };\n}\n\n// Crop management functions\n\n// Helper: Extract a single color from palettized image to binary format\nfunction extractColorFromPalettized(\n  palettized: PalettizedImage,\n  colorIndex: number,\n): BinaryImage {\n  const { width, height, data } = palettized;\n  const numPixels = width * height;\n\n  // Create properly bit-packed binary image\n  const byteCount = Math.ceil(numPixels / 8);\n  const binaryData = new Uint8Array(byteCount);\n\n  for (let pixelIndex = 0; pixelIndex < numPixels; pixelIndex++) {\n    const byteIndex = Math.floor(pixelIndex / 2);\n    const isHighNibble = pixelIndex % 2 === 0;\n\n    // Extract 4-bit color index from nibble\n    const paletteIndex = isHighNibble\n      ? (data[byteIndex] >> 4) & 0x0f\n      : data[byteIndex] & 0x0f;\n\n    // Set bit to 1 if this pixel matches the color we're extracting\n    if (paletteIndex === colorIndex) {\n      const bitByteIndex = Math.floor(pixelIndex / 8);\n      const bitIndex = 7 - (pixelIndex % 8); // MSB-first\n      binaryData[bitByteIndex] |= 1 << bitIndex;\n    }\n  }\n\n  return { width, height, data: binaryData };\n}\n\n// Helper: Convert Binary image to GPU buffer for processing\nasync function binaryToGPUBuffer(binary: BinaryImage): Promise<GPUBuffer> {\n  const { device } = await getGPUContext();\n  const { width, height, data } = binary;\n  const numPixels = width * height;\n\n  // Binary data is already bit-packed (8 pixels per byte, MSB-first)\n  // Convert to packed binary format for GPU (32 pixels per u32)\n  const numWords = Math.ceil(numPixels / 32);\n  const packed = new Uint32Array(numWords);\n\n  for (let i = 0; i < numPixels; i++) {\n    // Read bit from bit-packed data\n    const byteIdx = Math.floor(i / 8);\n    const bitIdx = 7 - (i % 8); // MSB-first\n    const bit = (data[byteIdx] >> bitIdx) & 1;\n\n    if (bit) {\n      const wordIdx = Math.floor(i / 32);\n      const bitInWord = i % 32;\n      packed[wordIdx] |= 1 << bitInWord;\n    }\n  }\n\n  // Create and fill GPU buffer\n  const buffer = createGPUBuffer(\n    device,\n    packed,\n    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n  );\n\n  return buffer;\n}\n\n// Processing mode functions\nasync function startProcessing() {\n  if (!state.currentImage) return;\n\n  try {\n    setMode(\"processing\");\n    state.processedImages.clear();\n    state.processViewInitialized = false; // Reset for new processing session\n\n    // Apply crop if selected\n    let processImage = state.currentImage;\n    if (\n      state.cropRegion && state.cropRegion.width > 0 &&\n      state.cropRegion.height > 0\n    ) {\n      showStatus(\"Cropping image...\");\n      processImage = cropImage(state.currentImage, state.cropRegion);\n    }\n\n    // Store and display cropped image\n    state.processedImages.set(\"cropped\", processImage);\n    displayProcessingStage(\"cropped\");\n\n    // Extract black from cropped image\n    showStatus(\"Extracting black...\");\n    const extractBlackStart = performance.now();\n    const extractedBlack = await extractBlackGPU(processImage, 0.20);\n    const extractBlackEnd = performance.now();\n    showStatus(\n      `Extract black: ${(extractBlackEnd - extractBlackStart).toFixed(1)}ms`,\n    );\n\n    state.processedImages.set(\"extract_black\", extractedBlack);\n    displayProcessingStage(\"extract_black\");\n\n    // Process color_1: median filter and skeletonize\n    const color1Buffer = await binaryToGPUBuffer(extractedBlack);\n    const color1SkelResults = await processValueChannel(\n      color1Buffer,\n      extractedBlack.width,\n      extractedBlack.height,\n    );\n\n    // Store median-filtered version as color_1, skeletonized as color_1_skel\n    state.processedImages.set(\"color_1\", color1SkelResults.median);\n    state.processedImages.set(\"color_1_skel\", color1SkelResults.skeleton);\n\n    color1Buffer.destroy();\n    color1SkelResults.skeletonBuffer.destroy();\n\n    // Apply bloom filter to extracted black\n    showStatus(\"Applying bloom filter...\");\n    const bloomStart = performance.now();\n    const bloomFiltered = await bloomFilter3x3GPU(extractedBlack);\n    const bloomEnd = performance.now();\n    showStatus(`Bloom filter: ${(bloomEnd - bloomStart).toFixed(1)}ms`);\n\n    // Subtract black from cropped image\n    showStatus(\"Subtracting black...\");\n    const subtractStart = performance.now();\n    const subtractedImage = await subtractBlackGPU(processImage, bloomFiltered);\n    const subtractEnd = performance.now();\n    showStatus(`Subtract black: ${(subtractEnd - subtractStart).toFixed(1)}ms`);\n    state.processedImages.set(\"subtract_black\", subtractedImage);\n    displayProcessingStage(\"subtract_black\");\n\n    // Use subtracted image for further processing\n    processImage = subtractedImage;\n\n    // Run GPU pipeline with auto-advance after each stage\n    showStatus(\"Running cleanup (extracting channels)...\");\n    const t1 = performance.now();\n    const cleanupResults = await cleanupGPU(processImage);\n    const t2 = performance.now();\n    showStatus(`Cleanup: ${(t2 - t1).toFixed(1)}ms`);\n\n    // Store all intermediate cleanup stages\n    state.processedImages.set(\"value\", cleanupResults.value);\n    state.processedImages.set(\"saturation\", cleanupResults.saturation);\n    state.processedImages.set(\n      \"saturation_median\",\n      cleanupResults.saturationMedian,\n    );\n    state.processedImages.set(\"hue\", cleanupResults.hue);\n    state.processedImages.set(\"hue_median\", cleanupResults.hueMedian);\n\n    // Recombine with thresholded value (no skeletonization yet)\n    showStatus(\"Recombining channels...\");\n    const t2d = performance.now();\n    const cleanupFinal = await recombineWithValue(\n      cleanupResults.valueBuffer,\n      cleanupResults.saturationBuffer,\n      cleanupResults.hueBuffer,\n      cleanupResults.width,\n      cleanupResults.height,\n    );\n    const t2e = performance.now();\n    showStatus(`Recombine: ${(t2e - t2d).toFixed(1)}ms`);\n    state.processedImages.set(\"cleanup\", cleanupFinal);\n    displayProcessingStage(\"cleanup\");\n\n    // Clean up buffers now that we're done with them\n    cleanupResults.valueBuffer.destroy();\n    cleanupResults.saturationBuffer.destroy();\n    cleanupResults.hueBuffer.destroy();\n\n    showStatus(\"Palettizing...\");\n    const t3 = performance.now();\n    const inputPalette = buildPaletteRGBA(); // Input colors for matching\n    const palettized = await palettizeGPU(cleanupFinal, inputPalette);\n\n    // Replace palette with output colors (after matching is done)\n    const outputPalette = new Uint8ClampedArray(16 * 4);\n    for (let i = 0; i < state.userPalette.length && i < 16; i++) {\n      const color = state.userPalette[i];\n      // Use output color, or background if marked for removal\n      const useColor = color.mapToBg\n        ? state.userPalette[0].outputColor\n        : color.outputColor;\n      const [r, g, b, a] = hexToRGBA(useColor);\n      outputPalette[i * 4] = r;\n      outputPalette[i * 4 + 1] = g;\n      outputPalette[i * 4 + 2] = b;\n      outputPalette[i * 4 + 3] = a;\n    }\n    for (let i = state.userPalette.length; i < 16; i++) {\n      const [r, g, b, a] = hexToRGBA(state.userPalette[0].outputColor);\n      outputPalette[i * 4] = r;\n      outputPalette[i * 4 + 1] = g;\n      outputPalette[i * 4 + 2] = b;\n      outputPalette[i * 4 + 3] = a;\n    }\n\n    // Convert to Uint32Array for palette storage\n    const outputPaletteU32 = new Uint32Array(16);\n    const outputView = new DataView(\n      outputPalette.buffer,\n      outputPalette.byteOffset,\n      outputPalette.byteLength,\n    );\n    for (let i = 0; i < 16; i++) {\n      outputPaletteU32[i] = outputView.getUint32(i * 4, true); // little-endian\n    }\n    palettized.palette = outputPaletteU32;\n\n    const t4 = performance.now();\n    showStatus(`Palettize: ${(t4 - t3).toFixed(1)}ms`);\n    state.processedImages.set(\"palettized\", palettized);\n    displayProcessingStage(\"palettized\");\n\n    // Apply median filter right after palettization (3 passes for aggressive cleaning)\n    showStatus(\"Applying median filter (pass 1/3)...\");\n    const t4b = performance.now();\n    let median = await median3x3GPU(palettized);\n    showStatus(\"Applying median filter (pass 2/3)...\");\n    median = await median3x3GPU(median);\n    showStatus(\"Applying median filter (pass 3/3)...\");\n    median = await median3x3GPU(median);\n    const t4c = performance.now();\n    showStatus(`Median filter (3 passes): ${(t4c - t4b).toFixed(1)}ms`);\n    state.processedImages.set(\"median\", median);\n    displayProcessingStage(\"median\");\n\n    // Process each non-background, non-removed color separately\n    showStatus(\"Processing individual colors...\");\n    const t5 = performance.now();\n    for (let i = 1; i < state.userPalette.length && i < 16; i++) {\n      const color = state.userPalette[i];\n      if (color.mapToBg) continue; // Skip removed colors\n      if (i === 1) continue; // Skip color_1 - already processed as extracted black\n\n      showStatus(`Processing color ${i}...`);\n\n      // Extract this color as binary from median-filtered image\n      const colorBinary = extractColorFromPalettized(median, i);\n      state.processedImages.set(`color_${i}`, colorBinary);\n\n      // Convert to GPU buffer and run skeletonization\n      const colorBuffer = await binaryToGPUBuffer(colorBinary);\n      const skelResults = await processValueChannel(\n        colorBuffer,\n        colorBinary.width,\n        colorBinary.height,\n      );\n\n      // Store skeletonized result\n      state.processedImages.set(`color_${i}_skel`, skelResults.skeleton);\n\n      // Clean up\n      colorBuffer.destroy();\n      skelResults.skeletonBuffer.destroy();\n    }\n    const t6 = performance.now();\n    showStatus(`Per-color processing: ${(t6 - t5).toFixed(1)}ms`);\n\n    // Add dynamic stage buttons for each color\n    addColorStageButtons();\n\n    const totalTime = t6 - t1;\n    showStatus(`\u2713 Pipeline complete! Total: ${totalTime.toFixed(1)}ms`);\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, true);\n    console.error(error);\n  }\n}\n\n// Add dynamic color stage buttons after processing\nfunction addColorStageButtons() {\n  // Clear existing color buttons\n  colorStagesContainer.innerHTML = \"\";\n  vectorOverlayContainer.innerHTML = \"\";\n\n  // Add a button for each non-background, non-removed color\n  for (let i = 1; i < state.userPalette.length && i < 16; i++) {\n    const color = state.userPalette[i];\n    if (color.mapToBg) continue; // Skip removed colors\n\n    // Check if this color stage exists\n    if (!state.processedImages.has(`color_${i}`)) continue;\n\n    // Color button\n    const colorBtn = document.createElement(\"button\");\n    colorBtn.className = \"stage-btn\";\n    colorBtn.textContent = `Color ${i}`;\n    colorBtn.style.borderLeft = `4px solid ${color.outputColor}`;\n    colorBtn.addEventListener(\n      \"click\",\n      () => displayProcessingStage(`color_${i}`),\n    );\n    colorStagesContainer.appendChild(colorBtn);\n\n    // Skeleton button (if it exists)\n    if (state.processedImages.has(`color_${i}_skel`)) {\n      const skelBtn = document.createElement(\"button\");\n      skelBtn.className = \"stage-btn\";\n      skelBtn.textContent = `Color ${i} Skel`;\n      skelBtn.style.borderLeft = `4px solid ${color.outputColor}`;\n      skelBtn.dataset.stage = `color_${i}_skel`;\n      skelBtn.addEventListener(\n        \"click\",\n        () => displayProcessingStage(`color_${i}_skel`),\n      );\n      colorStagesContainer.appendChild(skelBtn);\n\n      // Vector overlay toggle button\n      const vecStage = `color_${i}_vec`;\n      const vecToggle = document.createElement(\"button\");\n      vecToggle.className = \"stage-btn\";\n      vecToggle.textContent = `Color ${i} Vec`;\n      vecToggle.style.borderLeft = `4px solid ${color.outputColor}`;\n      vecToggle.dataset.stage = vecStage;\n      vecToggle.addEventListener(\"click\", () => toggleVectorOverlay(vecStage));\n      vectorOverlayContainer.appendChild(vecToggle);\n    }\n  }\n}\n\nfunction toggleVectorOverlay(vecStage: string) {\n  // If clicking the same overlay, toggle it off\n  if (state.vectorOverlayEnabled && state.vectorOverlayStage === vecStage) {\n    state.vectorOverlayEnabled = false;\n    state.vectorOverlayStage = null;\n    processSvgOverlay.style.display = \"none\";\n    updateVectorOverlayButtons();\n    showStatus(\"Vector overlay hidden\");\n    return;\n  }\n\n  // Check if we need to vectorize\n  let vectorized = state.vectorizedImages.get(vecStage);\n\n  if (!vectorized) {\n    // Vectorize on-demand\n    const skelStage = vecStage.replace(\"_vec\", \"_skel\") as ProcessingStage;\n    const skelImage = state.processedImages.get(skelStage);\n\n    if (!skelImage) {\n      showStatus(`Skeleton stage ${skelStage} not available`, true);\n      return;\n    }\n\n    // Convert skeleton to binary format if needed\n    let binaryImage: BinaryImage;\n    const expectedBinaryLength = Math.ceil(\n      skelImage.width * skelImage.height / 8,\n    );\n\n    if (\n      skelImage.data instanceof Uint8ClampedArray &&\n      skelImage.data.length === skelImage.width * skelImage.height * 4\n    ) {\n      console.log(`Converting ${skelStage} from RGBA to binary format`);\n      binaryImage = rgbaToBinary(skelImage as RGBAImage);\n    } else if (\n      skelImage.data instanceof Uint8Array &&\n      skelImage.data.length === expectedBinaryLength\n    ) {\n      binaryImage = skelImage as BinaryImage;\n    } else {\n      showStatus(`${skelStage} has unexpected format`, true);\n      return;\n    }\n\n    showStatus(`Vectorizing ${skelStage}...`);\n    const vectorizeStart = performance.now();\n    vectorized = vectorizeSkeleton(binaryImage);\n    state.vectorizedImages.set(vecStage, vectorized);\n    const vectorizeEnd = performance.now();\n    const totalPoints = vectorized.paths.reduce(\n      (sum, p) => sum + p.points.length,\n      0,\n    );\n    console.log(\n      `Vectorized: ${vectorized.paths.length} paths, ${totalPoints} points (${\n        (vectorizeEnd - vectorizeStart).toFixed(1)\n      }ms)`,\n    );\n  }\n\n  // Enable overlay\n  state.vectorOverlayEnabled = true;\n  state.vectorOverlayStage = vecStage;\n\n  // Render SVG overlay\n  const currentImage = state.processedImages.get(state.currentStage);\n  if (currentImage) {\n    renderVectorizedToSVG(\n      vectorized,\n      processSvgOverlay,\n      currentImage.width,\n      currentImage.height,\n    );\n    processSvgOverlay.style.display = \"block\";\n  }\n\n  updateVectorOverlayButtons();\n  const totalPoints = vectorized.paths.reduce(\n    (sum, p) => sum + p.points.length,\n    0,\n  );\n  showStatus(\n    `Vector overlay: ${vectorized.paths.length} paths, ${totalPoints} points`,\n  );\n}\n\nfunction updateVectorOverlayButtons() {\n  vectorOverlayContainer.querySelectorAll(\".stage-btn\").forEach((btn) => {\n    const btnStage = (btn as HTMLElement).dataset.stage;\n    if (btnStage === state.vectorOverlayStage && state.vectorOverlayEnabled) {\n      btn.classList.add(\"active\");\n    } else {\n      btn.classList.remove(\"active\");\n    }\n  });\n}\n\nfunction displayProcessingStage(stage: ProcessingStage) {\n  // Check if this is a vectorized stage\n  if (stage.endsWith(\"_vec\")) {\n    // Check if we already have it vectorized\n    let vectorized = state.vectorizedImages.get(stage);\n\n    if (!vectorized) {\n      // Need to vectorize on-demand\n      const skelStage = stage.replace(\"_vec\", \"_skel\") as ProcessingStage;\n      const skelImage = state.processedImages.get(skelStage);\n\n      if (!skelImage) {\n        showStatus(`Skeleton stage ${skelStage} not available`, true);\n        return;\n      }\n\n      // Convert skeleton to binary format if needed\n      let binaryImage: BinaryImage;\n      const expectedBinaryLength = Math.ceil(\n        skelImage.width * skelImage.height / 8,\n      );\n\n      if (\n        skelImage.data instanceof Uint8ClampedArray &&\n        skelImage.data.length === skelImage.width * skelImage.height * 4\n      ) {\n        // RGBA format - convert to binary\n        console.log(`Converting ${skelStage} from RGBA to binary format`);\n        binaryImage = rgbaToBinary(skelImage as RGBAImage);\n      } else if (\n        skelImage.data instanceof Uint8Array &&\n        skelImage.data.length === expectedBinaryLength\n      ) {\n        // Already binary format\n        binaryImage = skelImage as BinaryImage;\n      } else {\n        showStatus(`${skelStage} has unexpected format`, true);\n        console.error(`Unexpected format:`, {\n          dataType: skelImage.data?.constructor?.name,\n          actualLength: skelImage.data.length,\n          expectedRGBA: skelImage.width * skelImage.height * 4,\n          expectedBinary: expectedBinaryLength,\n        });\n        return;\n      }\n\n      // Vectorize now\n      showStatus(`Vectorizing ${skelStage}...`);\n      const vectorizeStart = performance.now();\n      vectorized = vectorizeSkeleton(binaryImage);\n      state.vectorizedImages.set(stage, vectorized);\n      const vectorizeEnd = performance.now();\n      const totalPoints = vectorized.paths.reduce(\n        (sum, p) => sum + p.points.length,\n        0,\n      );\n      showStatus(\n        `Vectorized: ${vectorized.paths.length} paths, ${totalPoints} points (${\n          (vectorizeEnd - vectorizeStart).toFixed(1)\n        }ms)`,\n      );\n    }\n\n    state.currentStage = stage;\n\n    // Update stage button states\n    document.querySelectorAll(\".stage-btn\").forEach((btn) =>\n      btn.classList.remove(\"active\")\n    );\n    const btn = Array.from(document.querySelectorAll(\".stage-btn\")).find(\n      (b) => (b as HTMLElement).dataset.stage === stage,\n    );\n    btn?.classList.add(\"active\");\n\n    // First, display the skeleton image on canvas\n    const skelStage = stage.replace(\"_vec\", \"_skel\") as ProcessingStage;\n    const skelImage = state.processedImages.get(skelStage);\n    if (skelImage) {\n      // Render skeleton to canvas\n      processCanvas.width = skelImage.width;\n      processCanvas.height = skelImage.height;\n\n      // Convert to RGBA for display\n      let rgbaData: Uint8ClampedArray;\n      if (\n        skelImage.data instanceof Uint8ClampedArray &&\n        skelImage.data.length === skelImage.width * skelImage.height * 4\n      ) {\n        rgbaData = skelImage.data;\n      } else {\n        // Convert binary to RGBA\n        const numPixels = skelImage.width * skelImage.height;\n        rgbaData = new Uint8ClampedArray(numPixels * 4);\n        for (let i = 0; i < numPixels; i++) {\n          const byteIndex = Math.floor(i / 8);\n          const bitIndex = 7 - (i % 8);\n          const bit = (skelImage.data[byteIndex] >> bitIndex) & 1;\n          const value = bit ? 0 : 255;\n          rgbaData[i * 4] = value;\n          rgbaData[i * 4 + 1] = value;\n          rgbaData[i * 4 + 2] = value;\n          rgbaData[i * 4 + 3] = 255;\n        }\n      }\n\n      const imageData = new ImageData(\n        rgbaData,\n        skelImage.width,\n        skelImage.height,\n      );\n      processCtx.putImageData(imageData, 0, 0);\n    }\n\n    // Then overlay the vectorized paths as SVG\n    renderVectorizedToSVG(vectorized, processSvgOverlay);\n\n    // Fit to screen on first display\n    if (!state.processViewInitialized) {\n      processFitToScreen();\n      state.processViewInitialized = true;\n    } else {\n      updateProcessTransform();\n    }\n\n    const totalPoints = vectorized.paths.reduce(\n      (sum, p) => sum + p.points.length,\n      0,\n    );\n    showStatus(\n      `Viewing: ${stage} (${vectorized.paths.length} paths, ${totalPoints} points)`,\n    );\n    return;\n  }\n\n  const image = state.processedImages.get(stage);\n  if (!image) {\n    showStatus(`Stage ${stage} not available`, true);\n    return;\n  }\n\n  state.currentStage = stage;\n\n  // Re-render vector overlay if it's enabled (over the new stage)\n  if (state.vectorOverlayEnabled && state.vectorOverlayStage) {\n    const vectorized = state.vectorizedImages.get(state.vectorOverlayStage);\n    if (vectorized) {\n      renderVectorizedToSVG(\n        vectorized,\n        processSvgOverlay,\n        image.width,\n        image.height,\n      );\n      processSvgOverlay.style.display = \"block\";\n    }\n  }\n\n  // Update stage button states\n  document.querySelectorAll(\".stage-btn\").forEach((btn) =>\n    btn.classList.remove(\"active\")\n  );\n\n  // Handle dynamic color stage buttons\n  if (typeof stage === \"string\" && (stage.startsWith(\"color_\"))) {\n    const btn = Array.from(document.querySelectorAll(\".stage-btn\")).find(\n      (b) =>\n        (b as HTMLElement).textContent?.toLowerCase().replace(\" \", \"_\")\n          .includes(stage),\n    );\n    btn?.classList.add(\"active\");\n  } else {\n    // Static stage buttons\n    const stageButtons: Partial<\n      Record<BaseProcessingStage, HTMLButtonElement>\n    > = {\n      cropped: stageCroppedBtn,\n      extract_black: stageExtractBlackBtn,\n      subtract_black: stageSubtractBlackBtn,\n      value: stageValueBtn,\n      saturation: stageSaturationBtn,\n      saturation_median: stageSaturationMedianBtn,\n      hue: stageHueBtn,\n      hue_median: stageHueMedianBtn,\n      cleanup: stageCleanupBtn,\n      palettized: stagePalettizedBtn,\n      median: stageMedianBtn,\n    };\n    const baseStage = stage as BaseProcessingStage;\n    stageButtons[baseStage]?.classList.add(\"active\");\n  }\n\n  // Set up canvas\n  processCanvas.width = image.width;\n  processCanvas.height = image.height;\n\n  // Convert to RGBA for display\n  let rgbaData: Uint8ClampedArray;\n  if (\"palette\" in image && image.palette) {\n    // PalettizedImage - convert indexed colors to RGBA\n    // Palettized format stores 2 pixels per byte: high nibble (left) and low nibble (right)\n    const numPixels = image.width * image.height;\n    rgbaData = new Uint8ClampedArray(numPixels * 4);\n\n    for (let pixelIndex = 0; pixelIndex < numPixels; pixelIndex++) {\n      const byteIndex = Math.floor(pixelIndex / 2);\n      const isHighNibble = pixelIndex % 2 === 0;\n\n      // Extract 4-bit color index from nibble\n      const colorIndex = isHighNibble\n        ? (image.data[byteIndex] >> 4) & 0x0f\n        : image.data[byteIndex] & 0x0f;\n\n      // Look up RGBA color in palette (stored as Uint32Array - need to unpack)\n      const pixelOffset = pixelIndex * 4;\n      const packedColor = image.palette[colorIndex];\n\n      // Unpack RGBA from 32-bit value (little-endian: ABGR)\n      rgbaData[pixelOffset] = packedColor & 0xff; // R\n      rgbaData[pixelOffset + 1] = (packedColor >> 8) & 0xff; // G\n      rgbaData[pixelOffset + 2] = (packedColor >> 16) & 0xff; // B\n      rgbaData[pixelOffset + 3] = (packedColor >> 24) & 0xff; // A\n    }\n  } else if (\n    image.data instanceof Uint8Array &&\n    image.data.length === Math.ceil(image.width * image.height / 8)\n  ) {\n    // BinaryImage - convert bit-packed 1-bit to RGBA (0=white, 1=black)\n    rgbaData = new Uint8ClampedArray(image.width * image.height * 4);\n    for (let y = 0; y < image.height; y++) {\n      for (let x = 0; x < image.width; x++) {\n        const pixelIndex = y * image.width + x;\n        const byteIndex = Math.floor(pixelIndex / 8);\n        const bitIndex = 7 - (pixelIndex % 8); // MSB-first\n        const bitValue = (image.data[byteIndex] >> bitIndex) & 1;\n        const value = bitValue ? 0 : 255; // 1=black, 0=white\n        const offset = pixelIndex * 4;\n        rgbaData[offset] = value;\n        rgbaData[offset + 1] = value;\n        rgbaData[offset + 2] = value;\n        rgbaData[offset + 3] = 255;\n      }\n    }\n  } else {\n    // RGBAImage - use directly\n    rgbaData = new Uint8ClampedArray(image.data);\n  }\n\n  // Draw image - ensure it's a proper Uint8ClampedArray with ArrayBuffer\n  const displayData = new Uint8ClampedArray(rgbaData);\n  const imageData = new ImageData(\n    displayData,\n    image.width,\n    image.height,\n  );\n  processCtx.putImageData(imageData, 0, 0);\n\n  // Only fit to screen on first display, then preserve state.zoom/pan\n  if (!state.processViewInitialized) {\n    processFitToScreen();\n    state.processViewInitialized = true;\n  } else {\n    updateProcessTransform();\n  }\n\n  showStatus(`Viewing: ${stage} (${image.width}\u00D7${image.height})`);\n}\n\nfunction processFitToScreen() {\n  // Get dimensions from either processed image or vectorized image\n  let imageWidth = 0, imageHeight = 0;\n  const image = state.processedImages.get(state.currentStage);\n  if (image) {\n    imageWidth = image.width;\n    imageHeight = image.height;\n  } else if (state.currentStage.endsWith(\"_vec\")) {\n    const vectorized = state.vectorizedImages.get(state.currentStage);\n    if (vectorized) {\n      imageWidth = vectorized.width;\n      imageHeight = vectorized.height;\n    }\n  }\n\n  if (imageWidth === 0 || imageHeight === 0) return;\n\n  const containerWidth = processCanvasContainer.clientWidth;\n  const containerHeight = processCanvasContainer.clientHeight;\n\n  const scaleX = containerWidth / imageWidth;\n  const scaleY = containerHeight / imageHeight;\n  state.processZoom = Math.min(scaleX, scaleY) * 0.9;\n\n  state.processPanX = (containerWidth - imageWidth * state.processZoom) / 2;\n  state.processPanY = (containerHeight - imageHeight * state.processZoom) / 2;\n\n  updateProcessZoom();\n  updateProcessTransform();\n}\n\nfunction updateProcessZoom() {\n  processZoomLevel.textContent = `${Math.round(state.processZoom * 100)}%`;\n}\n\nfunction updateProcessTransform() {\n  const transform =\n    `translate(${state.processPanX}px, ${state.processPanY}px) scale(${state.processZoom})`;\n  processCanvas.style.transform = transform;\n  processCanvas.style.transformOrigin = \"0 0\";\n  processCanvas.style.willChange = \"transform\";\n\n  // Apply same transform to SVG overlay\n  processSvgOverlay.style.transform = transform;\n  processSvgOverlay.style.transformOrigin = \"0 0\";\n  processSvgOverlay.style.willChange = \"transform\";\n\n  if (state.processZoom >= 1) {\n    processCanvas.style.imageRendering = \"pixelated\";\n  } else {\n    processCanvas.style.imageRendering = \"auto\";\n  }\n}\n\nfunction _displayResult(image: RGBAImage, label: string) {\n  const item = document.createElement(\"div\");\n  item.className = \"result-item\";\n\n  const title = document.createElement(\"h3\");\n  title.textContent = label;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = image.width;\n  canvas.height = image.height;\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    const imageData = new ImageData(\n      new Uint8ClampedArray(image.data),\n      image.width,\n      image.height,\n    );\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  const img = document.createElement(\"img\");\n  img.src = canvas.toDataURL();\n\n  item.appendChild(title);\n  item.appendChild(img);\n  resultsContainer.appendChild(item);\n}\n\nfunction generateThumbnail(image: RGBAImage): string {\n  const maxSize = 128; // Increased for better quality\n  const scale = Math.min(maxSize / image.width, maxSize / image.height);\n  const thumbWidth = Math.floor(image.width * scale);\n  const thumbHeight = Math.floor(image.height * scale);\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = thumbWidth;\n  canvas.height = thumbHeight;\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return \"\";\n\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.width = image.width;\n  tempCanvas.height = image.height;\n  const tempCtx = tempCanvas.getContext(\"2d\");\n  if (!tempCtx) return \"\";\n\n  const imageData = new ImageData(\n    new Uint8ClampedArray(image.data),\n    image.width,\n    image.height,\n  );\n  tempCtx.putImageData(imageData, 0, 0);\n\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = \"high\";\n  ctx.drawImage(tempCanvas, 0, 0, thumbWidth, thumbHeight);\n\n  return canvas.toDataURL(\"image/png\");\n}\n\n// File list management\nasync function refreshFileList() {\n  const files = await listFiles();\n\n  console.log(`Refreshing file list: ${files.length} files`);\n\n  if (files.length === 0) {\n    uploadFileList.innerHTML = `\n      <div class=\"upload-empty\">\n        <div>\uD83D\uDCC1</div>\n        <div>No files yet</div>\n      </div>\n    `;\n    return;\n  }\n\n  uploadFileList.innerHTML = `<div class=\"files-grid\"></div>`;\n  const filesGrid = uploadFileList.querySelector(\n    \".files-grid\",\n  ) as HTMLDivElement;\n\n  for (const file of files) {\n    const item = document.createElement(\"div\");\n    item.className = \"file-card\";\n    if (file.id === state.currentFileId) {\n      item.classList.add(\"active\");\n    }\n\n    const thumbnail = document.createElement(\"div\");\n    thumbnail.className = \"file-thumbnail\";\n    if (file.thumbnail) {\n      const img = document.createElement(\"img\");\n      img.src = file.thumbnail;\n      thumbnail.appendChild(img);\n    } else {\n      thumbnail.textContent = file.type.includes(\"pdf\") ? \"\uD83D\uDCC4\" : \"\uD83D\uDDBC\uFE0F\";\n    }\n\n    const info = document.createElement(\"div\");\n    info.className = \"file-info\";\n\n    const name = document.createElement(\"div\");\n    name.className = \"file-name\";\n    name.textContent = file.name;\n    name.title = file.name;\n\n    const meta = document.createElement(\"div\");\n    meta.className = \"file-meta\";\n    const date = new Date(file.uploadedAt);\n    const size = (file.data.length / 1024).toFixed(0);\n    meta.textContent = `${size} KB \u2022 ${date.toLocaleDateString()}`;\n\n    info.appendChild(name);\n    info.appendChild(meta);\n\n    const deleteBtn = document.createElement(\"button\");\n    deleteBtn.className = \"file-delete\";\n    deleteBtn.textContent = \"\u00D7\";\n    deleteBtn.title = \"Delete file\";\n    deleteBtn.onclick = async (e) => {\n      e.stopPropagation();\n      if (confirm(`Delete ${file.name}?`)) {\n        await deleteFile(file.id);\n        if (file.id === state.currentFileId) {\n          state.currentFileId = null;\n          state.currentPdfData = null;\n          state.currentImage = null;\n          setMode(\"upload\");\n        }\n        await refreshFileList();\n        showStatus(`Deleted ${file.name}`);\n      }\n    };\n\n    item.appendChild(thumbnail);\n    item.appendChild(info);\n    item.appendChild(deleteBtn);\n\n    item.onclick = () => loadStoredFile(file.id);\n\n    filesGrid.appendChild(item);\n  }\n}\n\nasync function loadStoredFile(id: string) {\n  showStatus(\"\u23F3 Loading file...\");\n\n  const stored = await getFile(id);\n  if (!stored) {\n    showStatus(\"File not found\", true);\n    return;\n  }\n\n  state.currentFileId = id;\n\n  // Restore palette if saved, otherwise load default\n  if (stored.palette) {\n    try {\n      const savedPalette = JSON.parse(stored.palette);\n      state.userPalette.length = 0;\n      state.userPalette.push(...savedPalette);\n      renderPaletteUI();\n      console.log(\"Restored saved palette with\", savedPalette.length, \"colors\");\n    } catch (err) {\n      console.error(\"Failed to restore palette:\", err);\n      await loadDefaultPalette();\n    }\n  } else {\n    // No saved palette, load default\n    await loadDefaultPalette();\n  }\n\n  const data = new Uint8Array(stored.data);\n  const blob = new Blob([data], { type: stored.type });\n  const file = new File([blob], stored.name, { type: stored.type });\n\n  await refreshFileList();\n  await handleFileUpload(file);\n}\n\n// Palette Editor Functions\n\n// Color Editor Panel - opens when clicking a palette color\n\n// Convert state.userPalette to RGBA format for GPU processing\n\n// Palette editor event handlers\nconsole.log(\"Setting up palette event listeners...\");\nif (addPaletteColorBtn) {\n  addPaletteColorBtn.addEventListener(\"click\", () => {\n    console.log(\"Add button clicked!\");\n    addPaletteColor();\n  });\n} else {\n  console.error(\"addPaletteColorBtn not found!\");\n}\n\nif (resetPaletteBtn) {\n  resetPaletteBtn.addEventListener(\"click\", () => {\n    console.log(\"Reset button clicked!\");\n    resetPaletteToDefault();\n  });\n} else {\n  console.error(\"resetPaletteBtn not found!\");\n}\n\nif (savePaletteBtn) {\n  savePaletteBtn.addEventListener(\"click\", () => {\n    const name = paletteName.value;\n    savePalette(name);\n  });\n}\n\nif (loadPaletteBtn) {\n  loadPaletteBtn.addEventListener(\"click\", () => {\n    loadPalette();\n  });\n}\n\nif (setDefaultPaletteBtn) {\n  setDefaultPaletteBtn.addEventListener(\"click\", () => {\n    setDefaultPalette();\n  });\n}\n\n// Canvas click handler for eyedropper\nmainCanvas.addEventListener(\"click\", (e: MouseEvent) => {\n  if (isEyedropperActive()) {\n    pickColorFromCanvas(e.clientX, e.clientY);\n  }\n});\n\n// ESC key to cancel eyedropper\ndocument.addEventListener(\"keydown\", (e: KeyboardEvent) => {\n  if (e.key === \"Escape\" && isEyedropperActive()) {\n    forceDeactivateEyedropper();\n  }\n});\n\n// Initialize palette UI on load\nrenderPaletteUI();\n"],
  "mappings": "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",
  "names": ["ctx", "pdfjsLib", "shaderCode", "shaderCode", "shaderCode", "shaderCode", "db", "db", "extractSegmentPoints", "i", "canvasContainer", "mainCanvas", "ctx", "cropOverlay", "cropCtx", "zoomLevel", "cropInfo", "totalPoints", "skelStage", "skelImage", "btn", "rgbaData", "imageData", "ctx", "mainCanvas"]
}
