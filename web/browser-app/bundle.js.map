{
  "version": 3,
  "sources": ["../src/pdf/image_load.ts", "../src/pdf/pdf_render.ts", "../src/gpu/gpu_context.ts", "../src/gpu/cleanup_gpu.ts", "../src/gpu/value_process_gpu.ts", "../src/gpu/palettize_gpu.ts", "../src/formats/palettized.ts", "../src/gpu/median_gpu.ts", "../src/gpu/extract_black_gpu.ts", "../src/gpu/bloom_gpu.ts", "../src/gpu/subtract_black_gpu.ts", "storage.ts", "utils.ts", "state.ts", "canvas.ts", "palette.ts", "../src/formats/binary.ts", "../src/vectorize/tracer.ts", "../src/vectorize/geometry.ts", "../src/vectorize/optimizer.ts", "../src/vectorize/line_fit.ts", "../src/vectorize/arc_fit.ts", "../src/vectorize/simplifier.ts", "vectorize.ts", "main.ts"],
  "sourcesContent": ["/**\r\n * Load image from File object in browser\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\n\r\nexport function loadImageFromFile(file: File): Promise<RGBAImage> {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        \r\n        img.onload = () => {\r\n            // Create canvas to extract pixel data\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            \r\n            const ctx = canvas.getContext(\"2d\");\r\n            if (!ctx) {\r\n                reject(new Error(\"Could not get 2D context\"));\r\n                return;\r\n            }\r\n            \r\n            // Draw image\r\n            ctx.drawImage(img, 0, 0);\r\n            \r\n            // Extract pixel data\r\n            const imageData = ctx.getImageData(0, 0, img.width, img.height);\r\n            \r\n            resolve({\r\n                width: img.width,\r\n                height: img.height,\r\n                data: new Uint8ClampedArray(imageData.data),\r\n            });\r\n            \r\n            // Clean up\r\n            URL.revokeObjectURL(img.src);\r\n        };\r\n        \r\n        img.onerror = () => {\r\n            reject(new Error(\"Failed to load image\"));\r\n            URL.revokeObjectURL(img.src);\r\n        };\r\n        \r\n        // Create object URL and load\r\n        img.src = URL.createObjectURL(file);\r\n    });\r\n}\r\n", "import type { RGBAImage } from \"../formats/rgba_image.ts\";\r\n\r\n/**\r\n * Canvas backend interface\r\n * Allows for different implementations in browser vs Deno\r\n */\r\nexport interface CanvasBackend {\r\n  createCanvas(width: number, height: number): CanvasLike;\r\n}\r\n\r\n/**\r\n * Minimal canvas interface needed for PDF rendering\r\n */\r\nexport interface CanvasLike {\r\n  width: number;\r\n  height: number;\r\n  getContext(contextId: \"2d\"): CanvasRenderingContext2DLike | null;\r\n}\r\n\r\n/**\r\n * Minimal 2D context interface\r\n */\r\nexport interface CanvasRenderingContext2DLike {\r\n  getImageData(\r\n    sx: number,\r\n    sy: number,\r\n    sw: number,\r\n    sh: number,\r\n  ): ImageDataLike;\r\n  putImageData(imageData: ImageDataLike, dx: number, dy: number): void;\r\n  drawImage(image: unknown, dx: number, dy: number): void;\r\n}\r\n\r\n/**\r\n * Minimal ImageData interface\r\n */\r\nexport interface ImageDataLike {\r\n  width: number;\r\n  height: number;\r\n  data: Uint8ClampedArray;\r\n}\r\n\r\n/**\r\n * PDF rendering options\r\n */\r\nexport interface PDFRenderOptions {\r\n  file: ArrayBuffer | Uint8Array;\r\n  pageNumber: number;\r\n  dpi?: number;\r\n  scale?: number;\r\n}\r\n\r\n/**\r\n * Render a PDF page to an RGBA image\r\n * Uses the provided canvas backend (browser or Deno)\r\n */\r\nexport async function renderPdfPage(\r\n  options: PDFRenderOptions,\r\n  backend: CanvasBackend,\r\n  pdfjsLib: any,\r\n): Promise<RGBAImage> {\r\n  const { file, pageNumber, scale = 2.0 } = options;\r\n\r\n  // Load PDF document\r\n  const loadingTask = pdfjsLib.getDocument({ data: file });\r\n  const pdf = await loadingTask.promise;\r\n\r\n  if (pageNumber < 1 || pageNumber > pdf.numPages) {\r\n    throw new Error(\r\n      `Page ${pageNumber} out of range (1-${pdf.numPages})`,\r\n    );\r\n  }\r\n\r\n  // Get page\r\n  const page = await pdf.getPage(pageNumber);\r\n  const viewport = page.getViewport({ scale });\r\n\r\n  // Create canvas\r\n  const canvas = backend.createCanvas(viewport.width, viewport.height);\r\n  const context = canvas.getContext(\"2d\");\r\n\r\n  if (!context) {\r\n    throw new Error(\"Failed to get 2D context\");\r\n  }\r\n\r\n  // Render page to canvas\r\n  await page.render({\r\n    canvasContext: context,\r\n    viewport: viewport,\r\n  }).promise;\r\n\r\n  // Extract image data\r\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n  return {\r\n    width: imageData.width,\r\n    height: imageData.height,\r\n    data: imageData.data,\r\n  };\r\n}\r\n", "/**\r\n * WebGPU context management\r\n * Shared between browser and Deno\r\n */\r\n\r\n// Extend Navigator interface for WebGPU support\r\ndeclare global {\r\n    interface Navigator {\r\n        gpu?: GPU;\r\n    }\r\n}\r\n\r\nexport interface GPUContext {\r\n    device: GPUDevice;\r\n    adapter: GPUAdapter;\r\n}\r\n\r\nlet cachedContext: GPUContext | null = null;\r\nlet isInitializing = false;\r\nlet initPromise: Promise<GPUContext> | null = null;\r\n\r\n/**\r\n * Initialize WebGPU context (works in both browser and Deno)\r\n * Caches context and pipelines for reuse\r\n */\r\nexport async function getGPUContext(): Promise<GPUContext> {\r\n    if (cachedContext) {\r\n        return cachedContext;\r\n    }\r\n\r\n    // Prevent multiple simultaneous initializations\r\n    if (isInitializing && initPromise) {\r\n        return initPromise;\r\n    }\r\n\r\n    isInitializing = true;\r\n    initPromise = (async () => {\r\n        if (!navigator.gpu) {\r\n            throw new Error(\"WebGPU not supported in this environment\");\r\n        }\r\n\r\n        const adapter = await navigator.gpu.requestAdapter();\r\n        if (!adapter) {\r\n            throw new Error(\"No WebGPU adapter found\");\r\n        }\r\n\r\n        const device = await adapter.requestDevice();\r\n        \r\n        // Set up error handling\r\n        device.addEventListener('uncapturederror', (event: Event) => {\r\n            const gpuEvent = event as GPUUncapturedErrorEvent;\r\n            console.error('WebGPU uncaptured error:');\r\n            console.error('  Type:', gpuEvent.error.constructor.name);\r\n            console.error('  Message:', gpuEvent.error.message);\r\n            console.error('  Full error:', gpuEvent.error);\r\n        });\r\n        \r\n        // Log adapter limits for debugging\r\n        console.log(\"WebGPU Adapter Limits:\");\r\n        console.log(`  maxStorageBufferBindingSize: ${adapter.limits.maxStorageBufferBindingSize}`);\r\n        console.log(`  maxBufferSize: ${adapter.limits.maxBufferSize}`);\r\n        console.log(`  maxComputeWorkgroupStorageSize: ${adapter.limits.maxComputeWorkgroupStorageSize}`);\r\n        console.log(`  maxComputeInvocationsPerWorkgroup: ${adapter.limits.maxComputeInvocationsPerWorkgroup}`);\r\n        console.log(`  maxComputeWorkgroupsPerDimension: ${adapter.limits.maxComputeWorkgroupsPerDimension}`);\r\n        console.log(`  maxComputeWorkgroupSizeX: ${adapter.limits.maxComputeWorkgroupSizeX}`);\r\n        console.log(`  maxComputeWorkgroupSizeY: ${adapter.limits.maxComputeWorkgroupSizeY}`);\r\n        console.log(`  maxComputeWorkgroupSizeZ: ${adapter.limits.maxComputeWorkgroupSizeZ}`);\r\n        \r\n        cachedContext = { device, adapter };\r\n        isInitializing = false;\r\n        return cachedContext;\r\n    })();\r\n\r\n    return await initPromise;\r\n}\r\n\r\n/**\r\n * Create a GPU buffer from typed array data\r\n */\r\nexport function createGPUBuffer(\r\n    device: GPUDevice,\r\n    data: Uint8Array | Uint32Array | Float32Array,\r\n    usage: GPUBufferUsageFlags,\r\n): GPUBuffer {\r\n    const buffer = device.createBuffer({\r\n        size: data.byteLength,\r\n        usage,\r\n        mappedAtCreation: true,\r\n    });\r\n    \r\n    const arrayBuffer = buffer.getMappedRange();\r\n    if (data instanceof Uint8Array) {\r\n        new Uint8Array(arrayBuffer).set(data);\r\n    } else if (data instanceof Uint32Array) {\r\n        new Uint32Array(arrayBuffer).set(data);\r\n    } else {\r\n        new Float32Array(arrayBuffer).set(data);\r\n    }\r\n    buffer.unmap();\r\n    \r\n    return buffer;\r\n}\r\n\r\n/**\r\n * Read data back from GPU buffer\r\n */\r\nexport async function readGPUBuffer(\r\n    device: GPUDevice,\r\n    buffer: GPUBuffer,\r\n    size: number,\r\n): Promise<Uint8Array> {\r\n    const readBuffer = device.createBuffer({\r\n        size,\r\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n\r\n    const commandEncoder = device.createCommandEncoder();\r\n    commandEncoder.copyBufferToBuffer(buffer, 0, readBuffer, 0, size);\r\n    device.queue.submit([commandEncoder.finish()]);\r\n\r\n    await readBuffer.mapAsync(GPUMapMode.READ);\r\n    const data = new Uint8Array(readBuffer.getMappedRange()).slice();\r\n    readBuffer.unmap();\r\n    readBuffer.destroy();\r\n\r\n    return data;\r\n}\r\n", "/**\r\n * WebGPU cleanup operation\r\n * Handles JPEG compression noise by processing channels separately:\r\n * 1. Calculate value (min(R,G,B)) for background vs lines\r\n * 2. Calculate saturation (max(R,G,B) - min(R,G,B))\r\n * 3. Threshold value at 50%\r\n * 4. Median filter on saturation (3x3)\r\n * 5. Extract hue and median filter it (3x3)\r\n * 6. Recombine into RGB\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\n// Step 1: Extract value, saturation, and hue channels\r\nconst extractChannelsShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> value_out: array<f32>;\r\n@group(0) @binding(2) var<storage, read_write> saturation_out: array<f32>;\r\n@group(0) @binding(3) var<storage, read_write> hue_out: array<f32>;\r\n@group(0) @binding(4) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let pixel = input[pixel_idx];\r\n    \r\n    // Extract RGBA bytes (little-endian: byte 0=R, 1=G, 2=B, 3=A)\r\n    // But when stored as u32 in GPU buffer from RGBA bytes:\r\n    // GPU sees it as: A|B|G|R (bytes 3|2|1|0 in memory become 0|1|2|3 in u32)\r\n    let r = f32((pixel >> 0u) & 0xFFu) / 255.0;\r\n    let g = f32((pixel >> 8u) & 0xFFu) / 255.0;\r\n    let b = f32((pixel >> 16u) & 0xFFu) / 255.0;\r\n    \r\n    // Calculate min and max for HSV\r\n    let min_rgb = min(min(r, g), b);\r\n    let max_rgb = max(max(r, g), b);\r\n    let delta = max_rgb - min_rgb;\r\n    \r\n    // Value = min(R,G,B) - gives 1.0 for white, 0.0 for black/colors\r\n    value_out[pixel_idx] = min_rgb;\r\n    \r\n    // Saturation = max(R,G,B) - min(R,G,B) - gives 0.0 for grayscale, higher for saturated\r\n    saturation_out[pixel_idx] = delta;\r\n    \r\n    // Hue calculation\r\n    var h: f32 = -1.0;\r\n    if (delta > 0.1) {\r\n        if (max_rgb == r) {\r\n            h = ((g - b) / delta) / 6.0;\r\n            if (h < 0.0) {\r\n                h = h + 1.0;\r\n            }\r\n        } else if (max_rgb == g) {\r\n            h = ((b - r) / delta + 2.0) / 6.0;\r\n        } else {\r\n            h = ((r - g) / delta + 4.0) / 6.0;\r\n        }\r\n    }\r\n    hue_out[pixel_idx] = h; // Store hue as 0.0 to 1.0\r\n}\r\n`;\r\n\r\n// Step 2: Threshold value channel to packed binary format\r\n// Output: 1 = line (signal), 0 = background\r\nconst thresholdShader = `\r\n@group(0) @binding(0) var<storage, read> value_in: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> value_out: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    threshold: f32,\r\n    _padding: f32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let value = value_in[pixel_idx];\r\n    \r\n    // Binary threshold: 1 = line (dark), 0 = background (light)\r\n    // Inverted from original: value < threshold means it's dark (a line)\r\n    if (value < params.threshold) {\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&value_out[word_idx], 1u << bit_idx);\r\n    }\r\n}\r\n`;\r\n\r\n// Step 3: 3x3 Median filter for saturation and hue\r\nconst medianFilterShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<f32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Sorting network for 9 elements (median filter)\r\nfn median9(v: array<f32, 9>) -> f32 {\r\n    var arr = v;\r\n    \r\n    // Simple bubble sort for median (good enough for 9 elements)\r\n    for (var i = 0u; i < 9u; i = i + 1u) {\r\n        for (var j = 0u; j < 8u - i; j = j + 1u) {\r\n            if (arr[j] > arr[j + 1u]) {\r\n                let temp = arr[j];\r\n                arr[j] = arr[j + 1u];\r\n                arr[j + 1u] = temp;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return arr[4]; // Middle element\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let w = i32(params.width);\r\n    let h = i32(params.height);\r\n    let ix = i32(x);\r\n    let iy = i32(y);\r\n    \r\n    var values: array<f32, 9>;\r\n    var idx = 0u;\r\n    \r\n    // Gather 3x3 neighborhood\r\n    for (var dy = -1; dy <= 1; dy = dy + 1) {\r\n        for (var dx = -1; dx <= 1; dx = dx + 1) {\r\n            let nx = clamp(ix + dx, 0, w - 1);\r\n            let ny = clamp(iy + dy, 0, h - 1);\r\n            values[idx] = input[u32(ny) * params.width + u32(nx)];\r\n            idx = idx + 1u;\r\n        }\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    output[pixel_idx] = median9(values);\r\n}\r\n`;\r\n\r\n// Step 4: Recombine channels into RGB\r\n// Value input is packed binary: 1 = line, 0 = background\r\nconst recombineShader = `\r\n@group(0) @binding(0) var<storage, read> value_in: array<u32>;\r\n@group(0) @binding(1) var<storage, read> saturation_in: array<f32>;\r\n@group(0) @binding(2) var<storage, read> hue_in: array<f32>;\r\n@group(0) @binding(3) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(4) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Convert HSV to RGB\r\nfn hsv_to_rgb(h: f32, s: f32, v: f32) -> vec3<f32> {\r\n    if (h < 0 || s < 0.1) {\r\n        // Grayscale\r\n        return vec3<f32>(v, v, v);\r\n    }\r\n    \r\n    let h6 = h * 6.0;\r\n    let sector = u32(floor(h6));\r\n    let frac = h6 - f32(sector);\r\n    \r\n    let p = v * (1.0 - s);\r\n    let q = v * (1.0 - s * frac);\r\n    let t = v * (1.0 - s * (1.0 - frac));\r\n    \r\n    switch (sector % 6u) {\r\n        case 0u: { return vec3<f32>(v, t, p); }\r\n        case 1u: { return vec3<f32>(q, v, p); }\r\n        case 2u: { return vec3<f32>(p, v, t); }\r\n        case 3u: { return vec3<f32>(p, q, v); }\r\n        case 4u: { return vec3<f32>(t, p, v); }\r\n        default: { return vec3<f32>(v, p, q); }\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    \r\n    // Read packed binary value: 1 = line, 0 = background\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    let value_bit = (value_in[word_idx] >> bit_idx) & 1u;\r\n    \r\n    let saturation = saturation_in[pixel_idx]; // Cleaned saturation\r\n    let hue = hue_in[pixel_idx]; // Cleaned hue\r\n    \r\n    // For background pixels (value_bit = 0), output white\r\n    // For line pixels (value_bit = 1), reconstruct color from cleaned hue and saturation\r\n    var rgb: vec3<f32>;\r\n    if (value_bit == 0u) {\r\n        // Background - output white\r\n        rgb = vec3<f32>(1.0, 1.0, 1.0);\r\n    } else {\r\n        // Line - reconstruct color with full brightness\r\n        // Use saturation and hue to rebuild the color\r\n        if (saturation < 0.1 || hue < 0.0) {\r\n            // Grayscale line - output black\r\n            rgb = vec3<f32>(0.0, 0.0, 0.0);\r\n        } else {\r\n            // Colored line - reconstruct from HSV with V=1.0 for full brightness\r\n            rgb = hsv_to_rgb(hue, 1.0, 1.0);\r\n        }\r\n    }\r\n    \r\n    let r = u32(clamp(rgb.x * 255.0, 0.0, 255.0));\r\n    let g = u32(clamp(rgb.y * 255.0, 0.0, 255.0));\r\n    let b = u32(clamp(rgb.z * 255.0, 0.0, 255.0));\r\n    let a = 255u;\r\n    \r\n    output[pixel_idx] = r | (g << 8u) | (b << 16u) | (a << 24u);\r\n}\r\n`;\r\n\r\n// Helper: Convert single channel (f32) to grayscale RGBA\r\nconst channelToGrayscaleShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let value = input[pixel_idx];\r\n    \r\n    let gray = u32(clamp(value * 255.0, 0.0, 255.0));\r\n    output[pixel_idx] = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\n// Helper: Convert binary u32 to grayscale RGBA\r\nconst binaryToGrayscaleShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    let bit = (input[word_idx] >> bit_idx) & 1u;\r\n    \r\n    // 1 = line (black), 0 = background (white)\r\n    let gray = (1u - bit) * 255u;\r\n    output[pixel_idx] = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\n// Helper: Convert hue channel to RGB for visualization\r\nconst hueToRGBShader = `\r\n@group(0) @binding(0) var<storage, read> hue_in: array<f32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\nfn hsv_to_rgb(h: f32, s: f32, v: f32) -> vec3<f32> {\r\n    if (h < 0 || s < 0.1) {\r\n        // Grayscale\r\n        return vec3<f32>(v, v, v);\r\n    }\r\n\r\n    let h6 = h * 6.0;\r\n    let sector = u32(floor(h6));\r\n    let frac = h6 - f32(sector);\r\n    \r\n    let p = v * (1.0 - s);\r\n    let q = v * (1.0 - s * frac);\r\n    let t = v * (1.0 - s * (1.0 - frac));\r\n    \r\n    switch (sector % 6u) {\r\n        case 0u: { return vec3<f32>(v, t, p); }\r\n        case 1u: { return vec3<f32>(q, v, p); }\r\n        case 2u: { return vec3<f32>(p, v, t); }\r\n        case 3u: { return vec3<f32>(p, q, v); }\r\n        case 4u: { return vec3<f32>(t, p, v); }\r\n        default: { return vec3<f32>(v, p, q); }\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let hue = hue_in[pixel_idx];\r\n    \r\n    // Convert hue to RGB with full saturation and value for visualization\r\n    let rgb = hsv_to_rgb(hue, 1.0, 1.0);\r\n    \r\n    let r = u32(clamp(rgb.x * 255.0, 0.0, 255.0));\r\n    let g = u32(clamp(rgb.y * 255.0, 0.0, 255.0));\r\n    let b = u32(clamp(rgb.z * 255.0, 0.0, 255.0));\r\n    \r\n    output[pixel_idx] = r | (g << 8u) | (b << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\nexport interface CleanupResults {\r\n    value: RGBAImage;              // Thresholded value channel (visualized)\r\n    saturation: RGBAImage;         // Raw saturation channel\r\n    saturationMedian: RGBAImage;   // Median-filtered saturation\r\n    hue: RGBAImage;                // Raw hue channel\r\n    hueMedian: RGBAImage;          // Median-filtered hue\r\n    final: RGBAImage;              // Final recombined result\r\n    valueBuffer: GPUBuffer;        // Binary value buffer (u32 array: 0=line, 1=bg)\r\n    saturationBuffer: GPUBuffer;   // Median-filtered saturation buffer (f32)\r\n    hueBuffer: GPUBuffer;          // Median-filtered hue buffer (f32)\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n/**\r\n * Apply cleanup filter using multi-pass WebGPU pipeline\r\n * Returns all intermediate channel visualizations\r\n */\r\nexport async function cleanupGPU(image: RGBAImage): Promise<CleanupResults> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    const byteSize = pixelCount * 4;\r\n    const floatByteSize = pixelCount * 4; // f32 arrays\r\n    const binaryWordCount = Math.ceil(pixelCount / 32);  // Pack 32 pixels per u32\r\n    const binaryByteSize = binaryWordCount * 4;\r\n    \r\n    console.log(`Cleanup: ${width}x${height}, ${pixelCount} pixels, data.length=${data.length}, expected=${byteSize}`);\r\n    \r\n    // Create input buffer - data should be RGBA bytes (4 per pixel)\r\n    // Shader will read as array<u32> where each u32 contains one RGBA pixel\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(data.buffer, data.byteOffset, data.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create channel buffers\r\n    const valueBuffer1 = device.createBuffer({\r\n        size: floatByteSize,  // f32\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const valueBuffer2 = device.createBuffer({\r\n        size: binaryByteSize,  // Packed binary format\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    const saturationBuffer1 = device.createBuffer({\r\n        size: floatByteSize,  // f32\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const saturationBuffer2 = device.createBuffer({\r\n        size: floatByteSize,\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const hueBuffer1 = device.createBuffer({\r\n        size: floatByteSize,\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const hueBuffer2 = device.createBuffer({\r\n        size: floatByteSize,\r\n        usage: GPUBufferUsage.STORAGE,\r\n    });\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffers\r\n    const extractParams = new Uint32Array([width, height]);\r\n    const extractParamsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(extractParamsBuffer, 0, extractParams);\r\n    \r\n    // Threshold params: u32 width, u32 height, f32 threshold, f32 padding\r\n    const thresholdParamsBuffer = device.createBuffer({\r\n        size: 16,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    const thresholdParamsArray = new ArrayBuffer(16);\r\n    const thresholdParamsU32 = new Uint32Array(thresholdParamsArray);\r\n    const thresholdParamsF32 = new Float32Array(thresholdParamsArray);\r\n    thresholdParamsU32[0] = width;   // u32\r\n    thresholdParamsU32[1] = height;  // u32\r\n    thresholdParamsF32[2] = 0.5;     // f32 threshold (50%)\r\n    thresholdParamsF32[3] = 0.0;     // f32 padding\r\n    device.queue.writeBuffer(thresholdParamsBuffer, 0, thresholdParamsArray);\r\n    \r\n    const medianParams = new Uint32Array([width, height]);\r\n    const medianParamsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(medianParamsBuffer, 0, medianParams);\r\n    \r\n    // Create shader modules\r\n    const extractModule = device.createShaderModule({ code: extractChannelsShader });\r\n    const thresholdModule = device.createShaderModule({ code: thresholdShader });\r\n    const medianModule = device.createShaderModule({ code: medianFilterShader });\r\n    const recombineModule = device.createShaderModule({ code: recombineShader });\r\n    \r\n    // Create pipelines\r\n    const extractPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: extractModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const thresholdPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: thresholdModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const medianPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: medianModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const recombinePipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: recombineModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const workgroupsX = Math.ceil(width / 8);\r\n    const workgroupsY = Math.ceil(height / 8);\r\n    \r\n    // Pass 1: Extract channels\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: extractPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: inputBuffer } },\r\n                { binding: 1, resource: { buffer: valueBuffer1 } },\r\n                { binding: 2, resource: { buffer: saturationBuffer1 } },\r\n                { binding: 3, resource: { buffer: hueBuffer1 } },\r\n                { binding: 4, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(extractPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Clear valueBuffer2 before threshold pass (atomic operations require starting at 0)\r\n    device.queue.writeBuffer(valueBuffer2, 0, new Uint32Array(binaryWordCount));\r\n    \r\n    // Pass 2: Threshold value channel\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: thresholdPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer1 } },\r\n                { binding: 1, resource: { buffer: valueBuffer2 } },\r\n                { binding: 2, resource: { buffer: thresholdParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(thresholdPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 3: Median filter on saturation\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: medianPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: saturationBuffer1 } },\r\n                { binding: 1, resource: { buffer: saturationBuffer2 } },\r\n                { binding: 2, resource: { buffer: medianParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(medianPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 4: Median filter on hue\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: medianPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: hueBuffer1 } },\r\n                { binding: 1, resource: { buffer: hueBuffer2 } },\r\n                { binding: 2, resource: { buffer: medianParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(medianPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 5: Recombine channels\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: recombinePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer2 } },\r\n                { binding: 1, resource: { buffer: saturationBuffer2 } },\r\n                { binding: 2, resource: { buffer: hueBuffer2 } },\r\n                { binding: 3, resource: { buffer: outputBuffer } },\r\n                { binding: 4, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(recombinePipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n    }\r\n    \r\n    // Wait for completion\r\n    if (typeof window !== 'undefined') {\r\n        await device.queue.onSubmittedWorkDone();\r\n    } else {\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n    \r\n    // Create visualization pipelines\r\n    const grayscaleModule = device.createShaderModule({ code: channelToGrayscaleShader });\r\n    const binaryModule = device.createShaderModule({ code: binaryToGrayscaleShader });\r\n    const hueVisModule = device.createShaderModule({ code: hueToRGBShader });\r\n    \r\n    const grayscalePipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: grayscaleModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const binaryPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: binaryModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const hueVisPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: hueVisModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    // Create output buffers for visualizations\r\n    const valueVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const saturationVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const saturationMedianVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const hueVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const hueMedianVisBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Visualize value channel (binary thresholded)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: binaryPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer2 } },\r\n                { binding: 1, resource: { buffer: valueVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(binaryPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize saturation (raw)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: grayscalePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: saturationBuffer1 } },\r\n                { binding: 1, resource: { buffer: saturationVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(grayscalePipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize saturation (median filtered)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: grayscalePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: saturationBuffer2 } },\r\n                { binding: 1, resource: { buffer: saturationMedianVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(grayscalePipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize hue (raw)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: hueVisPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: hueBuffer1 } },\r\n                { binding: 1, resource: { buffer: hueVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(hueVisPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Visualize hue (median filtered)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: hueVisPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: hueBuffer2 } },\r\n                { binding: 1, resource: { buffer: hueMedianVisBuffer } },\r\n                { binding: 2, resource: { buffer: extractParamsBuffer } },\r\n            ],\r\n        });\r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(hueVisPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Read back all results\r\n    const [finalData, valueData, satData, satMedianData, hueData, hueMedianData] = await Promise.all([\r\n        readGPUBuffer(device, outputBuffer, byteSize),\r\n        readGPUBuffer(device, valueVisBuffer, byteSize),\r\n        readGPUBuffer(device, saturationVisBuffer, byteSize),\r\n        readGPUBuffer(device, saturationMedianVisBuffer, byteSize),\r\n        readGPUBuffer(device, hueVisBuffer, byteSize),\r\n        readGPUBuffer(device, hueMedianVisBuffer, byteSize),\r\n    ]);\r\n    \r\n    console.log(`Cleanup complete: ${finalData.length} bytes`);\r\n    \r\n    // Cleanup buffers (keep valueBuffer2, saturationBuffer2, hueBuffer2 for further processing)\r\n    inputBuffer.destroy();\r\n    valueBuffer1.destroy();\r\n    // valueBuffer2 kept - returned for value processing\r\n    saturationBuffer1.destroy();\r\n    // saturationBuffer2 kept - returned for recombination\r\n    hueBuffer1.destroy();\r\n    // hueBuffer2 kept - returned for recombination\r\n    outputBuffer.destroy();\r\n    valueVisBuffer.destroy();\r\n    saturationVisBuffer.destroy();\r\n    saturationMedianVisBuffer.destroy();\r\n    hueVisBuffer.destroy();\r\n    hueMedianVisBuffer.destroy();\r\n    extractParamsBuffer.destroy();\r\n    thresholdParamsBuffer.destroy();\r\n    medianParamsBuffer.destroy();\r\n    \r\n    return {\r\n        value: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(valueData.buffer, 0, byteSize),\r\n        },\r\n        saturation: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(satData.buffer, 0, byteSize),\r\n        },\r\n        saturationMedian: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(satMedianData.buffer, 0, byteSize),\r\n        },\r\n        hue: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(hueData.buffer, 0, byteSize),\r\n        },\r\n        hueMedian: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(hueMedianData.buffer, 0, byteSize),\r\n        },\r\n        final: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(finalData.buffer, 0, byteSize),\r\n        },\r\n        valueBuffer: valueBuffer2,  // Don't destroy - pass to value processing\r\n        saturationBuffer: saturationBuffer2,  // Don't destroy - pass to recombination\r\n        hueBuffer: hueBuffer2,  // Don't destroy - pass to recombination\r\n        width,\r\n        height,\r\n    };\r\n}\r\n\r\n/**\r\n * Recombine channels with a custom value buffer (e.g., skeletonized)\r\n * Uses the saturation and hue buffers from cleanup, but with processed value\r\n */\r\nexport async function recombineWithValue(\r\n    valueBuffer: GPUBuffer,  // u32 binary buffer (0=line, 1=background)\r\n    saturationBuffer: GPUBuffer,  // f32 buffer\r\n    hueBuffer: GPUBuffer,  // f32 buffer\r\n    width: number,\r\n    height: number,\r\n): Promise<RGBAImage> {\r\n    const { device } = await getGPUContext();\r\n    \r\n    const pixelCount = width * height;\r\n    const byteSize = pixelCount * 4;\r\n    \r\n    // Create output buffer\r\n    const outputBuffer = device.createBuffer({\r\n        size: byteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffer\r\n    const paramsArray = new ArrayBuffer(8);\r\n    const paramsU32 = new Uint32Array(paramsArray);\r\n    paramsU32[0] = width;\r\n    paramsU32[1] = height;\r\n    \r\n    const paramsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(paramsBuffer, 0, paramsArray);\r\n    \r\n    // Create pipeline\r\n    const recombineModule = device.createShaderModule({ code: recombineShader });\r\n    const recombinePipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: recombineModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const workgroupsX = Math.ceil(width / 8);\r\n    const workgroupsY = Math.ceil(height / 8);\r\n    \r\n    // Recombine\r\n    const bindGroup = device.createBindGroup({\r\n        layout: recombinePipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: valueBuffer } },\r\n            { binding: 1, resource: { buffer: saturationBuffer } },\r\n            { binding: 2, resource: { buffer: hueBuffer } },\r\n            { binding: 3, resource: { buffer: outputBuffer } },\r\n            { binding: 4, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    const encoder = device.createCommandEncoder();\r\n    const pass = encoder.beginComputePass();\r\n    pass.setPipeline(recombinePipeline);\r\n    pass.setBindGroup(0, bindGroup);\r\n    pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n    pass.end();\r\n    device.queue.submit([encoder.finish()]);\r\n    await device.queue.onSubmittedWorkDone();\r\n    \r\n    // Read result\r\n    const finalData = await readGPUBuffer(device, outputBuffer, byteSize);\r\n    \r\n    // Cleanup\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: new Uint8ClampedArray(finalData.buffer, 0, byteSize),\r\n    };\r\n}\r\n", "/**\r\n * WebGPU value channel processing\r\n * - Convert to 1-bit binary format\r\n * - Weighted 3x3 median filter (cardinal directions weighted 2x)\r\n * - Skeletonization/thinning\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport { getGPUContext, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\n// Step 1: Weighted 3x3 median filter on packed binary data\r\n// Cardinals (N/E/S/W) counted twice, diagonals once = 12 total samples\r\n// Input/output: 1 = line (signal), 0 = background\r\nconst weightedMedianShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\nfn get_bit(data: ptr<storage, array<u32>, read>, x: u32, y: u32, w: u32, h: u32) -> u32 {\r\n    if (x >= w || y >= h) {\r\n        return 0u; // Background outside bounds\r\n    }\r\n    let pixel_idx = y * w + x;\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    return ((*data)[word_idx] >> bit_idx) & 1u;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let w = params.width;\r\n    let h = params.height;\r\n    \r\n    // Gather 3x3 neighborhood\r\n    var sum = 0u;\r\n    \r\n    // Corners = 4 samples (1x each)\r\n    sum += get_bit(&input, max(x, 1u) - 1u, max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, max(x, 1u) - 1u, min(y + 1u, h - 1u), w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), min(y + 1u, h - 1u), w, h);\r\n    \r\n    // Cardinals = 8 samples (2x each for weighting)\r\n    sum += get_bit(&input, x, max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, x, max(y, 1u) - 1u, w, h);\r\n    sum += get_bit(&input, x, min(y + 1u, h - 1u), w, h);\r\n    sum += get_bit(&input, x, min(y + 1u, h - 1u), w, h);\r\n    sum += get_bit(&input, max(x, 1u) - 1u, y, w, h);\r\n    sum += get_bit(&input, max(x, 1u) - 1u, y, w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), y, w, h);\r\n    sum += get_bit(&input, min(x + 1u, w - 1u), y, w, h);\r\n    \r\n    // Center = 1 sample\r\n    sum += get_bit(&input, x, y, w, h);\r\n    \r\n    // Total: 4 corners + 8 cardinals + 1 center = 13 samples\r\n    // Median threshold: keep if >= 7 samples are set\r\n    let median_bit = u32(sum >= 7u);\r\n    \r\n    if (median_bit == 1u) {\r\n        let pixel_idx = y * w + x;\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n    }\r\n}\r\n`;// Step 2: Pure Zhang-Suen skeletonization algorithm\r\n// Input/output: 1 = line (signal), 0 = background\r\nconst skeletonizeShader = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n@group(0) @binding(3) var<storage, read_write> change_counter: array<atomic<u32>>;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    iteration: u32,  // 0 or 1 for two-pass algorithm\r\n    _padding: u32,\r\n}\r\n\r\nfn get_bit(data: ptr<storage, array<u32>, read>, x: i32, y: i32, w: u32, h: u32) -> u32 {\r\n    if (x < 0 || y < 0 || x >= i32(w) || y >= i32(h)) {\r\n        return 0u; // Background outside bounds\r\n    }\r\n    let pixel_idx = u32(y) * w + u32(x);\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    return (input[word_idx] >> bit_idx) & 1u;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = i32(global_id.x);\r\n    let y = i32(global_id.y);\r\n    \r\n    if (x >= i32(params.width) || y >= i32(params.height)) {\r\n        return;\r\n    }\r\n    \r\n    let w = params.width;\r\n    let h = params.height;\r\n    \r\n    // Get center pixel (1 = line, 0 = background)\r\n    let p1 = get_bit(&input, x, y, w, h);\r\n    \r\n    // Only process line pixels\r\n    if (p1 == 0u) {\r\n        return;\r\n    }\r\n    \r\n    // Get 8-neighborhood in Zhang-Suen order (P2-P9):\r\n    // P9 P2 P3\r\n    // P8 P1 P4\r\n    // P7 P6 P5\r\n    let p2 = get_bit(&input, x,     y - 1, w, h);  // N\r\n    let p3 = get_bit(&input, x + 1, y - 1, w, h);  // NE\r\n    let p4 = get_bit(&input, x + 1, y,     w, h);  // E\r\n    let p5 = get_bit(&input, x + 1, y + 1, w, h);  // SE\r\n    let p6 = get_bit(&input, x,     y + 1, w, h);  // S\r\n    let p7 = get_bit(&input, x - 1, y + 1, w, h);  // SW\r\n    let p8 = get_bit(&input, x - 1, y,     w, h);  // W\r\n    let p9 = get_bit(&input, x - 1, y - 1, w, h);  // NW\r\n    \r\n    // Condition 1: 2 <= B(P1) <= 6\r\n    // B(P1) = number of line neighbors\r\n    let b = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9;\r\n    if (b < 2u || b > 6u) {\r\n        // Keep pixel\r\n        let pixel_idx = u32(y) * w + u32(x);\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n        return;\r\n    }\r\n    \r\n    // Condition 2: A(P1) = 1\r\n    // A(P1) = number of 0->1 transitions in ordered sequence P2,P3,...,P9,P2\r\n    var a = 0u;\r\n    if (p2 == 0u && p3 == 1u) { a += 1u; }\r\n    if (p3 == 0u && p4 == 1u) { a += 1u; }\r\n    if (p4 == 0u && p5 == 1u) { a += 1u; }\r\n    if (p5 == 0u && p6 == 1u) { a += 1u; }\r\n    if (p6 == 0u && p7 == 1u) { a += 1u; }\r\n    if (p7 == 0u && p8 == 1u) { a += 1u; }\r\n    if (p8 == 0u && p9 == 1u) { a += 1u; }\r\n    if (p9 == 0u && p2 == 1u) { a += 1u; }\r\n    \r\n    if (a != 1u) {\r\n        // Keep pixel\r\n        let pixel_idx = u32(y) * w + u32(x);\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n        return;\r\n    }\r\n    \r\n    // Conditions 3 & 4 depend on iteration (step 1 vs step 2)\r\n    // BOTH conditions must be satisfied (both products = 0) to delete\r\n    var should_delete = false;\r\n    \r\n    if (params.iteration == 0u) {\r\n        // Step 1:\r\n        // Condition 3: P2 * P4 * P6 = 0 (at least one of N, E, S is background)\r\n        // Condition 4: P4 * P6 * P8 = 0 (at least one of E, S, W is background)\r\n        if ((p2 * p4 * p6) == 0u && (p4 * p6 * p8) == 0u) {\r\n            should_delete = true;\r\n        }\r\n    } else {\r\n        // Step 2:\r\n        // Condition 3: P2 * P4 * P8 = 0 (at least one of N, E, W is background)\r\n        // Condition 4: P2 * P6 * P8 = 0 (at least one of N, S, W is background)\r\n        if ((p2 * p4 * p8) == 0u && (p2 * p6 * p8) == 0u) {\r\n            should_delete = true;\r\n        }\r\n    }\r\n    \r\n    if (!should_delete) {\r\n        let pixel_idx = u32(y) * w + u32(x);\r\n        let word_idx = pixel_idx / 32u;\r\n        let bit_idx = pixel_idx % 32u;\r\n        atomicOr(&output[word_idx], 1u << bit_idx);\r\n    } else {\r\n        // Pixel was deleted - increment change counter\r\n        atomicAdd(&change_counter[0], 1u);\r\n    }\r\n}\r\n`;\r\n\r\n// Helper: Convert packed binary to grayscale RGBA for visualization\r\n// Input: 1 = line (black), 0 = background (white)\r\nconst binaryToRGBAShader = `\r\n@group(0) @binding(0) var<storage, read> binary_in: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> rgba_out: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let pixel_idx = y * params.width + x;\r\n    let word_idx = pixel_idx / 32u;\r\n    let bit_idx = pixel_idx % 32u;\r\n    let bit = (binary_in[word_idx] >> bit_idx) & 1u;\r\n    \r\n    // 1 = line (black), 0 = background (white)\r\n    let gray = (1u - bit) * 255u;\r\n    \r\n    rgba_out[pixel_idx] = gray | (gray << 8u) | (gray << 16u) | (255u << 24u);\r\n}\r\n`;\r\n\r\nexport interface ValueProcessResults {\r\n    median: RGBAImage;           // After weighted median filter\r\n    skeleton: RGBAImage;         // After skeletonization\r\n    skeletonBuffer: GPUBuffer;   // Binary skeleton buffer (u32: 0=line, 1=background)\r\n}\r\n\r\n/**\r\n * Process value channel: weighted median, skeletonization\r\n * Input valueBuffer is already binary (u32: 0=line, 1=background)\r\n */\r\nexport async function processValueChannel(\r\n    valueBuffer: GPUBuffer,  // u32 array (binary) from cleanup\r\n    width: number,\r\n    height: number,\r\n): Promise<ValueProcessResults> {\r\n    const { device } = await getGPUContext();\r\n    \r\n    const pixelCount = width * height;\r\n    const binaryWordCount = Math.ceil(pixelCount / 32);  // Pack 32 pixels per u32\r\n    const binaryByteSize = binaryWordCount * 4;\r\n    const rgbaByteSize = pixelCount * 4;\r\n    \r\n    console.log(`Value processing: ${width}x${height}`);\r\n    \r\n    // Create binary buffers (unpacked: u32 per pixel)\r\n    // Input valueBuffer is already binary, use it directly\r\n    \r\n    const binaryBuffer2 = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const binaryBuffer3 = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const binaryBuffer4 = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create temporary buffer for intermediate pass results\r\n    const binaryBufferTemp = device.createBuffer({\r\n        size: binaryByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    // Create RGBA output buffers for visualization\r\n    const rgbaBuffer1 = device.createBuffer({\r\n        size: rgbaByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const rgbaBuffer2 = device.createBuffer({\r\n        size: rgbaByteSize,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffer\r\n    const params = new Uint32Array([width, height]);\r\n    const paramsBuffer = device.createBuffer({\r\n        size: 8,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(paramsBuffer, 0, params);\r\n    \r\n    // Create skeleton params buffer (with iteration field)\r\n    const skeletonParamsBuffer = device.createBuffer({\r\n        size: 16,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    // Create change counter buffer for convergence detection\r\n    const changeCounterBuffer = device.createBuffer({\r\n        size: 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create staging buffer for reading back the change counter\r\n    const stagingBuffer = device.createBuffer({\r\n        size: 4,\r\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n    });\r\n    \r\n    // Create shader modules\r\n    const medianModule = device.createShaderModule({ code: weightedMedianShader });\r\n    const skeletonModule = device.createShaderModule({ code: skeletonizeShader });\r\n    const toRGBAModule = device.createShaderModule({ code: binaryToRGBAShader });\r\n    \r\n    // Create pipelines\r\n    const medianPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: medianModule, entryPoint: \"main\" },\r\n    });    const skeletonPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: skeletonModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const toRGBAPipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: { module: toRGBAModule, entryPoint: \"main\" },\r\n    });\r\n    \r\n    const workgroupsX = Math.ceil(width / 8);\r\n    const workgroupsY = Math.ceil(height / 8);\r\n    \r\n    // Clear binary buffers (atomic operations require starting at 0)\r\n    device.queue.writeBuffer(binaryBuffer2, 0, new Uint32Array(binaryWordCount));\r\n    device.queue.writeBuffer(binaryBuffer3, 0, new Uint32Array(binaryWordCount));\r\n    device.queue.writeBuffer(binaryBuffer4, 0, new Uint32Array(binaryWordCount));\r\n    \r\n    // Pass 1: Weighted median filter (input is valueBuffer - already binary)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: medianPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: valueBuffer } },\r\n                { binding: 1, resource: { buffer: binaryBuffer2 } },\r\n                { binding: 2, resource: { buffer: paramsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(medianPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Pass 2: Skeletonization (Zhang-Suen algorithm - needs multiple iterations)\r\n    // Start from binaryBuffer2 (median output), copy to binaryBuffer3, then ping-pong between 3 and 4\r\n    // Run 4 iterations (2 passes each)\r\n    \r\n    // First, copy median result to binaryBuffer3 so we don't modify binaryBuffer2\r\n    {\r\n        const encoder = device.createCommandEncoder();\r\n        encoder.copyBufferToBuffer(binaryBuffer2, 0, binaryBuffer3, 0, binaryByteSize);\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Run up to 20 iterations, but exit early if converged\r\n    let convergedIter = -1;\r\n    for (let iter = 0; iter < 20; iter++) {\r\n        const inputBuffer = (iter % 2 == 0) ? binaryBuffer3 : binaryBuffer4;\r\n        const outputBuffer = (iter % 2 == 0) ? binaryBuffer4 : binaryBuffer3;\r\n        \r\n        // Clear temp buffer and output buffer, reset change counter\r\n        device.queue.writeBuffer(binaryBufferTemp, 0, new Uint32Array(binaryWordCount));\r\n        device.queue.writeBuffer(outputBuffer, 0, new Uint32Array(binaryWordCount));\r\n        device.queue.writeBuffer(changeCounterBuffer, 0, new Uint32Array(1));\r\n        \r\n        // Pass 0 - first pass of Zhang-Suen: input \u2192 temp\r\n        {\r\n            const skeletonParams = new Uint32Array([width, height, 0, 0]);\r\n            device.queue.writeBuffer(skeletonParamsBuffer, 0, skeletonParams);\r\n            \r\n            const bindGroup = device.createBindGroup({\r\n                layout: skeletonPipeline.getBindGroupLayout(0),\r\n                entries: [\r\n                    { binding: 0, resource: { buffer: inputBuffer } },\r\n                    { binding: 1, resource: { buffer: binaryBufferTemp } },\r\n                    { binding: 2, resource: { buffer: skeletonParamsBuffer } },\r\n                    { binding: 3, resource: { buffer: changeCounterBuffer } },\r\n                ],\r\n            });\r\n            \r\n            const encoder = device.createCommandEncoder();\r\n            const pass = encoder.beginComputePass();\r\n            pass.setPipeline(skeletonPipeline);\r\n            pass.setBindGroup(0, bindGroup);\r\n            pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n            pass.end();\r\n            device.queue.submit([encoder.finish()]);\r\n            await device.queue.onSubmittedWorkDone();\r\n        }\r\n        \r\n        // Pass 1 - second pass of Zhang-Suen: temp \u2192 output\r\n        {\r\n            const skeletonParams = new Uint32Array([width, height, 1, 0]);\r\n            device.queue.writeBuffer(skeletonParamsBuffer, 0, skeletonParams);\r\n            \r\n            const bindGroup = device.createBindGroup({\r\n                layout: skeletonPipeline.getBindGroupLayout(0),\r\n                entries: [\r\n                    { binding: 0, resource: { buffer: binaryBufferTemp } },\r\n                    { binding: 1, resource: { buffer: outputBuffer } },\r\n                    { binding: 2, resource: { buffer: skeletonParamsBuffer } },\r\n                    { binding: 3, resource: { buffer: changeCounterBuffer } },\r\n                ],\r\n            });\r\n            \r\n            const encoder = device.createCommandEncoder();\r\n            const pass = encoder.beginComputePass();\r\n            pass.setPipeline(skeletonPipeline);\r\n            pass.setBindGroup(0, bindGroup);\r\n            pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n            pass.end();\r\n            device.queue.submit([encoder.finish()]);\r\n            await device.queue.onSubmittedWorkDone();\r\n        }\r\n        \r\n        // Check for convergence by reading the change counter\r\n        {\r\n            const encoder = device.createCommandEncoder();\r\n            encoder.copyBufferToBuffer(changeCounterBuffer, 0, stagingBuffer, 0, 4);\r\n            device.queue.submit([encoder.finish()]);\r\n            await device.queue.onSubmittedWorkDone();\r\n            \r\n            await stagingBuffer.mapAsync(GPUMapMode.READ);\r\n            const counterData = new Uint32Array(stagingBuffer.getMappedRange());\r\n            const changeCount = counterData[0];\r\n            stagingBuffer.unmap();\r\n            \r\n            if (changeCount === 0) {\r\n                convergedIter = iter;\r\n                console.log(`Zhang-Suen converged after ${iter + 1} iteration(s) (${(iter + 1) * 2} passes)`);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (convergedIter === -1) {\r\n        console.log(`Zhang-Suen completed maximum 20 iterations (40 passes) without full convergence`);\r\n    }\r\n    \r\n    // After iterations, result is in outputBuffer from the last iteration\r\n    // Iter 0: input=buf3, output=buf4\r\n    // Iter 1: input=buf4, output=buf3\r\n    const finalIterCount = convergedIter === -1 ? 19 : convergedIter;\r\n    const finalSkeletonBuffer = finalIterCount % 2 == 0 ? binaryBuffer4 : binaryBuffer3;\r\n    \r\n    // Convert binary stages to RGBA for visualization\r\n    // Median stage (binaryBuffer2 preserved from Pass 1)\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: toRGBAPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: binaryBuffer2 } },\r\n                { binding: 1, resource: { buffer: rgbaBuffer1 } },\r\n                { binding: 2, resource: { buffer: paramsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(toRGBAPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Skeleton stage\r\n    {\r\n        const bindGroup = device.createBindGroup({\r\n            layout: toRGBAPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                { binding: 0, resource: { buffer: finalSkeletonBuffer } },\r\n                { binding: 1, resource: { buffer: rgbaBuffer2 } },\r\n                { binding: 2, resource: { buffer: paramsBuffer } },\r\n            ],\r\n        });\r\n        \r\n        const encoder = device.createCommandEncoder();\r\n        const pass = encoder.beginComputePass();\r\n        pass.setPipeline(toRGBAPipeline);\r\n        pass.setBindGroup(0, bindGroup);\r\n        pass.dispatchWorkgroups(workgroupsX, workgroupsY);\r\n        pass.end();\r\n        device.queue.submit([encoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n    \r\n    // Read back results\r\n    const [medianData, skeletonData] = await Promise.all([\r\n        readGPUBuffer(device, rgbaBuffer1, rgbaByteSize),\r\n        readGPUBuffer(device, rgbaBuffer2, rgbaByteSize),\r\n    ]);\r\n    \r\n    console.log(`Value processing complete`);\r\n    \r\n    // Cleanup (keep binaryBuffer3 (finalSkeletonBuffer) for recombination)\r\n    binaryBuffer2.destroy();\r\n    // binaryBuffer3 (finalSkeletonBuffer) kept - returned for recombination\r\n    binaryBuffer4.destroy();\r\n    rgbaBuffer1.destroy();\r\n    rgbaBuffer2.destroy();\r\n    paramsBuffer.destroy();\r\n    skeletonParamsBuffer.destroy();\r\n    \r\n    return {\r\n        median: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(medianData.buffer, 0, rgbaByteSize),\r\n        },\r\n        skeleton: {\r\n            width,\r\n            height,\r\n            data: new Uint8ClampedArray(skeletonData.buffer, 0, rgbaByteSize),\r\n        },\r\n        skeletonBuffer: finalSkeletonBuffer,  // Don't destroy - pass to recombination\r\n    };\r\n}\r\n", "/**\r\n * WebGPU palettization operation\r\n * Quantizes RGBA image to nearest colors in palette\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport type { PalettizedImage } from \"../formats/palettized.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<storage, read> palette: array<u32>;\r\n@group(0) @binding(3) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    palette_size: u32,\r\n}\r\n\r\nfn color_distance(c1: vec3<f32>, c2: vec3<f32>) -> f32 {\r\n    let diff = c1 - c2;\r\n    return dot(diff, diff);\r\n}\r\n\r\nfn luminosity(color: vec3<f32>) -> f32 {\r\n    return 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let idx = y * params.width + x;\r\n    let pixel = input[idx];\r\n    \r\n    // Unpack RGB\r\n    let r = f32(pixel & 0xFFu) / 255.0;\r\n    let g = f32((pixel >> 8u) & 0xFFu) / 255.0;\r\n    let b = f32((pixel >> 16u) & 0xFFu) / 255.0;\r\n    let color = vec3<f32>(r, g, b);\r\n    \r\n    // If input pixel is black (luminosity < threshold), force to white (palette index 0)\r\n    const threshold = 0.10;\r\n    let lum = luminosity(color);\r\n    if (lum < threshold) {\r\n        output[idx] = 0u;\r\n        return;\r\n    }\r\n    \r\n    // Pre-compute which palette indices are black (luminosity < 20%)\r\n    var is_black: array<bool, 16>;\r\n    for (var i = 0u; i < params.palette_size; i++) {\r\n        let pal_pixel = palette[i];\r\n        let pr = f32(pal_pixel & 0xFFu) / 255.0;\r\n        let pg = f32((pal_pixel >> 8u) & 0xFFu) / 255.0;\r\n        let pb = f32((pal_pixel >> 16u) & 0xFFu) / 255.0;\r\n        let pal_color = vec3<f32>(pr, pg, pb);\r\n        let pal_lum = luminosity(pal_color);\r\n        is_black[i] = pal_lum < threshold;\r\n    }\r\n    \r\n    // Find nearest palette color, skipping black palette entries\r\n    var best_idx: u32 = 0u;\r\n    var best_dist = 999999.0;\r\n    \r\n    for (var i = 0u; i < params.palette_size; i++) {\r\n        // Skip black palette colors\r\n        if (is_black[i]) {\r\n            continue;\r\n        }\r\n        \r\n        let pal_pixel = palette[i];\r\n        let pr = f32(pal_pixel & 0xFFu) / 255.0;\r\n        let pg = f32((pal_pixel >> 8u) & 0xFFu) / 255.0;\r\n        let pb = f32((pal_pixel >> 16u) & 0xFFu) / 255.0;\r\n        let pal_color = vec3<f32>(pr, pg, pb);\r\n        \r\n        let dist = color_distance(color, pal_color);\r\n        if (dist < best_dist) {\r\n            best_dist = dist;\r\n            best_idx = i;\r\n        }\r\n    }\r\n    \r\n    // Pack 2 pixels per u32 (4 bits each)\r\n    // Each workgroup handles one pixel, we'll pack later\r\n    output[idx] = best_idx;\r\n}\r\n`;\r\n\r\n/**\r\n * Palettize RGBA image using WebGPU\r\n * Returns palettized image with 4 bits per pixel\r\n */\r\nexport async function palettizeGPU(\r\n    image: RGBAImage,\r\n    palette: Uint8ClampedArray, // RGBA palette, length = paletteSize * 4\r\n): Promise<PalettizedImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const paletteSize = palette.length / 4;\r\n    if (paletteSize !== 16) {\r\n        throw new Error(\"GPU palettization currently only supports 16-color palettes\");\r\n    }\r\n    \r\n    // Convert RGBA bytes to u32 arrays - must copy to ensure alignment\r\n    const pixelCount = width * height;\r\n    const input = new Uint32Array(pixelCount);\r\n    const paletteU32 = new Uint32Array(paletteSize);\r\n    \r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        input[i] = dataView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    const paletteView = new DataView(palette.buffer, palette.byteOffset, palette.byteLength);\r\n    for (let i = 0; i < paletteSize; i++) {\r\n        paletteU32[i] = paletteView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(input.buffer, input.byteOffset, input.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: pixelCount * 4, // Temporary: one u32 per pixel\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paletteBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(paletteU32.buffer, paletteU32.byteOffset, paletteU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const paramsData = new Uint32Array([width, height, paletteSize, 0]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paletteBuffer } },\r\n            { binding: 3, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results (unpacked indices)\r\n    const indices = await readGPUBuffer(device, outputBuffer, pixelCount * 4);\r\n    const indicesU32 = new Uint32Array(indices.buffer);\r\n    \r\n    // Pack 2 pixels per byte (4 bits each)\r\n    const packedSize = Math.ceil(pixelCount / 2);\r\n    const packed = new Uint8Array(packedSize);\r\n    \r\n    for (let i = 0; i < pixelCount; i++) {\r\n        const byteIdx = Math.floor(i / 2);\r\n        const isHighNibble = (i % 2) === 0;\r\n        const paletteIdx = indicesU32[i] & 0xF;\r\n        \r\n        if (isHighNibble) {\r\n            packed[byteIdx] = (paletteIdx << 4);\r\n        } else {\r\n            packed[byteIdx] |= paletteIdx;\r\n        }\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paletteBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: packed,\r\n        palette: new Uint32Array(palette),\r\n    };\r\n}\r\n", "/**\r\n * Palettized image format\r\n * 4 bits per pixel (16 colors), stored as 2 pixels per byte\r\n * High nibble = left pixel, low nibble = right pixel\r\n */\r\nexport interface PalettizedImage {\r\n    width: number;\r\n    height: number;\r\n    data: Uint8Array; // length = ceil(width * height / 2)\r\n    palette?: Uint32Array; // optional RGBA palette (16 colors)\r\n}\r\n\r\n/**\r\n * Create an empty palettized image\r\n */\r\nexport function createPalettizedImage(\r\n    width: number,\r\n    height: number,\r\n    palette?: Uint32Array,\r\n): PalettizedImage {\r\n    const size = Math.ceil((width * height) / 2);\r\n    return {\r\n        width,\r\n        height,\r\n        data: new Uint8Array(size),\r\n        palette,\r\n    };\r\n}\r\n\r\n/**\r\n * Get pixel value at (x, y)\r\n * Returns index 0-15\r\n */\r\nexport function getPixelPal(\r\n    img: PalettizedImage,\r\n    x: number,\r\n    y: number,\r\n): number {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 2);\r\n    const isHighNibble = pixelIndex % 2 === 0;\r\n\r\n    if (isHighNibble) {\r\n        return (img.data[byteIndex] >> 4) & 0x0f;\r\n    } else {\r\n        return img.data[byteIndex] & 0x0f;\r\n    }\r\n}\r\n\r\n/**\r\n * Set pixel value at (x, y)\r\n * value must be 0-15\r\n */\r\nexport function setPixelPal(\r\n    img: PalettizedImage,\r\n    x: number,\r\n    y: number,\r\n    value: number,\r\n): void {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 2);\r\n    const isHighNibble = pixelIndex % 2 === 0;\r\n\r\n    value = value & 0x0f; // ensure 0-15\r\n\r\n    if (isHighNibble) {\r\n        img.data[byteIndex] = (img.data[byteIndex] & 0x0f) | (value << 4);\r\n    } else {\r\n        img.data[byteIndex] = (img.data[byteIndex] & 0xf0) | value;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert palettized image back to RGBA for export\r\n */\r\nexport function palettizedToRGBA(img: PalettizedImage): { width: number; height: number; data: Uint8ClampedArray } {\r\n    const palette = img.palette || DEFAULT_PALETTE;\r\n    const rgbaData = new Uint8ClampedArray(img.width * img.height * 4);\r\n    \r\n    for (let y = 0; y < img.height; y++) {\r\n        for (let x = 0; x < img.width; x++) {\r\n            const paletteIdx = getPixelPal(img, x, y);\r\n            const color = palette[paletteIdx];\r\n            \r\n            const pixelOffset = (y * img.width + x) * 4;\r\n            rgbaData[pixelOffset] = color & 0xFF;           // R\r\n            rgbaData[pixelOffset + 1] = (color >> 8) & 0xFF;  // G\r\n            rgbaData[pixelOffset + 2] = (color >> 16) & 0xFF; // B\r\n            rgbaData[pixelOffset + 3] = (color >> 24) & 0xFF; // A\r\n        }\r\n    }\r\n    \r\n    return {\r\n        width: img.width,\r\n        height: img.height,\r\n        data: rgbaData,\r\n    };\r\n}\r\n\r\n/**\r\n * Default palette\r\n * The classic 8-bit color palette, https://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_color_formats#3-bit_RGB,\r\n * with orange instead of yellow to improve visibility, plus one gray.\r\n */\r\nexport const DEFAULT_PALETTE: Uint32Array = new Uint32Array([\r\n    0xffffffff, // 0: white\r\n    0x000000ff, // 1: black\r\n    0xff0000ff, // 2: red\r\n    0x00ff00ff, // 3: green\r\n    0x0000ffff, // 4: blue\r\n    0xffaa00ff, // 5: orange (yellow is too similar to white)\r\n    0xff00ffff, // 6: magenta\r\n    0x00ffffff, // 7: cyan\r\n    0x808080ff, // 8: gray\r\n]);\r\n", "/**\r\n * WebGPU 3x3 median filter operation\r\n * Operates on palettized images (4-bit per pixel)\r\n */\r\n\r\nimport type { PalettizedImage } from \"../formats/palettized.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\nimport { getPixelPal } from \"../formats/palettized.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\nfn get_pixel(data: ptr<storage, array<u32>>, x: u32, y: u32, w: u32) -> u32 {\r\n    let idx = y * w + x;\r\n    return (*data)[idx] & 0xFu;\r\n}\r\n\r\nfn mode_nonzero(values: array<u32, 9>, center: u32) -> u32 {\r\n    // Count occurrences of each color\r\n    var counts: array<u32, 16>;\r\n    for (var i = 0u; i < 16u; i++) {\r\n        counts[i] = 0u;\r\n    }\r\n    \r\n    for (var i = 0u; i < 9u; i++) {\r\n        let val = values[i];\r\n        counts[val] = counts[val] + 1u;\r\n    }\r\n    \r\n    // Strategy: Only change center pixel if it's clearly an outlier\r\n    // Look at the 8 neighbors (excluding center)\r\n    var neighbor_counts: array<u32, 16>;\r\n    for (var i = 0u; i < 16u; i++) {\r\n        neighbor_counts[i] = 0u;\r\n    }\r\n    \r\n    // Count only the 8 neighbors (skip center at index 4)\r\n    for (var i = 0u; i < 9u; i++) {\r\n        if (i != 4u) {\r\n            let val = values[i];\r\n            neighbor_counts[val] = neighbor_counts[val] + 1u;\r\n        }\r\n    }\r\n    \r\n    // Find the most common neighbor color\r\n    var max_neighbor_count = 0u;\r\n    var dominant_neighbor = 0u;\r\n    for (var color = 0u; color < 16u; color++) {\r\n        if (neighbor_counts[color] > max_neighbor_count) {\r\n            max_neighbor_count = neighbor_counts[color];\r\n            dominant_neighbor = color;\r\n        }\r\n    }\r\n    \r\n    // Decision logic:\r\n    // 1. If center is different from all 8 neighbors, it's a single-pixel island - replace it\r\n    // 2. If 6+ neighbors agree on a color different from center, center is likely a cavity/barnacle - replace it\r\n    // 3. Otherwise, keep center as-is to preserve edges\r\n    \r\n    if (neighbor_counts[center] == 0u) {\r\n        // Center is completely isolated from all 8 neighbors - definitely noise\r\n        return dominant_neighbor;\r\n    } else if (max_neighbor_count >= 6u && dominant_neighbor != center) {\r\n        // Strong majority of neighbors agree on a different color - likely cavity or barnacle\r\n        return dominant_neighbor;\r\n    }\r\n    \r\n    // Keep center pixel - it's part of a legitimate feature\r\n    return center;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    // Clamp coordinates for edge handling\r\n    let x_prev = max(x, 1u) - 1u;\r\n    let x_next = min(x + 1u, params.width - 1u);\r\n    let y_prev = max(y, 1u) - 1u;\r\n    let y_next = min(y + 1u, params.height - 1u);\r\n    \r\n    // Gather 3x3 neighborhood\r\n    var values: array<u32, 9>;\r\n    values[0] = get_pixel(&input, x_prev, y_prev, params.width);\r\n    values[1] = get_pixel(&input, x,      y_prev, params.width);\r\n    values[2] = get_pixel(&input, x_next, y_prev, params.width);\r\n    values[3] = get_pixel(&input, x_prev, y,      params.width);\r\n    values[4] = get_pixel(&input, x,      y,      params.width);\r\n    values[5] = get_pixel(&input, x_next, y,      params.width);\r\n    values[6] = get_pixel(&input, x_prev, y_next, params.width);\r\n    values[7] = get_pixel(&input, x,      y_next, params.width);\r\n    values[8] = get_pixel(&input, x_next, y_next, params.width);\r\n    \r\n    let center = values[4];\r\n    let result = mode_nonzero(values, center);\r\n    \r\n    // Store result (unpacked, one u32 per pixel for now)\r\n    let idx = y * params.width + x;\r\n    output[idx] = result;\r\n}\r\n`;\r\n\r\n/**\r\n * Apply 3x3 median filter using WebGPU\r\n * Operates on palettized images\r\n */\r\nexport async function median3x3GPU(\r\n    image: PalettizedImage,\r\n): Promise<PalettizedImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, palette } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    \r\n    // Unpack to u32 array (one pixel per u32 for easier GPU access)\r\n    const unpacked = new Uint32Array(pixelCount);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        unpacked[i] = getPixelPal(image, i % width, Math.floor(i / width));\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(unpacked.buffer, unpacked.byteOffset, unpacked.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: unpacked.byteLength,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paramsData = new Uint32Array([width, height]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const outputData = await readGPUBuffer(device, outputBuffer, unpacked.byteLength);\r\n    const outputU32 = new Uint32Array(outputData.buffer);\r\n    \r\n    // Pack back to 4-bit format\r\n    const packedSize = Math.ceil(pixelCount / 2);\r\n    const packed = new Uint8Array(packedSize);\r\n    \r\n    for (let i = 0; i < pixelCount; i++) {\r\n        const byteIdx = Math.floor(i / 2);\r\n        const isHighNibble = (i % 2) === 0;\r\n        const paletteIdx = outputU32[i] & 0xF;\r\n        \r\n        if (isHighNibble) {\r\n            packed[byteIdx] = (paletteIdx << 4);\r\n        } else {\r\n            packed[byteIdx] |= paletteIdx;\r\n        }\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: packed,\r\n        palette: palette ? new Uint32Array(palette) : undefined,\r\n    };\r\n}\r\n", "/**\r\n * WebGPU black pixel extraction operation\r\n * Extracts black pixels from RGBA image based on luminosity threshold\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport type { BinaryImage } from \"../formats/binary.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input_rgba: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n    threshold: f32,\r\n}\r\n\r\n// Set a bit in the bit-packed array using atomics\r\nfn set_pixel_bit(x: u32, y: u32, w: u32, value: u32) {\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    let bit_position = byte_shift + bit_idx;\r\n    \r\n    let bit_mask = 1u << bit_position;\r\n    \r\n    if (value == 1u) {\r\n        atomicOr(&output[u32_idx], bit_mask);\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let idx = y * params.width + x;\r\n    let pixel = input_rgba[idx];\r\n    \r\n    // Unpack RGBA (little-endian: RGBA in memory = ABGR in u32)\r\n    let r = f32(pixel & 0xFFu) / 255.0;\r\n    let g = f32((pixel >> 8u) & 0xFFu) / 255.0;\r\n    let b = f32((pixel >> 16u) & 0xFFu) / 255.0;\r\n    \r\n    // Calculate luminosity\r\n    let luminosity = 0.299 * r + 0.587 * g + 0.114 * b;\r\n    \r\n    // If below threshold, mark as black (1)\r\n    if (luminosity < params.threshold) {\r\n        set_pixel_bit(x, y, params.width, 1u);\r\n    }\r\n}\r\n`;\r\n\r\n/**\r\n * Extract black pixels from RGBA image using WebGPU\r\n * Pixels with luminosity below threshold are marked as black (1)\r\n */\r\nexport async function extractBlackGPU(\r\n    image: RGBAImage,\r\n    luminosityThreshold: number = 0.20,\r\n): Promise<BinaryImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    \r\n    // Convert RGBA to u32 array\r\n    const inputU32 = new Uint32Array(pixelCount);\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        inputU32[i] = dataView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    // Create output buffer for bit-packed binary image\r\n    const byteCount = Math.ceil(pixelCount / 8);\r\n    const u32Count = Math.ceil(byteCount / 4);\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(inputU32.buffer, inputU32.byteOffset, inputU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: u32Count * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    // Create params buffer with proper types: u32, u32, f32, padding\r\n    const paramsArray = new ArrayBuffer(16); // 3 values + padding\r\n    const paramsU32 = new Uint32Array(paramsArray);\r\n    const paramsF32 = new Float32Array(paramsArray);\r\n    paramsU32[0] = width;  // u32\r\n    paramsU32[1] = height; // u32\r\n    paramsF32[2] = luminosityThreshold; // f32\r\n    \r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(paramsArray),\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const resultU32 = await readGPUBuffer(device, outputBuffer, u32Count * 4);\r\n    const resultU32Array = new Uint32Array(resultU32.buffer);\r\n    \r\n    // Convert back to byte array\r\n    const resultData = new Uint8Array(byteCount);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        resultData[i] = (resultU32Array[u32Idx] >> shift) & 0xff;\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: resultData,\r\n    };\r\n}\r\n", "/**\r\n * WebGPU bloom filter operation for binary images\r\n * For each pixel, if any pixel in its 3x3 neighborhood is black (1), set it to black\r\n */\r\n\r\nimport type { BinaryImage } from \"../formats/binary.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<atomic<u32>>;\r\n@group(0) @binding(2) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Get a bit from the bit-packed array\r\n// Data format: 8 pixels per byte, MSB first, bytes packed into u32s (little-endian)\r\nfn get_pixel_bit(x: u32, y: u32, w: u32, h: u32) -> u32 {\r\n    if (x >= w || y >= h) {\r\n        return 0u;\r\n    }\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    \r\n    let u32_val = input[u32_idx];\r\n    let byte_val = (u32_val >> byte_shift) & 0xFFu;\r\n    let bit_val = (byte_val >> bit_idx) & 1u;\r\n    return bit_val;\r\n}\r\n\r\n// Set a bit in the bit-packed array using atomics\r\nfn set_pixel_bit(x: u32, y: u32, w: u32, value: u32) {\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    let bit_position = byte_shift + bit_idx;\r\n    \r\n    let bit_mask = 1u << bit_position;\r\n    \r\n    if (value == 1u) {\r\n        atomicOr(&output[u32_idx], bit_mask);\r\n    } else {\r\n        atomicAnd(&output[u32_idx], ~bit_mask);\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    // Check 3x3 neighborhood for any black pixels (value == 1)\r\n    var has_black = false;\r\n    for (var dy = -1; dy <= 1; dy++) {\r\n        for (var dx = -1; dx <= 1; dx++) {\r\n            let nx = i32(x) + dx;\r\n            let ny = i32(y) + dy;\r\n            \r\n            if (nx >= 0 && ny >= 0 && nx < i32(params.width) && ny < i32(params.height)) {\r\n                let bit = get_pixel_bit(u32(nx), u32(ny), params.width, params.height);\r\n                if (bit == 1u) {\r\n                    has_black = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Set output pixel\r\n    set_pixel_bit(x, y, params.width, select(0u, 1u, has_black));\r\n}\r\n`;\r\n\r\n/**\r\n * Apply 3x3 bloom filter to binary image using WebGPU\r\n * Sets a pixel to black (1) if any pixel in its 3x3 neighborhood is black\r\n */\r\nexport async function bloomFilter3x3GPU(image: BinaryImage): Promise<BinaryImage> {\r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    const byteCount = Math.ceil(pixelCount / 8);\r\n    \r\n    // Convert to u32 array for GPU (pad to 4-byte alignment)\r\n    const u32Count = Math.ceil(byteCount / 4);\r\n    const inputU32 = new Uint32Array(u32Count);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        inputU32[u32Idx] |= (data[i] << shift);\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(inputU32.buffer, inputU32.byteOffset, inputU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: u32Count * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paramsData = new Uint32Array([width, height]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: outputBuffer } },\r\n            { binding: 2, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const resultU32 = await readGPUBuffer(device, outputBuffer, u32Count * 4);\r\n    const resultU32Array = new Uint32Array(resultU32.buffer);\r\n    \r\n    // Convert back to byte array\r\n    const resultData = new Uint8Array(byteCount);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        resultData[i] = (resultU32Array[u32Idx] >> shift) & 0xff;\r\n    }\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: resultData,\r\n    };\r\n}\r\n", "/**\r\n * WebGPU black subtraction operation\r\n * Subtracts bloom-filtered black from RGBA image by setting black pixels to white\r\n */\r\n\r\nimport type { RGBAImage } from \"../formats/rgba_image.ts\";\r\nimport type { BinaryImage } from \"../formats/binary.ts\";\r\nimport { getGPUContext, createGPUBuffer, readGPUBuffer } from \"./gpu_context.ts\";\r\n\r\nconst shaderCode = `\r\n@group(0) @binding(0) var<storage, read> input_rgba: array<u32>;\r\n@group(0) @binding(1) var<storage, read> bloom_mask: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(3) var<uniform> params: Params;\r\n\r\nstruct Params {\r\n    width: u32,\r\n    height: u32,\r\n}\r\n\r\n// Get a bit from the bit-packed binary image\r\n// Data format: 8 pixels per byte, MSB first, bytes packed into u32s (little-endian)\r\nfn get_pixel_bit(x: u32, y: u32, w: u32, h: u32) -> u32 {\r\n    if (x >= w || y >= h) {\r\n        return 0u;\r\n    }\r\n    let pixel_idx = y * w + x;\r\n    let byte_idx = pixel_idx / 8u;\r\n    let bit_idx = 7u - (pixel_idx % 8u); // MSB-first within byte\r\n    \r\n    // u32s contain 4 bytes in little-endian order\r\n    let u32_idx = byte_idx / 4u;\r\n    let byte_in_u32 = byte_idx % 4u;\r\n    let byte_shift = byte_in_u32 * 8u;\r\n    \r\n    let u32_val = bloom_mask[u32_idx];\r\n    let byte_val = (u32_val >> byte_shift) & 0xFFu;\r\n    let bit_val = (byte_val >> bit_idx) & 1u;\r\n    return bit_val;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\r\n    let x = global_id.x;\r\n    let y = global_id.y;\r\n    \r\n    if (x >= params.width || y >= params.height) {\r\n        return;\r\n    }\r\n    \r\n    let idx = y * params.width + x;\r\n    let is_black = get_pixel_bit(x, y, params.width, params.height);\r\n    \r\n    if (is_black == 1u) {\r\n        // Set to white: RGBA = (255, 255, 255, 255)\r\n        // In little-endian u32: 0xFFFFFFFF\r\n        output[idx] = 0xFFFFFFFFu;\r\n    } else {\r\n        // Copy original pixel\r\n        output[idx] = input_rgba[idx];\r\n    }\r\n}\r\n`;\r\n\r\n/**\r\n * Subtract bloom-filtered black from RGBA image using WebGPU\r\n * Sets pixels to white where bloom mask is black (1)\r\n */\r\nexport async function subtractBlackGPU(\r\n    image: RGBAImage,\r\n    bloomFiltered: BinaryImage,\r\n): Promise<RGBAImage> {\r\n    if (image.width !== bloomFiltered.width || image.height !== bloomFiltered.height) {\r\n        throw new Error(\"Image dimensions must match\");\r\n    }\r\n    \r\n    const { device } = await getGPUContext();\r\n    const { width, height, data } = image;\r\n    \r\n    const pixelCount = width * height;\r\n    \r\n    // Convert RGBA to u32 array\r\n    const inputU32 = new Uint32Array(pixelCount);\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    for (let i = 0; i < pixelCount; i++) {\r\n        inputU32[i] = dataView.getUint32(i * 4, true);\r\n    }\r\n    \r\n    // Convert binary image to u32 array\r\n    const byteCount = bloomFiltered.data.length;\r\n    const u32Count = Math.ceil(byteCount / 4);\r\n    const maskU32 = new Uint32Array(u32Count);\r\n    for (let i = 0; i < byteCount; i++) {\r\n        const u32Idx = Math.floor(i / 4);\r\n        const byteInU32 = i % 4;\r\n        const shift = byteInU32 * 8;\r\n        maskU32[u32Idx] |= (bloomFiltered.data[i] << shift);\r\n    }\r\n    \r\n    // Create GPU buffers\r\n    const inputBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(inputU32.buffer, inputU32.byteOffset, inputU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const maskBuffer = createGPUBuffer(\r\n        device,\r\n        new Uint8Array(maskU32.buffer, maskU32.byteOffset, maskU32.byteLength),\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    const outputBuffer = device.createBuffer({\r\n        size: pixelCount * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    \r\n    const paramsData = new Uint32Array([width, height]);\r\n    const paramsBuffer = createGPUBuffer(\r\n        device,\r\n        paramsData,\r\n        GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    );\r\n    \r\n    // Create shader module and pipeline\r\n    const shaderModule = device.createShaderModule({ code: shaderCode });\r\n    \r\n    const pipeline = device.createComputePipeline({\r\n        layout: \"auto\",\r\n        compute: {\r\n            module: shaderModule,\r\n            entryPoint: \"main\",\r\n        },\r\n    });\r\n    \r\n    const bindGroup = device.createBindGroup({\r\n        layout: pipeline.getBindGroupLayout(0),\r\n        entries: [\r\n            { binding: 0, resource: { buffer: inputBuffer } },\r\n            { binding: 1, resource: { buffer: maskBuffer } },\r\n            { binding: 2, resource: { buffer: outputBuffer } },\r\n            { binding: 3, resource: { buffer: paramsBuffer } },\r\n        ],\r\n    });\r\n    \r\n    // Execute compute shader\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginComputePass();\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.dispatchWorkgroups(\r\n        Math.ceil(width / 8),\r\n        Math.ceil(height / 8),\r\n    );\r\n    passEncoder.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    // Read back results\r\n    const resultBytes = await readGPUBuffer(device, outputBuffer, pixelCount * 4);\r\n    const resultData = new Uint8ClampedArray(resultBytes);\r\n    \r\n    // Cleanup\r\n    inputBuffer.destroy();\r\n    maskBuffer.destroy();\r\n    outputBuffer.destroy();\r\n    paramsBuffer.destroy();\r\n    \r\n    return {\r\n        width,\r\n        height,\r\n        data: resultData,\r\n    };\r\n}\r\n", "/**\r\n * IndexedDB storage for uploaded files\r\n */\r\n\r\nconst DB_NAME = \"CleanPlansDB\";\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = \"files\";\r\n\r\nexport interface StoredFile {\r\n  id: string;\r\n  name: string;\r\n  type: string;\r\n  data: Uint8Array;\r\n  uploadedAt: number;\r\n  thumbnail?: string; // base64 data URL\r\n  palette?: string; // JSON serialized palette\r\n}\r\n\r\nlet db: IDBDatabase | null = null;\r\n\r\nasync function openDB(): Promise<IDBDatabase> {\r\n  if (db) return db;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n    request.onerror = () => reject(request.error);\r\n    request.onsuccess = () => {\r\n      db = request.result;\r\n      resolve(db);\r\n    };\r\n\r\n    request.onupgradeneeded = (event) => {\r\n      const db = (event.target as IDBOpenDBRequest).result;\r\n      \r\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\r\n        const store = db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\r\n        store.createIndex(\"uploadedAt\", \"uploadedAt\", { unique: false });\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nexport async function saveFile(file: File, thumbnail?: string): Promise<string> {\r\n  const db = await openDB();\r\n  const id = crypto.randomUUID();\r\n  const arrayBuffer = await file.arrayBuffer();\r\n\r\n  const storedFile: StoredFile = {\r\n    id,\r\n    name: file.name,\r\n    type: file.type,\r\n    data: new Uint8Array(arrayBuffer),\r\n    uploadedAt: Date.now(),\r\n    thumbnail,\r\n  };\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.add(storedFile);\r\n\r\n    request.onsuccess = () => resolve(id);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function updateFile(id: string, updates: Partial<StoredFile>): Promise<void> {\r\n  const db = await openDB();\r\n  const existing = await getFile(id);\r\n  \r\n  if (!existing) {\r\n    throw new Error(`File ${id} not found`);\r\n  }\r\n\r\n  const updated = { ...existing, ...updates };\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.put(updated);\r\n\r\n    request.onsuccess = () => resolve();\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function getFile(id: string): Promise<StoredFile | null> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readonly\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.get(id);\r\n\r\n    request.onsuccess = () => resolve(request.result || null);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function listFiles(): Promise<StoredFile[]> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readonly\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.getAll();\r\n\r\n    request.onsuccess = () => {\r\n      const files = request.result as StoredFile[];\r\n      // Sort by most recent first\r\n      files.sort((a, b) => b.uploadedAt - a.uploadedAt);\r\n      resolve(files);\r\n    };\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function deleteFile(id: string): Promise<void> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.delete(id);\r\n\r\n    request.onsuccess = () => resolve();\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n\r\nexport async function clearAllFiles(): Promise<void> {\r\n  const db = await openDB();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.clear();\r\n\r\n    request.onsuccess = () => resolve();\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n}\r\n", "/**\r\n * Utility functions for color conversion and helpers\r\n */\r\n\r\n// Convert u32 color to hex\r\nexport function u32ToHex(color: number): string {\r\n  const r = (color >> 24) & 0xff;\r\n  const g = (color >> 16) & 0xff;\r\n  const b = (color >> 8) & 0xff;\r\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\r\n}\r\n\r\n// Convert hex to RGBA values\r\nexport function hexToRGBA(hex: string): [number, number, number, number] {\r\n  const r = parseInt(hex.slice(1, 3), 16);\r\n  const g = parseInt(hex.slice(3, 5), 16);\r\n  const b = parseInt(hex.slice(5, 7), 16);\r\n  return [r, g, b, 255];\r\n}\r\n", "/**\r\n * Application state management\r\n * Using a state object to allow mutations from importing modules\r\n */\r\n\r\nimport type { RGBAImage } from \"../src/formats/rgba_image.ts\";\r\nimport type { PalettizedImage } from \"../src/formats/palettized.ts\";\r\nimport type { BinaryImage } from \"../src/formats/binary.ts\";\r\nimport { DEFAULT_PALETTE } from \"../src/formats/palettized.ts\";\r\nimport type { ProcessingStage, PaletteColor } from \"./types.ts\";\r\nimport type { VectorizedImage } from \"./vectorize.ts\";\r\nimport { u32ToHex } from \"./utils.ts\";\r\n\r\n// UI State\r\nexport const state = {\r\n  currentFileId: null as string | null,\r\n  currentPdfData: null as Uint8Array | null,\r\n  currentImage: null as RGBAImage | null,\r\n  currentSelectedPage: null as number | null,\r\n  pdfPageCount: 0,\r\n  cancelThumbnailLoading: false,\r\n\r\n  // Processing state\r\n  currentStage: \"cropped\" as ProcessingStage,\r\n  processedImages: new Map<ProcessingStage, RGBAImage | PalettizedImage | BinaryImage>(),\r\n  vectorizedImages: new Map<string, VectorizedImage>(), // e.g., \"color_1_vec\"\r\n\r\n  // Palette configuration\r\n  userPalette: Array.from(DEFAULT_PALETTE).map(color => ({\r\n    inputColor: u32ToHex(color),\r\n    outputColor: u32ToHex(color),\r\n    mapToBg: false,\r\n  })) as PaletteColor[],\r\n  currentPaletteName: \"\",\r\n\r\n  // Canvas/Viewport State\r\n  zoom: 1.0,\r\n  panX: 0,\r\n  panY: 0,\r\n  isPanning: false,\r\n  isDraggingCropHandle: false,\r\n  activeCropHandle: null as string | null,\r\n  cropRegion: null as { x: number; y: number; width: number; height: number } | null,\r\n  lastPanX: 0,\r\n  lastPanY: 0,\r\n\r\n  // Processing canvas state\r\n  processZoom: 1.0,\r\n  processPanX: 0,\r\n  processPanY: 0,\r\n  isProcessPanning: false,\r\n  lastProcessPanX: 0,\r\n  lastProcessPanY: 0,\r\n  processViewInitialized: false,\r\n  \r\n  // Vector overlay state\r\n  vectorOverlayEnabled: false,\r\n  vectorOverlayStage: null as string | null, // e.g., \"color_1_vec\"\r\n};\r\n", "/**\r\n * Canvas viewport and crop management\r\n */\r\n\r\nimport type { RGBAImage } from \"../src/formats/rgba_image.ts\";\r\nimport { state } from \"./state.ts\";\r\n\r\n// DOM Elements (initialized in main.ts)\r\nexport let canvasContainer: HTMLDivElement;\r\nexport let mainCanvas: HTMLCanvasElement;\r\nexport let ctx: CanvasRenderingContext2D;\r\nexport let cropOverlay: HTMLCanvasElement;\r\nexport let cropCtx: CanvasRenderingContext2D;\r\nexport let zoomLevel: HTMLDivElement;\r\nexport let cropInfo: HTMLDivElement;\r\n\r\nexport function initCanvasElements(elements: {\r\n  canvasContainer: HTMLDivElement;\r\n  mainCanvas: HTMLCanvasElement;\r\n  ctx: CanvasRenderingContext2D;\r\n  cropOverlay: HTMLCanvasElement;\r\n  cropCtx: CanvasRenderingContext2D;\r\n  zoomLevel: HTMLDivElement;\r\n  cropInfo: HTMLDivElement;\r\n}) {\r\n  canvasContainer = elements.canvasContainer;\r\n  mainCanvas = elements.mainCanvas;\r\n  ctx = elements.ctx;\r\n  cropOverlay = elements.cropOverlay;\r\n  cropCtx = elements.cropCtx;\r\n  zoomLevel = elements.zoomLevel;\r\n  cropInfo = elements.cropInfo;\r\n}\r\n\r\nexport function loadImage(image: RGBAImage, statusCallback: (msg: string) => void) {\r\n  state.currentImage = image;\r\n  \r\n  // Set up canvases\r\n  mainCanvas.width = image.width;\r\n  mainCanvas.height = image.height;\r\n  cropOverlay.width = image.width;\r\n  cropOverlay.height = image.height;\r\n  \r\n  // Make sure main canvas is visible (crop overlay shown after drawing)\r\n  mainCanvas.style.display = \"block\";\r\n  canvasContainer.style.opacity = \"1\";\r\n  \r\n  // Load saved crop settings or set default 10% margin\r\n  const savedCrop = getCropSettings(image.width, image.height);\r\n  if (savedCrop) {\r\n    state.cropRegion = savedCrop;\r\n  } else {\r\n    setDefaultCrop(image.width, image.height);\r\n  }\r\n  \r\n  // Draw the image first\r\n  const imageData = new ImageData(\r\n    new Uint8ClampedArray(image.data),\r\n    image.width,\r\n    image.height,\r\n  );\r\n  ctx.putImageData(imageData, 0, 0);\r\n  \r\n  // Then fit to screen and draw crop\r\n  fitToScreen();\r\n  cropOverlay.style.display = \"block\";\r\n  drawCropOverlay();\r\n  \r\n  statusCallback(`\u2713 Ready: ${image.width}\u00D7${image.height} pixels`);\r\n}\r\n\r\nexport function fitToScreen() {\r\n  if (!state.currentImage) return;\r\n  \r\n  const containerWidth = canvasContainer.clientWidth;\r\n  const containerHeight = canvasContainer.clientHeight;\r\n  const imageWidth = state.currentImage.width;\r\n  const imageHeight = state.currentImage.height;\r\n  \r\n  const scaleX = containerWidth / imageWidth;\r\n  const scaleY = containerHeight / imageHeight;\r\n  state.zoom = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding\r\n  \r\n  state.panX = (containerWidth - imageWidth * state.zoom) / 2;\r\n  state.panY = (containerHeight - imageHeight * state.zoom) / 2;\r\n  \r\n  updateZoom();\r\n  updateTransform();\r\n}\r\n\r\nexport function updateZoom() {\r\n  zoomLevel.textContent = `${Math.round(state.zoom * 100)}%`;\r\n}\r\n\r\n// Crop management functions\r\nexport function setDefaultCrop(imageWidth: number, imageHeight: number) {\r\n  const margin = 0.1; // 10% margin\r\n  state.cropRegion = {\r\n    x: imageWidth * margin,\r\n    y: imageHeight * margin,\r\n    width: imageWidth * (1 - 2 * margin),\r\n    height: imageHeight * (1 - 2 * margin),\r\n  };\r\n  updateCropInfo();\r\n}\r\n\r\nexport function getCropSettings(imageWidth: number, imageHeight: number) {\r\n  const key = `crop_${Math.round(imageWidth)}_${Math.round(imageHeight)}`;\r\n  const stored = localStorage.getItem(key);\r\n  if (stored) {\r\n    try {\r\n      return JSON.parse(stored) as { x: number; y: number; width: number; height: number };\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function saveCropSettings(imageWidth: number, imageHeight: number, crop: { x: number; y: number; width: number; height: number }) {\r\n  const key = `crop_${Math.round(imageWidth)}_${Math.round(imageHeight)}`;\r\n  localStorage.setItem(key, JSON.stringify(crop));\r\n}\r\n\r\nexport function updateCropInfo() {\r\n  if (state.cropRegion) {\r\n    cropInfo.textContent = `Crop: ${Math.round(state.cropRegion.width)}\u00D7${Math.round(state.cropRegion.height)} at (${Math.round(state.cropRegion.x)}, ${Math.round(state.cropRegion.y)})`;\r\n  }\r\n}\r\n\r\nexport function getCropHandleAtPoint(x: number, y: number): string | null {\r\n  if (!state.cropRegion) return null;\r\n  \r\n  const handleSize = 15 / state.zoom; // Handle hit area in canvas coordinates\r\n  const { x: cx, y: cy, width: cw, height: ch } = state.cropRegion;\r\n  \r\n  // Check corners first\r\n  if (Math.abs(x - cx) < handleSize && Math.abs(y - cy) < handleSize) return \"tl\";\r\n  if (Math.abs(x - (cx + cw)) < handleSize && Math.abs(y - cy) < handleSize) return \"tr\";\r\n  if (Math.abs(x - cx) < handleSize && Math.abs(y - (cy + ch)) < handleSize) return \"bl\";\r\n  if (Math.abs(x - (cx + cw)) < handleSize && Math.abs(y - (cy + ch)) < handleSize) return \"br\";\r\n  \r\n  // Check edges\r\n  if (Math.abs(x - (cx + cw / 2)) < handleSize && Math.abs(y - cy) < handleSize) return \"t\";\r\n  if (Math.abs(x - (cx + cw / 2)) < handleSize && Math.abs(y - (cy + ch)) < handleSize) return \"b\";\r\n  if (Math.abs(y - (cy + ch / 2)) < handleSize && Math.abs(x - cx) < handleSize) return \"l\";\r\n  if (Math.abs(y - (cy + ch / 2)) < handleSize && Math.abs(x - (cx + cw)) < handleSize) return \"r\";\r\n  \r\n  return null;\r\n}\r\n\r\nexport function updateCursorForHandle(handle: string | null) {\r\n  if (!handle) {\r\n    canvasContainer.style.cursor = \"default\";\r\n  } else if (handle === \"tl\" || handle === \"br\") {\r\n    canvasContainer.style.cursor = \"nwse-resize\";\r\n  } else if (handle === \"tr\" || handle === \"bl\") {\r\n    canvasContainer.style.cursor = \"nesw-resize\";\r\n  } else if (handle === \"t\" || handle === \"b\") {\r\n    canvasContainer.style.cursor = \"ns-resize\";\r\n  } else if (handle === \"l\" || handle === \"r\") {\r\n    canvasContainer.style.cursor = \"ew-resize\";\r\n  }\r\n}\r\n\r\nexport function adjustCropRegion(handle: string, dx: number, dy: number) {\r\n  if (!state.cropRegion || !state.currentImage) return;\r\n  \r\n  const { x, y, width, height } = state.cropRegion;\r\n  let newX = x, newY = y, newWidth = width, newHeight = height;\r\n  \r\n  switch (handle) {\r\n    case \"tl\":\r\n      newX = x + dx;\r\n      newY = y + dy;\r\n      newWidth = width - dx;\r\n      newHeight = height - dy;\r\n      break;\r\n    case \"tr\":\r\n      newY = y + dy;\r\n      newWidth = width + dx;\r\n      newHeight = height - dy;\r\n      break;\r\n    case \"bl\":\r\n      newX = x + dx;\r\n      newWidth = width - dx;\r\n      newHeight = height + dy;\r\n      break;\r\n    case \"br\":\r\n      newWidth = width + dx;\r\n      newHeight = height + dy;\r\n      break;\r\n    case \"t\":\r\n      newY = y + dy;\r\n      newHeight = height - dy;\r\n      break;\r\n    case \"b\":\r\n      newHeight = height + dy;\r\n      break;\r\n    case \"l\":\r\n      newX = x + dx;\r\n      newWidth = width - dx;\r\n      break;\r\n    case \"r\":\r\n      newWidth = width + dx;\r\n      break;\r\n  }\r\n  \r\n  // Constrain to image bounds\r\n  newX = Math.max(0, Math.min(newX, state.currentImage.width - 10));\r\n  newY = Math.max(0, Math.min(newY, state.currentImage.height - 10));\r\n  newWidth = Math.max(10, Math.min(newWidth, state.currentImage.width - newX));\r\n  newHeight = Math.max(10, Math.min(newHeight, state.currentImage.height - newY));\r\n  \r\n  state.cropRegion.x = newX;\r\n  state.cropRegion.y = newY;\r\n  state.cropRegion.width = newWidth;\r\n  state.cropRegion.height = newHeight;\r\n  \r\n  updateCropInfo();\r\n}\r\n\r\n// Fast update - only changes transform (for panning/zooming)\r\nexport function updateTransform() {\r\n  const transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;\r\n  mainCanvas.style.transform = transform;\r\n  mainCanvas.style.transformOrigin = \"0 0\";\r\n  mainCanvas.style.willChange = \"transform\";\r\n  \r\n  cropOverlay.style.transform = transform;\r\n  cropOverlay.style.transformOrigin = \"0 0\";\r\n  cropOverlay.style.willChange = \"transform\";\r\n  \r\n  // Use crisp pixels when zoomed in (>= 1x), filtered when zoomed out (< 1x)\r\n  if (state.zoom >= 1) {\r\n    mainCanvas.style.imageRendering = \"pixelated\";\r\n  } else {\r\n    mainCanvas.style.imageRendering = \"smooth\";\r\n  }\r\n  \r\n  // Redraw crop overlay whenever transform changes\r\n  drawCropOverlay();\r\n}\r\n\r\n// Full redraw - updates canvas content\r\nexport function redrawCanvas() {\r\n  if (!state.currentImage) return;\r\n  \r\n  // Clear and redraw base image\r\n  ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);\r\n  const imageData = new ImageData(\r\n    new Uint8ClampedArray(state.currentImage.data),\r\n    state.currentImage.width,\r\n    state.currentImage.height,\r\n  );\r\n  ctx.putImageData(imageData, 0, 0);\r\n  \r\n  drawCropOverlay();\r\n}\r\n\r\n// Draw crop overlay with darkened mask and handles\r\nexport function drawCropOverlay() {\r\n  if (!state.currentImage || !state.cropRegion) {\r\n    cropCtx.clearRect(0, 0, cropOverlay.width, cropOverlay.height);\r\n    return;\r\n  }\r\n  \r\n  cropCtx.clearRect(0, 0, cropOverlay.width, cropOverlay.height);\r\n  \r\n  // Draw darkened mask over entire image\r\n  cropCtx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\r\n  cropCtx.fillRect(0, 0, state.currentImage.width, state.currentImage.height);\r\n  \r\n  // Clear the crop region (composite mode)\r\n  cropCtx.globalCompositeOperation = \"destination-out\";\r\n  cropCtx.fillStyle = \"rgba(0, 0, 0, 1)\";\r\n  cropCtx.fillRect(\r\n    state.cropRegion.x,\r\n    state.cropRegion.y,\r\n    state.cropRegion.width,\r\n    state.cropRegion.height,\r\n  );\r\n  cropCtx.globalCompositeOperation = \"source-over\";\r\n  \r\n  // Draw crop rectangle border\r\n  cropCtx.strokeStyle = \"#4f46e5\";\r\n  cropCtx.lineWidth = 3 / state.zoom;\r\n  cropCtx.strokeRect(\r\n    state.cropRegion.x,\r\n    state.cropRegion.y,\r\n    state.cropRegion.width,\r\n    state.cropRegion.height,\r\n  );\r\n  \r\n  // Draw handles - 4 corners + 4 edges\r\n  const handleSize = 10 / state.zoom;\r\n  cropCtx.fillStyle = \"#4f46e5\";\r\n  \r\n  const cx = state.cropRegion.x;\r\n  const cy = state.cropRegion.y;\r\n  const cw = state.cropRegion.width;\r\n  const ch = state.cropRegion.height;\r\n  \r\n  const handles = [\r\n    // Corners\r\n    [cx, cy],                     // top-left\r\n    [cx + cw, cy],                // top-right\r\n    [cx, cy + ch],                // bottom-left\r\n    [cx + cw, cy + ch],           // bottom-right\r\n    // Edges\r\n    [cx + cw / 2, cy],            // top\r\n    [cx + cw, cy + ch / 2],       // right\r\n    [cx + cw / 2, cy + ch],       // bottom\r\n    [cx, cy + ch / 2],            // left\r\n  ];\r\n  \r\n  for (const [x, y] of handles) {\r\n    cropCtx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);\r\n  }\r\n}\r\n\r\nexport function cropImage(\r\n  image: RGBAImage,\r\n  crop: { x: number; y: number; width: number; height: number },\r\n): RGBAImage {\r\n  // Round crop coordinates to integers and ensure they're within bounds\r\n  const x = Math.max(0, Math.min(Math.round(crop.x), image.width - 1));\r\n  const y = Math.max(0, Math.min(Math.round(crop.y), image.height - 1));\r\n  const width = Math.max(1, Math.min(Math.round(crop.width), image.width - x));\r\n  const height = Math.max(1, Math.min(Math.round(crop.height), image.height - y));\r\n  \r\n  const croppedData = new Uint8ClampedArray(width * height * 4);\r\n  \r\n  for (let row = 0; row < height; row++) {\r\n    const srcOffset = ((y + row) * image.width + x) * 4;\r\n    const dstOffset = row * width * 4;\r\n    const copyLength = width * 4;\r\n    \r\n    // Ensure we don't read beyond the source image bounds\r\n    if (srcOffset + copyLength <= image.data.length) {\r\n      croppedData.set(\r\n        image.data.subarray(srcOffset, srcOffset + copyLength),\r\n        dstOffset,\r\n      );\r\n    }\r\n  }\r\n  \r\n  return { width, height, data: croppedData };\r\n}\r\n", "/**\r\n * Palette management and color editor\r\n */\r\n\r\nimport { DEFAULT_PALETTE } from \"../src/formats/palettized.ts\";\r\nimport { u32ToHex, hexToRGBA } from \"./utils.ts\";\r\nimport { state } from \"./state.ts\";\r\nimport { updateFile } from \"./storage.ts\";\r\n\r\n// Local state for color editor\r\nlet colorEditorIndex: number | null = null;\r\nlet eyedropperMode: 'input' | 'output' | null = null;\r\nlet eyedropperActive = false;\r\n\r\n// Callbacks that must be provided by main.ts\r\nlet showStatusCallback: (msg: string, isError?: boolean) => void = () => {};\r\nlet mainCanvasRef: HTMLCanvasElement | null = null;\r\n\r\n// Auto-save palette to the current file's storage\r\nasync function autosavePaletteToFile() {\r\n  if (state.currentFileId) {\r\n    try {\r\n      const palette = JSON.stringify(state.userPalette);\r\n      await updateFile(state.currentFileId, { palette });\r\n      console.log(\"Auto-saved palette to file storage\");\r\n    } catch (err) {\r\n      console.error(\"Failed to auto-save palette:\", err);\r\n    }\r\n  }\r\n}\r\n\r\nexport function initPaletteModule(callbacks: {\r\n  showStatus: (msg: string, isError?: boolean) => void;\r\n  mainCanvas: HTMLCanvasElement;\r\n}) {\r\n  showStatusCallback = callbacks.showStatus;\r\n  mainCanvasRef = callbacks.mainCanvas;\r\n}\r\n\r\n// IndexedDB for palette storage\r\nexport function initPaletteDB(): Promise<IDBDatabase> {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(\"PalettesDB\", 1);\r\n    request.onerror = () => reject(request.error);\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onupgradeneeded = (event) => {\r\n      const db = (event.target as IDBOpenDBRequest).result;\r\n      if (!db.objectStoreNames.contains(\"palettes\")) {\r\n        db.createObjectStore(\"palettes\", { keyPath: \"name\" });\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nexport async function savePalette(name: string) {\r\n  if (!name || name.trim() === \"\") {\r\n    showStatusCallback(\"Please enter a palette name\", true);\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    const db = await initPaletteDB();\r\n    const transaction = db.transaction([\"palettes\"], \"readwrite\");\r\n    const store = transaction.objectStore(\"palettes\");\r\n    \r\n    await store.put({\r\n      name: name.trim(),\r\n      palette: JSON.parse(JSON.stringify(state.userPalette)),\r\n      timestamp: Date.now(),\r\n    });\r\n    \r\n    showStatusCallback(`\u2713 Palette \"${name.trim()}\" saved`);\r\n  } catch (error) {\r\n    showStatusCallback(`Error saving palette: ${error}`, true);\r\n  }\r\n}\r\n\r\nexport async function loadPalette(name?: string) {\r\n  try {\r\n    const db = await initPaletteDB();\r\n    const transaction = db.transaction([\"palettes\"], \"readonly\");\r\n    const store = transaction.objectStore(\"palettes\");\r\n    \r\n    if (name) {\r\n      const request = store.get(name);\r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = () => {\r\n          if (request.result) {\r\n            state.userPalette.length = 0;\r\n            state.userPalette.push(...request.result.palette);\r\n            state.currentPaletteName = name;\r\n            renderPaletteUI();\r\n            showStatusCallback(`\u2713 Loaded palette \"${name}\"`);\r\n            resolve(request.result);\r\n          } else {\r\n            showStatusCallback(`Palette \"${name}\" not found`, true);\r\n            reject(new Error(\"Not found\"));\r\n          }\r\n        };\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } else {\r\n      // List all palettes for selection\r\n      const allRequest = store.getAll();\r\n      return new Promise((resolve, reject) => {\r\n        allRequest.onsuccess = () => {\r\n          const palettes = allRequest.result;\r\n          if (palettes.length === 0) {\r\n            showStatusCallback(\"No saved palettes\", true);\r\n            resolve([]);\r\n            return;\r\n          }\r\n          \r\n          // Create selection dialog\r\n          const names = palettes.map((p: { name: string }) => p.name).join(\"\\n\");\r\n          const selected = prompt(`Available palettes:\\n${names}\\n\\nEnter name to load:`);\r\n          \r\n          if (selected && palettes.some((p: { name: string }) => p.name === selected)) {\r\n            loadPalette(selected);\r\n          }\r\n          resolve(palettes);\r\n        };\r\n        allRequest.onerror = () => reject(allRequest.error);\r\n      });\r\n    }\r\n  } catch (error) {\r\n    showStatusCallback(`Error loading palette: ${error}`, true);\r\n  }\r\n}\r\n\r\nexport async function setDefaultPalette() {\r\n  const name = state.currentPaletteName || prompt(\"Enter name for this palette:\");\r\n  if (!name) return;\r\n  \r\n  localStorage.setItem(\"defaultPalette\", name);\r\n  await savePalette(name);\r\n  showStatusCallback(`\u2713 Set \"${name}\" as default palette`);\r\n}\r\n\r\nexport async function loadDefaultPalette() {\r\n  const defaultName = localStorage.getItem(\"defaultPalette\");\r\n  if (defaultName) {\r\n    try {\r\n      await loadPalette(defaultName);\r\n      showStatusCallback(`\u2713 Loaded default palette \"${defaultName}\"`);\r\n    } catch {\r\n      showStatusCallback(\"Default palette not found\", true);\r\n    }\r\n  }\r\n}\r\n\r\nexport function renderPaletteUI() {\r\n  const paletteDisplay = document.getElementById(\"paletteDisplay\") as HTMLDivElement;\r\n  if (!paletteDisplay) {\r\n    console.error(\"paletteDisplay not found in DOM!\");\r\n    return;\r\n  }\r\n  paletteDisplay.innerHTML = \"\";\r\n  \r\n  state.userPalette.forEach((color, index) => {\r\n    const item = document.createElement(\"div\");\r\n    item.style.cssText = \"display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem; border-bottom: 1px solid #3a3a3a; cursor: pointer; transition: background 0.2s;\";\r\n    item.onmouseover = () => item.style.background = \"#333\";\r\n    item.onmouseout = () => item.style.background = \"transparent\";\r\n    item.onclick = () => openColorEditor(index);\r\n    \r\n    // Input color swatch\r\n    const inputSwatch = document.createElement(\"div\");\r\n    inputSwatch.style.cssText = `width: 24px; height: 24px; border-radius: 4px; border: 2px solid ${index === 0 ? \"#4f46e5\" : \"#3a3a3a\"}; background: ${color.inputColor}; flex-shrink: 0;`;\r\n    item.appendChild(inputSwatch);\r\n    \r\n    // Status indicator and output\r\n    if (color.mapToBg) {\r\n      const statusIcon = document.createElement(\"span\");\r\n      statusIcon.textContent = \"\u2715\";\r\n      statusIcon.style.cssText = \"font-size: 0.9rem; color: #ef4444; flex-shrink: 0; width: 16px; text-align: center;\";\r\n      statusIcon.title = \"Remove\";\r\n      item.appendChild(statusIcon);\r\n    } else if (color.inputColor.toLowerCase() !== color.outputColor.toLowerCase()) {\r\n      const arrow = document.createElement(\"span\");\r\n      arrow.textContent = \"\u2192\";\r\n      arrow.style.cssText = \"font-size: 0.9rem; color: #999; flex-shrink: 0;\";\r\n      item.appendChild(arrow);\r\n      \r\n      const outputSwatch = document.createElement(\"div\");\r\n      outputSwatch.style.cssText = `width: 24px; height: 24px; border-radius: 4px; border: 2px solid ${index === 0 ? \"#4f46e5\" : \"#3a3a3a\"}; background: ${color.outputColor}; flex-shrink: 0;`;\r\n      item.appendChild(outputSwatch);\r\n    }\r\n    \r\n    // Hex value\r\n    const hexLabel = document.createElement(\"div\");\r\n    hexLabel.style.cssText = \"font-family: 'Courier New', monospace; font-size: 0.8rem; color: #aaa; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis;\";\r\n    hexLabel.textContent = color.inputColor.toUpperCase();\r\n    hexLabel.title = color.inputColor.toUpperCase();\r\n    item.appendChild(hexLabel);\r\n    \r\n    // Index indicator\r\n    if (index === 0) {\r\n      const bgLabel = document.createElement(\"span\");\r\n      bgLabel.textContent = \"BG\";\r\n      bgLabel.style.cssText = \"font-size: 0.7rem; color: #4f46e5; font-weight: 600; flex-shrink: 0; padding: 0.1rem 0.3rem; background: rgba(79, 70, 229, 0.2); border-radius: 3px;\";\r\n      item.appendChild(bgLabel);\r\n    }\r\n    \r\n    paletteDisplay.appendChild(item);\r\n  });\r\n}\r\n\r\nfunction openColorEditor(index: number) {\r\n  colorEditorIndex = index;\r\n  const color = state.userPalette[index];\r\n  \r\n  // Create or get color editor modal\r\n  let modal = document.getElementById(\"colorEditorModal\");\r\n  if (!modal) {\r\n    modal = document.createElement(\"div\");\r\n    modal.id = \"colorEditorModal\";\r\n    modal.style.cssText = `\r\n      position: fixed; top: 0; left: 0; right: 0; bottom: 0;\r\n      background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px);\r\n      z-index: 3000; display: flex; align-items: center; justify-content: center;\r\n    `;\r\n    document.body.appendChild(modal);\r\n  }\r\n  \r\n  modal.innerHTML = `\r\n    <div style=\"background: #1a1a1a; border: 2px solid #4f46e5; border-radius: 8px; padding: 1.5rem; min-width: 400px; max-width: 500px;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;\">\r\n        <h3 style=\"margin: 0; color: #fff;\">Edit Color ${index}${index === 0 ? ' (Background)' : ''}</h3>\r\n        <button id=\"closeColorEditor\" style=\"background: none; border: none; color: #999; font-size: 1.5rem; cursor: pointer; padding: 0; width: 32px; height: 32px;\">\u00D7</button>\r\n      </div>\r\n      \r\n      <div style=\"display: flex; flex-direction: column; gap: 1.25rem;\">\r\n        <!-- Input Color -->\r\n        <div style=\"display: flex; flex-direction: column; gap: 0.5rem;\">\r\n          <label style=\"color: #aaa; font-size: 0.9rem; font-weight: 500;\">Input Color (from document)</label>\r\n          <div style=\"display: flex; gap: 0.5rem; align-items: center;\">\r\n            <div style=\"width: 48px; height: 48px; border-radius: 6px; border: 2px solid #3a3a3a; background: ${color.inputColor}; flex-shrink: 0;\"></div>\r\n            <input type=\"text\" id=\"inputColorHex\" value=\"${color.inputColor}\" maxlength=\"7\" \r\n              style=\"flex: 1; padding: 0.75rem; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #fff; font-family: 'Courier New', monospace; font-size: 1rem;\">\r\n            <button id=\"eyedropperInput\" style=\"padding: 0.75rem; background: #4f46e5; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 1.2rem;\" title=\"Pick from canvas\">\uD83D\uDCA7</button>\r\n          </div>\r\n        </div>\r\n        \r\n        <!-- Output Options -->\r\n        <div style=\"display: flex; flex-direction: column; gap: 0.5rem;\">\r\n          <label style=\"color: #aaa; font-size: 0.9rem; font-weight: 500;\">Output (in vectorized result)</label>\r\n          \r\n          <div style=\"display: flex; gap: 0.75rem; margin-bottom: 0.5rem;\">\r\n            <label style=\"display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #fff;\">\r\n              <input type=\"radio\" name=\"outputMode\" value=\"same\" ${!color.mapToBg && color.inputColor === color.outputColor ? 'checked' : ''} style=\"cursor: pointer;\">\r\n              <span>Keep same color</span>\r\n            </label>\r\n            <label style=\"display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #fff;\">\r\n              <input type=\"radio\" name=\"outputMode\" value=\"different\" ${!color.mapToBg && color.inputColor !== color.outputColor ? 'checked' : ''} style=\"cursor: pointer;\">\r\n              <span>Transform to:</span>\r\n            </label>\r\n            <label style=\"display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #fff;\">\r\n              <input type=\"radio\" name=\"outputMode\" value=\"remove\" ${color.mapToBg ? 'checked' : ''} style=\"cursor: pointer;\">\r\n              <span style=\"color: #ef4444;\">Remove</span>\r\n            </label>\r\n          </div>\r\n          \r\n          <div id=\"outputColorSection\" style=\"display: flex; gap: 0.5rem; align-items: center; ${color.mapToBg || color.inputColor === color.outputColor ? 'opacity: 0.4; pointer-events: none;' : ''}\">\r\n            <div style=\"width: 48px; height: 48px; border-radius: 6px; border: 2px solid #3a3a3a; background: ${color.outputColor}; flex-shrink: 0;\"></div>\r\n            <input type=\"text\" id=\"outputColorHex\" value=\"${color.outputColor}\" maxlength=\"7\" \r\n              style=\"flex: 1; padding: 0.75rem; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #fff; font-family: 'Courier New', monospace; font-size: 1rem;\">\r\n            <button id=\"eyedropperOutput\" style=\"padding: 0.75rem; background: #4f46e5; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 1.2rem;\" title=\"Pick from canvas\">\uD83D\uDCA7</button>\r\n          </div>\r\n        </div>\r\n        \r\n        <!-- Action Buttons -->\r\n        <div style=\"display: flex; gap: 0.75rem; margin-top: 0.5rem;\">\r\n          <button id=\"saveColorEdit\" style=\"flex: 1; padding: 0.75rem; background: #4f46e5; border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600;\">Save</button>\r\n          ${index !== 0 ? '<button id=\"deleteColor\" style=\"padding: 0.75rem 1.25rem; background: #ef4444; border: none; border-radius: 4px; color: white; cursor: pointer;\">Delete</button>' : ''}\r\n          <button id=\"cancelColorEdit\" style=\"padding: 0.75rem 1.25rem; background: #3a3a3a; border: none; border-radius: 4px; color: white; cursor: pointer;\">Cancel</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `;\r\n  \r\n  modal.style.display = \"flex\";\r\n  \r\n  // Setup event listeners\r\n  const inputHexField = document.getElementById(\"inputColorHex\") as HTMLInputElement;\r\n  const outputHexField = document.getElementById(\"outputColorHex\") as HTMLInputElement;\r\n  const outputSection = document.getElementById(\"outputColorSection\") as HTMLDivElement;\r\n  const outputModeRadios = document.getElementsByName(\"outputMode\") as NodeListOf<HTMLInputElement>;\r\n  \r\n  // Update output section visibility based on mode\r\n  outputModeRadios.forEach(radio => {\r\n    radio.addEventListener(\"change\", () => {\r\n      if (radio.value === \"different\") {\r\n        outputSection.style.opacity = \"1\";\r\n        outputSection.style.pointerEvents = \"auto\";\r\n      } else {\r\n        outputSection.style.opacity = \"0.4\";\r\n        outputSection.style.pointerEvents = \"none\";\r\n      }\r\n    });\r\n  });\r\n  \r\n  // Eyedropper buttons\r\n  document.getElementById(\"eyedropperInput\")!.addEventListener(\"click\", () => {\r\n    eyedropperMode = 'input';\r\n    activateEyedropper();\r\n    modal!.style.display = \"none\";\r\n  });\r\n  \r\n  document.getElementById(\"eyedropperOutput\")!.addEventListener(\"click\", () => {\r\n    eyedropperMode = 'output';\r\n    activateEyedropper();\r\n    modal!.style.display = \"none\";\r\n  });\r\n  \r\n  // Save button\r\n  document.getElementById(\"saveColorEdit\")!.addEventListener(\"click\", () => {\r\n    const inputColor = inputHexField.value;\r\n    const outputColor = outputHexField.value;\r\n    const selectedMode = Array.from(outputModeRadios).find(r => r.checked)?.value;\r\n    \r\n    if (!/^#[0-9A-Fa-f]{6}$/.test(inputColor)) {\r\n      alert(\"Invalid input color format. Use #RRGGBB\");\r\n      return;\r\n    }\r\n    \r\n    if (selectedMode === 'different' && !/^#[0-9A-Fa-f]{6}$/.test(outputColor)) {\r\n      alert(\"Invalid output color format. Use #RRGGBB\");\r\n      return;\r\n    }\r\n    \r\n    state.userPalette[index].inputColor = inputColor;\r\n    \r\n    if (selectedMode === 'remove') {\r\n      state.userPalette[index].mapToBg = true;\r\n      state.userPalette[index].outputColor = inputColor; // Keep it same for display\r\n    } else if (selectedMode === 'different') {\r\n      state.userPalette[index].mapToBg = false;\r\n      state.userPalette[index].outputColor = outputColor;\r\n    } else { // same\r\n      state.userPalette[index].mapToBg = false;\r\n      state.userPalette[index].outputColor = inputColor;\r\n    }\r\n    \r\n    renderPaletteUI();\r\n    autosavePaletteToFile();\r\n    closeColorEditor();\r\n  });\r\n  \r\n  // Delete button\r\n  const deleteBtn = document.getElementById(\"deleteColor\");\r\n  if (deleteBtn) {\r\n    deleteBtn.addEventListener(\"click\", () => {\r\n      if (index !== 0 && confirm(\"Delete this color?\")) {\r\n        state.userPalette.splice(index, 1);\r\n        renderPaletteUI();\r\n        autosavePaletteToFile();\r\n        closeColorEditor();\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Cancel/Close buttons\r\n  document.getElementById(\"cancelColorEdit\")!.addEventListener(\"click\", closeColorEditor);\r\n  document.getElementById(\"closeColorEditor\")!.addEventListener(\"click\", closeColorEditor);\r\n  \r\n  // Click outside to close\r\n  modal.addEventListener(\"click\", (e) => {\r\n    if (e.target === modal) closeColorEditor();\r\n  });\r\n}\r\n\r\nfunction closeColorEditor() {\r\n  const modal = document.getElementById(\"colorEditorModal\");\r\n  if (modal) modal.style.display = \"none\";\r\n  colorEditorIndex = null;\r\n  eyedropperMode = null;\r\n}\r\n\r\nexport function addPaletteColor() {\r\n  if (state.userPalette.length >= 16) {\r\n    showStatusCallback(\"Maximum 16 colors allowed\", true);\r\n    return;\r\n  }\r\n  \r\n  const newIndex = state.userPalette.length;\r\n  state.userPalette.push({\r\n    inputColor: \"#808080\",\r\n    outputColor: \"#808080\",\r\n    mapToBg: false,\r\n  });\r\n  \r\n  renderPaletteUI();\r\n  autosavePaletteToFile();\r\n  \r\n  // Immediately open editor for the new color\r\n  openColorEditor(newIndex);\r\n}\r\n\r\nexport function resetPaletteToDefault() {\r\n  state.userPalette.length = 0;\r\n  Array.from(DEFAULT_PALETTE).forEach(color => {\r\n    state.userPalette.push({\r\n      inputColor: u32ToHex(color),\r\n      outputColor: u32ToHex(color),\r\n      mapToBg: false,\r\n    });\r\n  });\r\n  renderPaletteUI();\r\n  autosavePaletteToFile();\r\n  showStatusCallback(\"Palette reset to default\");\r\n}\r\n\r\nfunction activateEyedropper() {\r\n  if (!state.currentImage) {\r\n    showStatusCallback(\"No image loaded\", true);\r\n    return;\r\n  }\r\n  \r\n  if (!mainCanvasRef) {\r\n    showStatusCallback(\"Canvas not initialized\", true);\r\n    return;\r\n  }\r\n  \r\n  eyedropperActive = true;\r\n  document.body.classList.add(\"eyedropper-active\");\r\n  mainCanvasRef.style.cursor = \"crosshair\";\r\n  showStatusCallback(\"\uD83D\uDCA7 Click on the image to pick a color (ESC to cancel)\");\r\n}\r\n\r\nfunction deactivateEyedropper() {\r\n  if (!mainCanvasRef) return;\r\n  \r\n  eyedropperActive = false;\r\n  document.body.classList.remove(\"eyedropper-active\");\r\n  mainCanvasRef.style.cursor = \"\";\r\n  showStatusCallback(\"Eyedropper cancelled\");\r\n}\r\n\r\nexport function pickColorFromCanvas(x: number, y: number) {\r\n  if (!state.currentImage || !mainCanvasRef) return;\r\n  \r\n  // Convert canvas coordinates to image coordinates\r\n  const rect = mainCanvasRef.getBoundingClientRect();\r\n  const scaleX = state.currentImage.width / rect.width;\r\n  const scaleY = state.currentImage.height / rect.height;\r\n  const imgX = Math.floor((x - rect.left) * scaleX);\r\n  const imgY = Math.floor((y - rect.top) * scaleY);\r\n  \r\n  // Check bounds\r\n  if (imgX < 0 || imgX >= state.currentImage.width || imgY < 0 || imgY >= state.currentImage.height) {\r\n    return;\r\n  }\r\n  \r\n  // Get pixel color\r\n  const pixelIndex = (imgY * state.currentImage.width + imgX) * 4;\r\n  const r = state.currentImage.data[pixelIndex];\r\n  const g = state.currentImage.data[pixelIndex + 1];\r\n  const b = state.currentImage.data[pixelIndex + 2];\r\n  \r\n  const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\r\n  \r\n  deactivateEyedropper();\r\n  \r\n  // If we're in color editor mode, update the color editor\r\n  if (colorEditorIndex !== null && eyedropperMode) {\r\n    if (eyedropperMode === 'input') {\r\n      state.userPalette[colorEditorIndex].inputColor = hex;\r\n    } else if (eyedropperMode === 'output') {\r\n      state.userPalette[colorEditorIndex].outputColor = hex;\r\n      state.userPalette[colorEditorIndex].mapToBg = false; // Ensure it's not set to remove\r\n    }\r\n    autosavePaletteToFile();\r\n    // Reopen the color editor with updated values\r\n    openColorEditor(colorEditorIndex);\r\n    showStatusCallback(`Picked ${hex.toUpperCase()}`);\r\n  } else {\r\n    // Old behavior: add to palette\r\n    addColorToPalette(hex);\r\n    showStatusCallback(`Added ${hex.toUpperCase()} to palette`);\r\n  }\r\n}\r\n\r\nfunction addColorToPalette(hex: string) {\r\n  if (state.userPalette.length >= 16) {\r\n    showStatusCallback(\"Maximum 16 colors - remove one first\", true);\r\n    return;\r\n  }\r\n  \r\n  state.userPalette.push({\r\n    inputColor: hex,\r\n    outputColor: hex,\r\n    mapToBg: false,\r\n  });\r\n  \r\n  renderPaletteUI();\r\n  showStatusCallback(`Added ${hex} to palette`);\r\n}\r\n\r\n// Convert state.userPalette to RGBA format for GPU processing\r\nexport function buildPaletteRGBA(): Uint8ClampedArray {\r\n  const palette = new Uint8ClampedArray(16 * 4);\r\n  \r\n  for (let i = 0; i < state.userPalette.length && i < 16; i++) {\r\n    const color = state.userPalette[i];\r\n    // Use INPUT color for matching - GPU will find nearest input color\r\n    // The palette stored with the result contains OUTPUT colors for display\r\n    const [r, g, b, a] = hexToRGBA(color.inputColor);\r\n    \r\n    palette[i * 4] = r;\r\n    palette[i * 4 + 1] = g;\r\n    palette[i * 4 + 2] = b;\r\n    palette[i * 4 + 3] = a;\r\n  }\r\n  \r\n  // Fill remaining slots with background color\r\n  for (let i = state.userPalette.length; i < 16; i++) {\r\n    const [r, g, b, a] = hexToRGBA(state.userPalette[0].inputColor);\r\n    palette[i * 4] = r;\r\n    palette[i * 4 + 1] = g;\r\n    palette[i * 4 + 2] = b;\r\n    palette[i * 4 + 3] = a;\r\n  }\r\n  \r\n  return palette;\r\n}\r\n\r\n// Check if eyedropper is active (for event handling in main.ts)\r\nexport function isEyedropperActive(): boolean {\r\n  return eyedropperActive;\r\n}\r\n\r\n// Force deactivate (e.g., on ESC key)\r\nexport function forceDeactivateEyedropper() {\r\n  if (eyedropperActive) {\r\n    deactivateEyedropper();\r\n  }\r\n}\r\n", "/**\r\n * Binary image format\r\n * 1 bit per pixel, stored as 8 pixels per byte, MSB-first\r\n */\r\nexport interface BinaryImage {\r\n    width: number;\r\n    height: number;\r\n    data: Uint8Array; // length = ceil(width * height / 8)\r\n}\r\n\r\n/**\r\n * Create an empty binary image\r\n */\r\nexport function createBinaryImage(width: number, height: number): BinaryImage {\r\n    const size = Math.ceil((width * height) / 8);\r\n    return {\r\n        width,\r\n        height,\r\n        data: new Uint8Array(size),\r\n    };\r\n}\r\n\r\n/**\r\n * Get pixel value at (x, y)\r\n * Returns 0 or 1\r\n */\r\nexport function getPixelBin(\r\n    img: BinaryImage,\r\n    x: number,\r\n    y: number,\r\n): 0 | 1 {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 8);\r\n    const bitIndex = 7 - (pixelIndex % 8); // MSB-first\r\n\r\n    return ((img.data[byteIndex] >> bitIndex) & 1) as 0 | 1;\r\n}\r\n\r\n/**\r\n * Set pixel value at (x, y)\r\n * value must be 0 or 1\r\n */\r\nexport function setPixelBin(\r\n    img: BinaryImage,\r\n    x: number,\r\n    y: number,\r\n    value: 0 | 1,\r\n): void {\r\n    const pixelIndex = y * img.width + x;\r\n    const byteIndex = Math.floor(pixelIndex / 8);\r\n    const bitIndex = 7 - (pixelIndex % 8); // MSB-first\r\n\r\n    if (value === 1) {\r\n        img.data[byteIndex] |= 1 << bitIndex;\r\n    } else {\r\n        img.data[byteIndex] &= ~(1 << bitIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Clone a binary image\r\n */\r\nexport function cloneBinaryImage(img: BinaryImage): BinaryImage {\r\n    return {\r\n        width: img.width,\r\n        height: img.height,\r\n        data: new Uint8Array(img.data),\r\n    };\r\n}\r\n", "import { type BinaryImage, getPixelBin } from \"../formats/binary.ts\";\r\nimport type { Point } from \"./geometry.ts\";\r\n\r\nexport interface GraphNode {\r\n  id: number; // pixel ID (y * width + x)\r\n  point: Point;\r\n  edges: number[]; // indices into edges array\r\n}\r\n\r\nexport interface GraphEdge {\r\n  id: number;\r\n  points: Point[]; // Ordered list of pixels in the edge\r\n  nodeA: number; // Node ID at start (-1 if loop)\r\n  nodeB: number; // Node ID at end (-1 if loop)\r\n}\r\n\r\nexport interface Graph {\r\n  nodes: Map<number, GraphNode>;\r\n  edges: GraphEdge[];\r\n}\r\n\r\n/**\r\n * Traces connected paths in a binary image into a graph structure.\r\n * Converts raster pixels into vector paths with topology.\r\n */\r\nexport function traceGraph(binary: BinaryImage): Graph {\r\n  const width = binary.width;\r\n  const height = binary.height;\r\n  const nodes = new Map<number, GraphNode>();\r\n  const edges: GraphEdge[] = [];\r\n  const visitedEdges = new Set<string>(); // Stores \"id1-id2\" for visited edge segments\r\n\r\n  const getVertexId = (x: number, y: number) => y * width + x;\r\n\r\n  const isPixelSet = (x: number, y: number) => {\r\n    if (x < 0 || x >= width || y < 0 || y >= height) return false;\r\n    return getPixelBin(binary, x, y) === 1;\r\n  };\r\n\r\n  const getNeighbors = (x: number, y: number): Point[] => {\r\n    const neighbors: Point[] = [];\r\n\r\n    // Cardinal directions first\r\n    const cardinalOffsets: Point[] = [\r\n      { x: 0, y: -1 },\r\n      { x: 1, y: 0 },\r\n      { x: 0, y: 1 },\r\n      { x: -1, y: 0 },\r\n    ];\r\n\r\n    for (const offset of cardinalOffsets) {\r\n      const nx = x + offset.x;\r\n      const ny = y + offset.y;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        if (isPixelSet(nx, ny)) {\r\n          neighbors.push({ x: nx, y: ny });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Then diagonals (only if no stair-step path exists)\r\n    const diagonalOffsets: Point[] = [\r\n      { x: -1, y: -1 },\r\n      { x: 1, y: -1 },\r\n      { x: -1, y: 1 },\r\n      { x: 1, y: 1 },\r\n    ];\r\n\r\n    for (const offset of diagonalOffsets) {\r\n      const nx = x + offset.x;\r\n      const ny = y + offset.y;\r\n      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n        if (isPixelSet(nx, ny)) {\r\n          // Check if there's a stair-step path to this diagonal\r\n          const hasStairStep = cardinalOffsets.some((cardinal) => {\r\n            const cx = x + cardinal.x;\r\n            const cy = y + cardinal.y;\r\n            if (\r\n              cx >= 0 && cx < width && cy >= 0 && cy < height &&\r\n              isPixelSet(cx, cy)\r\n            ) {\r\n              const dcx = nx - cx;\r\n              const dcy = ny - cy;\r\n              return Math.abs(dcx) + Math.abs(dcy) === 1;\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (!hasStairStep) {\r\n            neighbors.push({ x: nx, y: ny });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return neighbors;\r\n  };\r\n\r\n  // Pass 1: Identify Nodes\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (isPixelSet(x, y)) {\r\n        const neighbors = getNeighbors(x, y);\r\n        // A node is any pixel that is NOT a simple path continuation (degree 2)\r\n        // Degree 0: Isolated point (Node)\r\n        // Degree 1: Endpoint (Node)\r\n        // Degree 3+: Junction (Node)\r\n        if (neighbors.length !== 2) {\r\n          const id = getVertexId(x, y);\r\n          nodes.set(id, {\r\n            id,\r\n            point: { x, y },\r\n            edges: [],\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Helper to get edge key\r\n  const getEdgeKey = (id1: number, id2: number) => {\r\n    return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`;\r\n  };\r\n\r\n  // Pass 2: Trace Edges from Nodes\r\n  for (const node of nodes.values()) {\r\n    const startNeighbors = getNeighbors(node.point.x, node.point.y);\r\n\r\n    for (const neighbor of startNeighbors) {\r\n      const neighborId = getVertexId(neighbor.x, neighbor.y);\r\n      const edgeKey = getEdgeKey(node.id, neighborId);\r\n\r\n      if (visitedEdges.has(edgeKey)) continue;\r\n\r\n      // Start tracing a new edge\r\n      const pathPoints: Point[] = [node.point, neighbor];\r\n      visitedEdges.add(edgeKey);\r\n\r\n      let currentId = neighborId;\r\n      let currentPoint = neighbor;\r\n      let prevId = node.id;\r\n\r\n      while (true) {\r\n        // If current point is a node, we are done\r\n        if (nodes.has(currentId)) {\r\n          const edgeIndex = edges.length;\r\n          const endNode = nodes.get(currentId)!;\r\n\r\n          // Add edge to graph\r\n          edges.push({\r\n            id: edgeIndex,\r\n            points: pathPoints,\r\n            nodeA: node.id,\r\n            nodeB: endNode.id,\r\n          });\r\n\r\n          // Link nodes to edge\r\n          node.edges.push(edgeIndex);\r\n          // Avoid adding duplicate edge reference if startNode == endNode (loop back to self)\r\n          if (node.id !== endNode.id) {\r\n            endNode.edges.push(edgeIndex);\r\n          } else {\r\n            node.edges.push(edgeIndex);\r\n          }\r\n          break;\r\n        }\r\n\r\n        // Continue tracing\r\n        const neighbors = getNeighbors(currentPoint.x, currentPoint.y);\r\n        // Find the neighbor that is NOT the previous one\r\n        const next = neighbors.find((n) => getVertexId(n.x, n.y) !== prevId);\r\n\r\n        if (!next) {\r\n          // Should not happen if logic is correct (degree 2 check)\r\n          // But if it does, treat as endpoint (which should have been a node)\r\n          break;\r\n        }\r\n\r\n        const nextId = getVertexId(next.x, next.y);\r\n        const nextKey = getEdgeKey(currentId, nextId);\r\n\r\n        visitedEdges.add(nextKey);\r\n        pathPoints.push(next);\r\n\r\n        prevId = currentId;\r\n        currentId = nextId;\r\n        currentPoint = next;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Pass 3: Trace Isolated Loops (no nodes)\r\n  // Populate visited pixels from existing edges\r\n  const processedPixels = new Set<number>();\r\n  for (const edge of edges) {\r\n    for (const p of edge.points) {\r\n      processedPixels.add(getVertexId(p.x, p.y));\r\n    }\r\n  }\r\n  for (const node of nodes.values()) {\r\n    processedPixels.add(node.id);\r\n  }\r\n\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      const id = getVertexId(x, y);\r\n      if (isPixelSet(x, y) && !processedPixels.has(id)) {\r\n        // Found a start of a loop\r\n        const pathPoints: Point[] = [{ x, y }];\r\n        processedPixels.add(id);\r\n\r\n        let currentPoint = { x, y };\r\n        let currentId = id;\r\n        let prevId = -1; // No previous for start\r\n\r\n        // Trace forward\r\n        while (true) {\r\n          const neighbors = getNeighbors(currentPoint.x, currentPoint.y);\r\n          let next: Point | undefined;\r\n\r\n          if (prevId === -1) {\r\n            next = neighbors[0]; // Pick any direction\r\n          } else {\r\n            next = neighbors.find((n) => getVertexId(n.x, n.y) !== prevId);\r\n          }\r\n\r\n          if (!next) break; // Should be closed loop\r\n\r\n          const nextId = getVertexId(next.x, next.y);\r\n\r\n          if (nextId === id && prevId !== -1) {\r\n            // Closed the loop\r\n            pathPoints.push(next);\r\n            break;\r\n          }\r\n\r\n          if (processedPixels.has(nextId)) {\r\n            break;\r\n          }\r\n\r\n          processedPixels.add(nextId);\r\n          pathPoints.push(next);\r\n          prevId = currentId;\r\n          currentId = nextId;\r\n          currentPoint = next;\r\n        }\r\n\r\n        const edgeIndex = edges.length;\r\n        edges.push({\r\n          id: edgeIndex,\r\n          points: pathPoints,\r\n          nodeA: -1,\r\n          nodeB: -1,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return { nodes, edges };\r\n}\r\n", "/**\r\n * Core geometric primitives and operations for vectorization\r\n */\r\n\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface Line {\r\n  /** Point on the line */\r\n  point: Point;\r\n  /** Unit direction vector */\r\n  direction: Point;\r\n}\r\n\r\nexport interface Arc {\r\n  center: Point;\r\n  radius: number;\r\n  /** Start angle in radians */\r\n  startAngle: number;\r\n  /** End angle in radians */\r\n  endAngle: number;\r\n  /** True if arc goes clockwise from start to end */\r\n  clockwise: boolean;\r\n}\r\n\r\nexport interface Circle {\r\n  center: Point;\r\n  radius: number;\r\n}\r\n\r\n// ============================================================================\r\n// Point Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate distance between two points\r\n */\r\nexport function distance(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\n/**\r\n * Calculate squared distance (faster when you don't need actual distance)\r\n */\r\nexport function distanceSquared(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Add two points (vector addition)\r\n */\r\nexport function add(p1: Point, p2: Point): Point {\r\n  return { x: p1.x + p2.x, y: p1.y + p2.y };\r\n}\r\n\r\n/**\r\n * Subtract two points (vector subtraction)\r\n */\r\nexport function subtract(p1: Point, p2: Point): Point {\r\n  return { x: p1.x - p2.x, y: p1.y - p2.y };\r\n}\r\n\r\n/**\r\n * Scale a point/vector by a scalar\r\n */\r\nexport function scale(p: Point, s: number): Point {\r\n  return { x: p.x * s, y: p.y * s };\r\n}\r\n\r\n/**\r\n * Calculate dot product of two vectors\r\n */\r\nexport function dot(p1: Point, p2: Point): number {\r\n  return p1.x * p2.x + p1.y * p2.y;\r\n}\r\n\r\n/**\r\n * Calculate cross product magnitude (z-component of 3D cross product)\r\n */\r\nexport function cross(p1: Point, p2: Point): number {\r\n  return p1.x * p2.y - p1.y * p2.x;\r\n}\r\n\r\n/**\r\n * Calculate magnitude (length) of a vector\r\n */\r\nexport function magnitude(p: Point): number {\r\n  return Math.sqrt(p.x * p.x + p.y * p.y);\r\n}\r\n\r\n/**\r\n * Normalize a vector to unit length\r\n */\r\nexport function normalize(p: Point): Point {\r\n  const mag = magnitude(p);\r\n  if (mag < 1e-10) {\r\n    return { x: 0, y: 0 };\r\n  }\r\n  return { x: p.x / mag, y: p.y / mag };\r\n}\r\n\r\n/**\r\n * Calculate angle of a vector in radians (-\u03C0 to \u03C0)\r\n */\r\nexport function angle(p: Point): number {\r\n  return Math.atan2(p.y, p.x);\r\n}\r\n\r\n/**\r\n * Calculate angle between two vectors in radians (0 to \u03C0)\r\n */\r\nexport function angleBetween(p1: Point, p2: Point): number {\r\n  const mag1 = magnitude(p1);\r\n  const mag2 = magnitude(p2);\r\n  if (mag1 < 1e-10 || mag2 < 1e-10) {\r\n    return 0;\r\n  }\r\n  const cosAngle = dot(p1, p2) / (mag1 * mag2);\r\n  // Clamp to handle floating point errors\r\n  return Math.acos(Math.max(-1, Math.min(1, cosAngle)));\r\n}\r\n\r\n/**\r\n * Rotate a point around the origin by an angle in radians\r\n */\r\nexport function rotate(p: Point, angleRad: number): Point {\r\n  const cos = Math.cos(angleRad);\r\n  const sin = Math.sin(angleRad);\r\n  return {\r\n    x: p.x * cos - p.y * sin,\r\n    y: p.x * sin + p.y * cos,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if two points are approximately equal within tolerance\r\n */\r\nexport function pointsEqual(p1: Point, p2: Point, tolerance = 1e-6): boolean {\r\n  return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance;\r\n}\r\n\r\n// ============================================================================\r\n// Line Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Create a line from two points\r\n */\r\nexport function lineFromPoints(p1: Point, p2: Point): Line | null {\r\n  const dir = subtract(p2, p1);\r\n  const mag = magnitude(dir);\r\n  if (mag < 1e-10) {\r\n    return null; // Points are too close\r\n  }\r\n  return {\r\n    point: p1,\r\n    direction: normalize(dir),\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate perpendicular distance from a point to a line\r\n */\r\nexport function distanceToLine(point: Point, line: Line): number {\r\n  const toPoint = subtract(point, line.point);\r\n  // Distance is |toPoint \u00D7 direction| since direction is unit length\r\n  return Math.abs(cross(toPoint, line.direction));\r\n}\r\n\r\n/**\r\n * Project a point onto a line (closest point on line to the given point)\r\n */\r\nexport function projectPointOnLine(point: Point, line: Line): Point {\r\n  const toPoint = subtract(point, line.point);\r\n  const projection = dot(toPoint, line.direction);\r\n  return add(line.point, scale(line.direction, projection));\r\n}\r\n\r\n/**\r\n * Calculate parameter t where point lies on line (line.point + t * line.direction)\r\n */\r\nexport function lineParameter(point: Point, line: Line): number {\r\n  const toPoint = subtract(point, line.point);\r\n  return dot(toPoint, line.direction);\r\n}\r\n\r\n/**\r\n * Find intersection point of two lines\r\n * Returns null if lines are parallel\r\n */\r\nexport function lineLineIntersection(\r\n  line1: Line,\r\n  line2: Line,\r\n  tolerance = 1e-6,\r\n): Point | null {\r\n  const d1 = line1.direction;\r\n  const d2 = line2.direction;\r\n  const crossProduct = cross(d1, d2);\r\n\r\n  // Check if lines are parallel\r\n  if (Math.abs(crossProduct) < tolerance) {\r\n    return null;\r\n  }\r\n\r\n  const diff = subtract(line2.point, line1.point);\r\n  const t = cross(diff, d2) / crossProduct;\r\n\r\n  return add(line1.point, scale(d1, t));\r\n}\r\n\r\n// ============================================================================\r\n// Circle Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate distance from a point to the circle perimeter\r\n * Positive means outside, negative means inside\r\n */\r\nexport function distanceToCircle(point: Point, circle: Circle): number {\r\n  return distance(point, circle.center) - circle.radius;\r\n}\r\n\r\n/**\r\n * Project a point onto a circle (closest point on circle to the given point)\r\n */\r\nexport function projectPointOnCircle(point: Point, circle: Circle): Point {\r\n  const toPoint = subtract(point, circle.center);\r\n  const dir = normalize(toPoint);\r\n  return add(circle.center, scale(dir, circle.radius));\r\n}\r\n\r\n/**\r\n * Calculate angle of a point relative to circle center\r\n */\r\nexport function angleOnCircle(point: Point, circle: Circle): number {\r\n  const toPoint = subtract(point, circle.center);\r\n  return angle(toPoint);\r\n}\r\n\r\n/**\r\n * Find intersection points of a line and a circle\r\n * Returns 0, 1, or 2 intersection points\r\n */\r\nexport function lineCircleIntersection(\r\n  line: Line,\r\n  circle: Circle,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  // Vector from line point to circle center\r\n  const toCenter = subtract(circle.center, line.point);\r\n\r\n  // Project center onto line\r\n  const projection = dot(toCenter, line.direction);\r\n\r\n  // Closest point on line to center\r\n  const closest = add(line.point, scale(line.direction, projection));\r\n\r\n  // Distance from center to line\r\n  const distToLine = distance(circle.center, closest);\r\n\r\n  // No intersection if line is too far from circle\r\n  if (distToLine > circle.radius + tolerance) {\r\n    return [];\r\n  }\r\n\r\n  // Tangent case (1 intersection)\r\n  if (Math.abs(distToLine - circle.radius) < tolerance) {\r\n    return [closest];\r\n  }\r\n\r\n  // Two intersections\r\n  const halfChord = Math.sqrt(\r\n    circle.radius * circle.radius - distToLine * distToLine,\r\n  );\r\n  const offset = scale(line.direction, halfChord);\r\n\r\n  return [\r\n    subtract(closest, offset),\r\n    add(closest, offset),\r\n  ];\r\n}\r\n\r\n/**\r\n * Find intersection points of two circles\r\n * Returns 0, 1, or 2 intersection points\r\n */\r\nexport function circleCircleIntersection(\r\n  c1: Circle,\r\n  c2: Circle,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  const d = distance(c1.center, c2.center);\r\n\r\n  // No intersection if circles are too far apart or one contains the other\r\n  if (\r\n    d > c1.radius + c2.radius + tolerance ||\r\n    d < Math.abs(c1.radius - c2.radius) - tolerance\r\n  ) {\r\n    return [];\r\n  }\r\n\r\n  // Same circle\r\n  if (d < tolerance && Math.abs(c1.radius - c2.radius) < tolerance) {\r\n    return []; // Infinite intersections, return empty\r\n  }\r\n\r\n  // Calculate intersection points\r\n  const a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);\r\n  const h = Math.sqrt(c1.radius * c1.radius - a * a);\r\n\r\n  const toC2 = subtract(c2.center, c1.center);\r\n  const unit = normalize(toC2);\r\n  const midpoint = add(c1.center, scale(unit, a));\r\n\r\n  // Tangent case (1 intersection)\r\n  if (Math.abs(h) < tolerance) {\r\n    return [midpoint];\r\n  }\r\n\r\n  // Perpendicular offset\r\n  const perpendicular = { x: -unit.y, y: unit.x };\r\n  const offset = scale(perpendicular, h);\r\n\r\n  return [\r\n    add(midpoint, offset),\r\n    subtract(midpoint, offset),\r\n  ];\r\n}\r\n\r\n// ============================================================================\r\n// Arc Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Normalize angle to range [-\u03C0, \u03C0]\r\n */\r\nexport function normalizeAngle(angleRad: number): number {\r\n  let normalized = angleRad % (2 * Math.PI);\r\n  if (normalized > Math.PI) normalized -= 2 * Math.PI;\r\n  if (normalized < -Math.PI) normalized += 2 * Math.PI;\r\n  return normalized;\r\n}\r\n\r\n/**\r\n * Calculate sweep angle of an arc\r\n * Always returns positive value\r\n */\r\nexport function arcSweepAngle(arc: Arc): number {\r\n  let sweep = arc.endAngle - arc.startAngle;\r\n  if (arc.clockwise) {\r\n    if (sweep > 0) sweep -= 2 * Math.PI;\r\n    return -sweep;\r\n  } else {\r\n    if (sweep < 0) sweep += 2 * Math.PI;\r\n    return sweep;\r\n  }\r\n}\r\n\r\n/**\r\n * Get point on arc at a specific angle\r\n */\r\nexport function pointOnArc(arc: Arc, angleRad: number): Point {\r\n  return {\r\n    x: arc.center.x + arc.radius * Math.cos(angleRad),\r\n    y: arc.center.y + arc.radius * Math.sin(angleRad),\r\n  };\r\n}\r\n\r\n/**\r\n * Get start point of an arc\r\n */\r\nexport function arcStartPoint(arc: Arc): Point {\r\n  return pointOnArc(arc, arc.startAngle);\r\n}\r\n\r\n/**\r\n * Get end point of an arc\r\n */\r\nexport function arcEndPoint(arc: Arc): Point {\r\n  return pointOnArc(arc, arc.endAngle);\r\n}\r\n\r\n/**\r\n * Check if an angle is within the arc's sweep\r\n */\r\nexport function isAngleInArc(arc: Arc, angleRad: number): boolean {\r\n  const normalized = normalizeAngle(angleRad);\r\n  const start = normalizeAngle(arc.startAngle);\r\n  const end = normalizeAngle(arc.endAngle);\r\n\r\n  if (arc.clockwise) {\r\n    if (start > end) {\r\n      return normalized <= start && normalized >= end;\r\n    } else {\r\n      return normalized <= start || normalized >= end;\r\n    }\r\n  } else {\r\n    if (start < end) {\r\n      return normalized >= start && normalized <= end;\r\n    } else {\r\n      return normalized >= start || normalized <= end;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate perpendicular distance from a point to an arc\r\n * Returns the minimum distance considering the arc's extent\r\n */\r\nexport function distanceToArc(point: Point, arc: Arc): number {\r\n  const angleToPoint = angleOnCircle(point, arc);\r\n\r\n  // If the point projects onto the arc, use circle distance\r\n  if (isAngleInArc(arc, angleToPoint)) {\r\n    return Math.abs(distanceToCircle(point, arc));\r\n  }\r\n\r\n  // Otherwise, use distance to nearest endpoint\r\n  const startPoint = arcStartPoint(arc);\r\n  const endPoint = arcEndPoint(arc);\r\n  return Math.min(\r\n    distance(point, startPoint),\r\n    distance(point, endPoint),\r\n  );\r\n}\r\n\r\n/**\r\n * Find intersection points of a line and an arc\r\n */\r\nexport function lineArcIntersection(\r\n  line: Line,\r\n  arc: Arc,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  // First find line-circle intersections\r\n  const circleIntersections = lineCircleIntersection(line, arc, tolerance);\r\n\r\n  // Filter to only points that lie on the arc\r\n  return circleIntersections.filter((point) => {\r\n    const angleToPoint = angleOnCircle(point, arc);\r\n    return isAngleInArc(arc, angleToPoint);\r\n  });\r\n}\r\n\r\n/**\r\n * Find intersection points of two arcs\r\n */\r\nexport function arcArcIntersection(\r\n  arc1: Arc,\r\n  arc2: Arc,\r\n  tolerance = 1e-6,\r\n): Point[] {\r\n  // First find circle-circle intersections\r\n  const circleIntersections = circleCircleIntersection(arc1, arc2, tolerance);\r\n\r\n  // Filter to only points that lie on both arcs\r\n  return circleIntersections.filter((point) => {\r\n    const angle1 = angleOnCircle(point, arc1);\r\n    const angle2 = angleOnCircle(point, arc2);\r\n    return isAngleInArc(arc1, angle1) && isAngleInArc(arc2, angle2);\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// 3-Point Arc Operations\r\n// ============================================================================\r\n\r\nexport interface Arc3Point {\r\n  start: Point;\r\n  end: Point;\r\n  mid: Point; // A point on the arc\r\n}\r\n\r\n/**\r\n * Convert 3-point arc to center/radius representation\r\n * Returns null if points are collinear (it's a line, not an arc)\r\n */\r\nexport function arc3PointToArc(arc3: Arc3Point): Arc | null {\r\n  const { start, end, mid } = arc3;\r\n\r\n  // Check for collinearity\r\n  // If area of triangle is 0, they are collinear\r\n  // Area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\r\n  const area = 0.5 * Math.abs(\r\n    start.x * (mid.y - end.y) +\r\n      mid.x * (end.y - start.y) +\r\n      end.x * (start.y - mid.y),\r\n  );\r\n\r\n  if (area < 1e-6) {\r\n    return null;\r\n  }\r\n\r\n  // Find center of circle passing through 3 points\r\n  // Perpendicular bisector of start-mid\r\n  const midStartMid = scale(add(start, mid), 0.5);\r\n  const dirStartMid = subtract(mid, start);\r\n  const perpStartMid = { x: -dirStartMid.y, y: dirStartMid.x };\r\n  const line1 = { point: midStartMid, direction: normalize(perpStartMid) };\r\n\r\n  // Perpendicular bisector of mid-end\r\n  const midMidEnd = scale(add(mid, end), 0.5);\r\n  const dirMidEnd = subtract(end, mid);\r\n  const perpMidEnd = { x: -dirMidEnd.y, y: dirMidEnd.x };\r\n  const line2 = { point: midMidEnd, direction: normalize(perpMidEnd) };\r\n\r\n  const center = lineLineIntersection(line1, line2);\r\n  if (!center) return null; // Should be caught by collinear check\r\n\r\n  const radius = distance(center, start);\r\n  const startAngle = angle(subtract(start, center));\r\n  const endAngle = angle(subtract(end, center));\r\n\r\n  // Determine direction (clockwise or counter-clockwise)\r\n  // Cross product of (mid-start) and (end-mid) tells us the turn direction\r\n  const v1 = subtract(mid, start);\r\n  const v2 = subtract(end, mid);\r\n  const crossProd = cross(v1, v2);\r\n  // In Y-down screen coords:\r\n  // cross > 0 => Right Turn (Clockwise)\r\n  // cross < 0 => Left Turn (Counter-Clockwise)\r\n\r\n  return {\r\n    center,\r\n    radius,\r\n    startAngle,\r\n    endAngle,\r\n    clockwise: crossProd > 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate squared distance from a point to a line segment\r\n */\r\nexport function distancePointToLineSegmentSq(\r\n  p: Point,\r\n  a: Point,\r\n  b: Point,\r\n): number {\r\n  const l2 = distanceSquared(a, b);\r\n  if (l2 === 0) return distanceSquared(p, a);\r\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;\r\n  t = Math.max(0, Math.min(1, t));\r\n  const proj = {\r\n    x: a.x + t * (b.x - a.x),\r\n    y: a.y + t * (b.y - a.y),\r\n  };\r\n  return distanceSquared(p, proj);\r\n}\r\n\r\n/**\r\n * Calculate distance from a point to a line segment\r\n */\r\nexport function distancePointToLineSegment(\r\n  p: Point,\r\n  a: Point,\r\n  b: Point,\r\n): number {\r\n  return Math.sqrt(distancePointToLineSegmentSq(p, a, b));\r\n}\r\n\r\n/**\r\n * Calculate distance from a point to a 3-point arc\r\n */\r\nexport function distancePointToArc3Point(p: Point, arc3: Arc3Point): number {\r\n  const arc = arc3PointToArc(arc3);\r\n  if (!arc) {\r\n    // Treat as line segment\r\n    return distancePointToLineSegment(p, arc3.start, arc3.end);\r\n  }\r\n  return distanceToArc(p, arc);\r\n}\r\n", "import {\r\n  add,\r\n  cross,\r\n  distance,\r\n  dot,\r\n  magnitude,\r\n  normalize,\r\n  type Point,\r\n  scale,\r\n  subtract,\r\n} from \"./geometry.ts\";\r\nimport { type Segment, type SimplifiedEdge } from \"./simplifier.ts\";\r\n\r\n// Configuration\r\nconst CONFIG = {\r\n  LEARNING_RATE: 0.01,\r\n  ITERATIONS: 50,\r\n  SPLIT_THRESHOLD: 1.0, // Lower threshold to catch corners like L-shapes\r\n  MERGE_THRESHOLD: 0.2,\r\n  ALIGNMENT_STRENGTH: 0.5,\r\n  SMOOTHNESS_STRENGTH: 0.2,\r\n  FIDELITY_WEIGHT: 1.0,\r\n};\r\n\r\nexport interface OptNode {\r\n  x: number;\r\n  y: number;\r\n  fixed: boolean;\r\n}\r\n\r\nexport interface OptSegment {\r\n  startIdx: number; // Index into nodes array\r\n  endIdx: number; // Index into nodes array\r\n  sagittaPoint: Point; // Point on the curve at the \"bulge\" - defines the arc curvature\r\n  points: Point[]; // Original pixels\r\n}\r\n\r\n/**\r\n * Compute circle center and radius from 3 points (start, sagittaPoint, end).\r\n * Returns null if points are collinear (line case).\r\n * Special case: if start == end (full circle), returns circle with sagittaPoint as diameter opposite.\r\n */\r\nfunction circleFrom3Points(\r\n  p1: Point,\r\n  p2: Point,\r\n  p3: Point,\r\n): { center: Point; radius: number } | null {\r\n  // Special case: full circle (p1 == p3)\r\n  const startEndDist = distance(p1, p3);\r\n  if (startEndDist < 1e-6) {\r\n    // Full circle: p1 and p3 are the same point, p2 is the opposite point on the circle\r\n    // Center is midpoint of p1 and p2, radius is half the distance\r\n    const center = scale(add(p1, p2), 0.5);\r\n    const radius = distance(p1, p2) / 2;\r\n    if (radius < 1e-6) return null; // Degenerate\r\n    return { center, radius };\r\n  }\r\n\r\n  // Check for collinearity using cross product\r\n  const v1 = subtract(p2, p1);\r\n  const v2 = subtract(p3, p1);\r\n  const crossProd = cross(v1, v2);\r\n\r\n  if (Math.abs(crossProd) < 1e-6) {\r\n    return null; // Collinear - treat as line\r\n  }\r\n\r\n  // Circle through 3 points using perpendicular bisector intersection\r\n  const ax = p1.x, ay = p1.y;\r\n  const bx = p2.x, by = p2.y;\r\n  const cx = p3.x, cy = p3.y;\r\n\r\n  const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\r\n  if (Math.abs(d) < 1e-10) {\r\n    return null;\r\n  }\r\n\r\n  const ux = ((ax * ax + ay * ay) * (by - cy) +\r\n    (bx * bx + by * by) * (cy - ay) +\r\n    (cx * cx + cy * cy) * (ay - by)) /\r\n    d;\r\n  const uy = ((ax * ax + ay * ay) * (cx - bx) +\r\n    (bx * bx + by * by) * (ax - cx) +\r\n    (cx * cx + cy * cy) * (bx - ax)) /\r\n    d;\r\n\r\n  const center = { x: ux, y: uy };\r\n  const radius = distance(center, p1);\r\n\r\n  return { center, radius };\r\n}\r\n\r\n/**\r\n * Compute the signed sagitta (scalar) from start, sagittaPoint, end.\r\n * This is used for determining if segment is line-like.\r\n */\r\nfunction computeSagitta(start: Point, sagittaPoint: Point, end: Point): number {\r\n  const chord = subtract(end, start);\r\n  const chordLen = magnitude(chord);\r\n  if (chordLen < 1e-6) {\r\n    // start == end (closed loop) - sagitta is distance to sagittaPoint\r\n    return distance(start, sagittaPoint);\r\n  }\r\n\r\n  const midChord = scale(add(start, end), 0.5);\r\n  const toSagitta = subtract(sagittaPoint, midChord);\r\n\r\n  // Normal to chord (pointing \"left\")\r\n  const normal = { x: -chord.y / chordLen, y: chord.x / chordLen };\r\n  // Signed distance along normal\r\n  return dot(toSagitta, normal);\r\n}\r\n\r\nexport function optimizeEdge(\r\n  edge: SimplifiedEdge,\r\n  initialSegments?: Segment[],\r\n  onIteration?: (\r\n    nodes: OptNode[],\r\n    segments: OptSegment[],\r\n    label: string,\r\n  ) => void,\r\n): SimplifiedEdge {\r\n  // 1. Initialize Optimization Model\r\n  let nodes: OptNode[] = [];\r\n  let segments: OptSegment[] = [];\r\n\r\n  // Determine if the edge is a closed loop\r\n  const startP = edge.original.points[0];\r\n  const endP = edge.original.points[edge.original.points.length - 1];\r\n  const isClosed = distance(startP, endP) < 1e-4;\r\n\r\n  if (initialSegments && initialSegments.length > 0) {\r\n    // Initialize from existing segments\r\n    const firstSeg = initialSegments[0];\r\n\r\n    // Handle circle specially - it has no start/end points\r\n    if (firstSeg.type === \"circle\") {\r\n      // For a circle, create a single segment with start=end (same node index)\r\n      const circleCenter = firstSeg.circle.center;\r\n      const circleRadius = firstSeg.circle.radius;\r\n      const circlePoints = firstSeg.points;\r\n\r\n      // Project first point onto the fitted circle to get exact start point\r\n      const p0 = circlePoints[0];\r\n      const dirToP0 = normalize(subtract(p0, circleCenter));\r\n      const startOnCircle = add(circleCenter, scale(dirToP0, circleRadius));\r\n\r\n      nodes.push({ x: startOnCircle.x, y: startOnCircle.y, fixed: false });\r\n\r\n      // SagittaPoint is opposite side of circle (at exact radius)\r\n      const opposite = add(circleCenter, scale(dirToP0, -circleRadius));\r\n\r\n      segments.push({\r\n        startIdx: 0,\r\n        endIdx: 0, // Same node index for full circle\r\n        sagittaPoint: opposite,\r\n        points: circlePoints,\r\n      });\r\n    } else {\r\n      // Normal case: lines and arcs with start/end\r\n      const firstP = firstSeg.start;\r\n      nodes.push({ x: firstP.x, y: firstP.y, fixed: false });\r\n\r\n      for (let i = 0; i < initialSegments.length; i++) {\r\n        const seg = initialSegments[i];\r\n        if (seg.type === \"circle\") continue; // Skip circles in mixed lists\r\n\r\n        const segEnd = seg.end;\r\n        nodes.push({ x: segEnd.x, y: segEnd.y, fixed: false });\r\n\r\n        // Calculate sagittaPoint from the segment\r\n        let sagittaPoint: Point;\r\n        if (seg.type === \"arc\") {\r\n          // Use the midpoint of the arc (point on arc at middle angle)\r\n          const midIdx = Math.floor(seg.points.length / 2);\r\n          sagittaPoint = seg.points[midIdx];\r\n        } else {\r\n          // Line: sagittaPoint is on the chord (midpoint)\r\n          sagittaPoint = scale(add(seg.start, seg.end), 0.5);\r\n        }\r\n\r\n        segments.push({\r\n          startIdx: i,\r\n          endIdx: i + 1,\r\n          sagittaPoint,\r\n          points: seg.points,\r\n        });\r\n      }\r\n    }\r\n  } else {\r\n    // Create initial single segment\r\n    nodes.push({ x: startP.x, y: startP.y, fixed: false });\r\n    nodes.push({ x: endP.x, y: endP.y, fixed: false });\r\n\r\n    // Initial sagittaPoint: midpoint of points (not chord)\r\n    const midIdx = Math.floor(edge.original.points.length / 2);\r\n    const sagittaPoint = edge.original.points[midIdx];\r\n\r\n    segments.push({\r\n      startIdx: 0,\r\n      endIdx: 1,\r\n      sagittaPoint,\r\n      points: edge.original.points,\r\n    });\r\n  }\r\n\r\n  if (onIteration) {\r\n    onIteration(\r\n      JSON.parse(JSON.stringify(nodes)),\r\n      JSON.parse(JSON.stringify(segments)),\r\n      \"Initial\",\r\n    );\r\n  }\r\n\r\n  // 2. Iterative Refinement Loop\r\n  let changed = true;\r\n  let loopCount = 0;\r\n\r\n  while (changed && loopCount < 5) {\r\n    changed = false;\r\n    loopCount++;\r\n\r\n    // A. Optimize Parameters (Gradient Descent)\r\n    optimizeParameters(nodes, segments, isClosed);\r\n    if (onIteration) {\r\n      onIteration(\r\n        JSON.parse(JSON.stringify(nodes)),\r\n        JSON.parse(JSON.stringify(segments)),\r\n        `Iteration ${loopCount} - Optimized`,\r\n      );\r\n    }\r\n\r\n    // B. Split Pass\r\n    const newSegments: OptSegment[] = [];\r\n    let splitOccurred = false;\r\n\r\n    for (const seg of segments) {\r\n      const maxErr = getMaxError(seg, nodes);\r\n      if (maxErr > CONFIG.SPLIT_THRESHOLD && seg.points.length > 4) {\r\n        const splitRes = splitSegment(seg, nodes);\r\n        newSegments.push(splitRes.left);\r\n        newSegments.push(splitRes.right);\r\n        splitOccurred = true;\r\n        changed = true;\r\n      } else {\r\n        newSegments.push(seg);\r\n      }\r\n    }\r\n    segments = newSegments;\r\n\r\n    if (splitOccurred) {\r\n      if (onIteration) {\r\n        onIteration(\r\n          JSON.parse(JSON.stringify(nodes)),\r\n          JSON.parse(JSON.stringify(segments)),\r\n          `Iteration ${loopCount} - Split`,\r\n        );\r\n      }\r\n      optimizeParameters(nodes, segments, isClosed);\r\n      if (onIteration) {\r\n        onIteration(\r\n          JSON.parse(JSON.stringify(nodes)),\r\n          JSON.parse(JSON.stringify(segments)),\r\n          `Iteration ${loopCount} - Re-optimized`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Final Polish\r\n  optimizeParameters(nodes, segments, isClosed);\r\n  if (onIteration) {\r\n    onIteration(\r\n      JSON.parse(JSON.stringify(nodes)),\r\n      JSON.parse(JSON.stringify(segments)),\r\n      \"Final\",\r\n    );\r\n  }\r\n\r\n  return {\r\n    original: edge.original,\r\n    segments: convertToSegments(nodes, segments),\r\n  };\r\n}\r\n\r\nfunction optimizeParameters(\r\n  nodes: OptNode[],\r\n  segments: OptSegment[],\r\n  isClosed: boolean = false,\r\n) {\r\n  const MAX_GRAD = 1000; // Gradient clipping threshold\r\n\r\n  for (let iter = 0; iter < CONFIG.ITERATIONS; iter++) {\r\n    // Check for NaN/Inf at start of iteration\r\n    for (let ni = 0; ni < nodes.length; ni++) {\r\n      if (!isFinite(nodes[ni].x) || !isFinite(nodes[ni].y)) {\r\n        return; // Stop optimization on numerical explosion\r\n      }\r\n    }\r\n    for (let si = 0; si < segments.length; si++) {\r\n      const sp = segments[si].sagittaPoint;\r\n      if (!isFinite(sp.x) || !isFinite(sp.y)) {\r\n        return; // Stop optimization on numerical explosion\r\n      }\r\n    }\r\n\r\n    // Calculate Gradients\r\n    const nodeGrads = nodes.map(() => ({ x: 0, y: 0 }));\r\n    const sagittaGrads = segments.map(() => ({ x: 0, y: 0 }));\r\n\r\n    const h = 0.01;\r\n\r\n    // 1. Fidelity Gradients\r\n    for (let i = 0; i < segments.length; i++) {\r\n      const seg = segments[i];\r\n      const pStart = nodes[seg.startIdx];\r\n      const pEnd = nodes[seg.endIdx];\r\n\r\n      // Numerical gradient for sagittaPoint\r\n      const errBase = getSegmentErrorWithPoints(\r\n        seg.points,\r\n        pStart,\r\n        seg.sagittaPoint,\r\n        pEnd,\r\n      );\r\n\r\n      // Gradient for sagittaPoint.x\r\n      const sagPlusX = { ...seg.sagittaPoint, x: seg.sagittaPoint.x + h };\r\n      const sagMinusX = { ...seg.sagittaPoint, x: seg.sagittaPoint.x - h };\r\n      const errSagXPlus = getSegmentErrorWithPoints(\r\n        seg.points,\r\n        pStart,\r\n        sagPlusX,\r\n        pEnd,\r\n      );\r\n      const errSagXMinus = getSegmentErrorWithPoints(\r\n        seg.points,\r\n        pStart,\r\n        sagMinusX,\r\n        pEnd,\r\n      );\r\n      sagittaGrads[i].x += ((errSagXPlus - errSagXMinus) / (2 * h)) *\r\n        CONFIG.FIDELITY_WEIGHT;\r\n\r\n      // Gradient for sagittaPoint.y\r\n      const sagPlusY = { ...seg.sagittaPoint, y: seg.sagittaPoint.y + h };\r\n      const sagMinusY = { ...seg.sagittaPoint, y: seg.sagittaPoint.y - h };\r\n      const errSagYPlus = getSegmentErrorWithPoints(\r\n        seg.points,\r\n        pStart,\r\n        sagPlusY,\r\n        pEnd,\r\n      );\r\n      const errSagYMinus = getSegmentErrorWithPoints(\r\n        seg.points,\r\n        pStart,\r\n        sagMinusY,\r\n        pEnd,\r\n      );\r\n      sagittaGrads[i].y += ((errSagYPlus - errSagYMinus) / (2 * h)) *\r\n        CONFIG.FIDELITY_WEIGHT;\r\n\r\n      // For full circle (startIdx == endIdx), the node defines a point on the circle\r\n      // and must be perturbed together with end (same node).\r\n      // For regular segments, perturb start and end separately.\r\n      const isFullCircle = seg.startIdx === seg.endIdx;\r\n\r\n      // Gradient for start node (and end if full circle)\r\n      if (!pStart.fixed) {\r\n        const pStartXPlus = { ...pStart, x: pStart.x + h };\r\n        const pStartXMinus = { ...pStart, x: pStart.x - h };\r\n        // For full circle: end moves with start\r\n        const errXPlus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStartXPlus,\r\n          seg.sagittaPoint,\r\n          isFullCircle ? pStartXPlus : pEnd,\r\n        );\r\n        const errXMinus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStartXMinus,\r\n          seg.sagittaPoint,\r\n          isFullCircle ? pStartXMinus : pEnd,\r\n        );\r\n        nodeGrads[seg.startIdx].x += ((errXPlus - errXMinus) / (2 * h)) *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n\r\n        const pStartYPlus = { ...pStart, y: pStart.y + h };\r\n        const pStartYMinus = { ...pStart, y: pStart.y - h };\r\n        const errYPlus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStartYPlus,\r\n          seg.sagittaPoint,\r\n          isFullCircle ? pStartYPlus : pEnd,\r\n        );\r\n        const errYMinus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStartYMinus,\r\n          seg.sagittaPoint,\r\n          isFullCircle ? pStartYMinus : pEnd,\r\n        );\r\n        nodeGrads[seg.startIdx].y += ((errYPlus - errYMinus) / (2 * h)) *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n      }\r\n\r\n      // Gradient for end node (skip if full circle - already handled above)\r\n      if (!isFullCircle && !pEnd.fixed) {\r\n        const pEndXPlus = { ...pEnd, x: pEnd.x + h };\r\n        const pEndXMinus = { ...pEnd, x: pEnd.x - h };\r\n        const errXPlus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStart,\r\n          seg.sagittaPoint,\r\n          pEndXPlus,\r\n        );\r\n        const errXMinus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStart,\r\n          seg.sagittaPoint,\r\n          pEndXMinus,\r\n        );\r\n        nodeGrads[seg.endIdx].x += ((errXPlus - errXMinus) / (2 * h)) *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n\r\n        const pEndYPlus = { ...pEnd, y: pEnd.y + h };\r\n        const pEndYMinus = { ...pEnd, y: pEnd.y - h };\r\n        const errYPlus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStart,\r\n          seg.sagittaPoint,\r\n          pEndYPlus,\r\n        );\r\n        const errYMinus = getSegmentErrorWithPoints(\r\n          seg.points,\r\n          pStart,\r\n          seg.sagittaPoint,\r\n          pEndYMinus,\r\n        );\r\n        nodeGrads[seg.endIdx].y += ((errYPlus - errYMinus) / (2 * h)) *\r\n          CONFIG.FIDELITY_WEIGHT;\r\n      }\r\n    }\r\n\r\n    // 2. Alignment Gradients (only for line-like segments)\r\n    for (let i = 0; i < segments.length; i++) {\r\n      const seg = segments[i];\r\n      const pStart = nodes[seg.startIdx];\r\n      const pEnd = nodes[seg.endIdx];\r\n\r\n      const sagitta = computeSagitta(pStart, seg.sagittaPoint, pEnd);\r\n      if (Math.abs(sagitta) < 1.0) {\r\n        const dx = pEnd.x - pStart.x;\r\n        const dy = pEnd.y - pStart.y;\r\n        const len = Math.sqrt(dx * dx + dy * dy);\r\n        if (len > 1e-4) {\r\n          if (!pStart.fixed) {\r\n            const costXPlus = alignmentCost(\r\n              { ...pStart, x: pStart.x + h },\r\n              pEnd,\r\n            );\r\n            const costXMinus = alignmentCost(\r\n              { ...pStart, x: pStart.x - h },\r\n              pEnd,\r\n            );\r\n            nodeGrads[seg.startIdx].x += ((costXPlus - costXMinus) / (2 * h)) *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n\r\n            const costYPlus = alignmentCost(\r\n              { ...pStart, y: pStart.y + h },\r\n              pEnd,\r\n            );\r\n            const costYMinus = alignmentCost(\r\n              { ...pStart, y: pStart.y - h },\r\n              pEnd,\r\n            );\r\n            nodeGrads[seg.startIdx].y += ((costYPlus - costYMinus) / (2 * h)) *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n          }\r\n          if (!pEnd.fixed) {\r\n            const costXPlus = alignmentCost(pStart, { ...pEnd, x: pEnd.x + h });\r\n            const costXMinus = alignmentCost(pStart, {\r\n              ...pEnd,\r\n              x: pEnd.x - h,\r\n            });\r\n            nodeGrads[seg.endIdx].x += ((costXPlus - costXMinus) / (2 * h)) *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n\r\n            const costYPlus = alignmentCost(pStart, { ...pEnd, y: pEnd.y + h });\r\n            const costYMinus = alignmentCost(pStart, {\r\n              ...pEnd,\r\n              y: pEnd.y - h,\r\n            });\r\n            nodeGrads[seg.endIdx].y += ((costYPlus - costYMinus) / (2 * h)) *\r\n              CONFIG.ALIGNMENT_STRENGTH;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Clip gradients to prevent explosion\r\n    for (let i = 0; i < nodeGrads.length; i++) {\r\n      nodeGrads[i].x = Math.max(-MAX_GRAD, Math.min(MAX_GRAD, nodeGrads[i].x));\r\n      nodeGrads[i].y = Math.max(-MAX_GRAD, Math.min(MAX_GRAD, nodeGrads[i].y));\r\n    }\r\n    for (let i = 0; i < sagittaGrads.length; i++) {\r\n      sagittaGrads[i].x = Math.max(\r\n        -MAX_GRAD,\r\n        Math.min(MAX_GRAD, sagittaGrads[i].x),\r\n      );\r\n      sagittaGrads[i].y = Math.max(\r\n        -MAX_GRAD,\r\n        Math.min(MAX_GRAD, sagittaGrads[i].y),\r\n      );\r\n    }\r\n\r\n    // Sync gradients for closed loops\r\n    if (isClosed && nodes.length > 1) {\r\n      const last = nodes.length - 1;\r\n      const sumX = nodeGrads[0].x + nodeGrads[last].x;\r\n      const sumY = nodeGrads[0].y + nodeGrads[last].y;\r\n      nodeGrads[0].x = sumX;\r\n      nodeGrads[0].y = sumY;\r\n      nodeGrads[last].x = sumX;\r\n      nodeGrads[last].y = sumY;\r\n    }\r\n\r\n    // Apply Gradients to nodes\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      if (!nodes[i].fixed) {\r\n        nodes[i].x -= nodeGrads[i].x * CONFIG.LEARNING_RATE;\r\n        nodes[i].y -= nodeGrads[i].y * CONFIG.LEARNING_RATE;\r\n      }\r\n    }\r\n\r\n    // Sync positions for closed loops\r\n    if (isClosed && nodes.length > 1) {\r\n      const last = nodes.length - 1;\r\n      const avgX = (nodes[0].x + nodes[last].x) / 2;\r\n      const avgY = (nodes[0].y + nodes[last].y) / 2;\r\n      nodes[0].x = avgX;\r\n      nodes[0].y = avgY;\r\n      nodes[last].x = avgX;\r\n      nodes[last].y = avgY;\r\n    }\r\n\r\n    // Apply Gradients to sagittaPoints\r\n    for (let i = 0; i < segments.length; i++) {\r\n      segments[i].sagittaPoint.x -= sagittaGrads[i].x * CONFIG.LEARNING_RATE;\r\n      segments[i].sagittaPoint.y -= sagittaGrads[i].y * CONFIG.LEARNING_RATE;\r\n    }\r\n  }\r\n}\r\n\r\nfunction alignmentCost(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  const lenSq = dx * dx + dy * dy;\r\n  if (lenSq < 1e-6) return 0;\r\n  return Math.pow((dx * dy) / lenSq, 2) * 10;\r\n}\r\n\r\n/**\r\n * Compute segment error using 3 points (start, sagittaPoint, end) to define the curve.\r\n */\r\nfunction getSegmentErrorWithPoints(\r\n  points: Point[],\r\n  start: Point,\r\n  sagittaPoint: Point,\r\n  end: Point,\r\n): number {\r\n  let error = 0;\r\n\r\n  const circle = circleFrom3Points(start, sagittaPoint, end);\r\n\r\n  if (!circle) {\r\n    // Collinear - use line distance\r\n    for (const p of points) {\r\n      error += distancePointToLineSegmentSq(p, start, end);\r\n    }\r\n  } else {\r\n    // Arc distance - distance to circle\r\n    for (const p of points) {\r\n      const d = Math.abs(distance(p, circle.center) - circle.radius);\r\n      error += d * d;\r\n    }\r\n  }\r\n\r\n  return error;\r\n}\r\n\r\nfunction getMaxError(seg: OptSegment, nodes: OptNode[]): number {\r\n  const start = nodes[seg.startIdx];\r\n  const end = nodes[seg.endIdx];\r\n  let maxErr = 0;\r\n\r\n  const circle = circleFrom3Points(start, seg.sagittaPoint, end);\r\n\r\n  if (!circle) {\r\n    for (const p of seg.points) {\r\n      const d = Math.sqrt(distancePointToLineSegmentSq(p, start, end));\r\n      if (d > maxErr) maxErr = d;\r\n    }\r\n  } else {\r\n    for (const p of seg.points) {\r\n      const d = Math.abs(distance(p, circle.center) - circle.radius);\r\n      if (d > maxErr) maxErr = d;\r\n    }\r\n  }\r\n\r\n  return maxErr;\r\n}\r\n\r\nfunction splitSegment(\r\n  seg: OptSegment,\r\n  nodes: OptNode[],\r\n): { left: OptSegment; right: OptSegment } {\r\n  const start = nodes[seg.startIdx];\r\n  const end = nodes[seg.endIdx];\r\n  let maxErr = -1;\r\n  let splitIdx = -1;\r\n\r\n  const circle = circleFrom3Points(start, seg.sagittaPoint, end);\r\n\r\n  for (let i = 0; i < seg.points.length; i++) {\r\n    const p = seg.points[i];\r\n    let d = 0;\r\n    if (!circle) {\r\n      d = Math.sqrt(distancePointToLineSegmentSq(p, start, end));\r\n    } else {\r\n      d = Math.abs(distance(p, circle.center) - circle.radius);\r\n    }\r\n\r\n    if (d > maxErr) {\r\n      maxErr = d;\r\n      splitIdx = i;\r\n    }\r\n  }\r\n\r\n  // Create new node at split point\r\n  const splitPoint = seg.points[splitIdx];\r\n  const newNodeIdx = nodes.length;\r\n  nodes.push({ x: splitPoint.x, y: splitPoint.y, fixed: false });\r\n\r\n  const leftPoints = seg.points.slice(0, splitIdx + 1);\r\n  const rightPoints = seg.points.slice(splitIdx);\r\n\r\n  // Compute sagittaPoints for each half (midpoint of their points)\r\n  const leftMidIdx = Math.floor(leftPoints.length / 2);\r\n  const rightMidIdx = Math.floor(rightPoints.length / 2);\r\n\r\n  return {\r\n    left: {\r\n      startIdx: seg.startIdx,\r\n      endIdx: newNodeIdx,\r\n      sagittaPoint: leftPoints[leftMidIdx],\r\n      points: leftPoints,\r\n    },\r\n    right: {\r\n      startIdx: newNodeIdx,\r\n      endIdx: seg.endIdx,\r\n      sagittaPoint: rightPoints[rightMidIdx],\r\n      points: rightPoints,\r\n    },\r\n  };\r\n}\r\n\r\nfunction distancePointToLineSegmentSq(p: Point, a: Point, b: Point): number {\r\n  const l2 = distanceSquared(a, b);\r\n  if (l2 === 0) return distanceSquared(p, a);\r\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;\r\n  t = Math.max(0, Math.min(1, t));\r\n  const proj = {\r\n    x: a.x + t * (b.x - a.x),\r\n    y: a.y + t * (b.y - a.y),\r\n  };\r\n  return distanceSquared(p, proj);\r\n}\r\n\r\nfunction distanceSquared(p1: Point, p2: Point): number {\r\n  const dx = p2.x - p1.x;\r\n  const dy = p2.y - p1.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\nexport function convertToSegments(\r\n  nodes: OptNode[],\r\n  optSegments: OptSegment[],\r\n): Segment[] {\r\n  return optSegments.map((seg) => {\r\n    const start: Point = { x: nodes[seg.startIdx].x, y: nodes[seg.startIdx].y };\r\n    const end: Point = { x: nodes[seg.endIdx].x, y: nodes[seg.endIdx].y };\r\n\r\n    // Compute the sagitta (perpendicular distance from sagittaPoint to chord)\r\n    const sagitta = computeSagitta(start, seg.sagittaPoint, end);\r\n    const chordLen = distance(start, end);\r\n\r\n    // Treat as line if:\r\n    // - sagitta is very small (nearly collinear points)\r\n    // - or sagitta relative to chord length is tiny (nearly straight)\r\n    const isLine = Math.abs(sagitta) < 0.5 ||\r\n      (chordLen > 1e-4 && Math.abs(sagitta) / chordLen < 0.05);\r\n\r\n    if (isLine) {\r\n      // Line\r\n      const dir = chordLen > 1e-6\r\n        ? normalize(subtract(end, start))\r\n        : { x: 1, y: 0 };\r\n\r\n      return {\r\n        type: \"line\" as const,\r\n        start,\r\n        end,\r\n        points: seg.points,\r\n        line: {\r\n          point: start,\r\n          direction: dir,\r\n        },\r\n      };\r\n    }\r\n\r\n    const circle = circleFrom3Points(start, seg.sagittaPoint, end);\r\n\r\n    if (!circle || circle.radius > 10000) {\r\n      // Fallback to line\r\n      const dir = magnitude(subtract(end, start)) > 1e-6\r\n        ? normalize(subtract(end, start))\r\n        : { x: 1, y: 0 };\r\n\r\n      return {\r\n        type: \"line\" as const,\r\n        start,\r\n        end,\r\n        points: seg.points,\r\n        line: {\r\n          point: start,\r\n          direction: dir,\r\n        },\r\n      };\r\n    } else {\r\n      // Arc\r\n      const startAngle = Math.atan2(\r\n        start.y - circle.center.y,\r\n        start.x - circle.center.x,\r\n      );\r\n      const endAngle = Math.atan2(\r\n        end.y - circle.center.y,\r\n        end.x - circle.center.x,\r\n      );\r\n\r\n      // Determine clockwise by checking if sagittaPoint is on left or right of chord\r\n      const chord = subtract(end, start);\r\n      const toSagitta = subtract(seg.sagittaPoint, start);\r\n      const crossProd = cross(chord, toSagitta);\r\n      const clockwise = crossProd < 0;\r\n\r\n      return {\r\n        type: \"arc\" as const,\r\n        start,\r\n        end,\r\n        points: seg.points,\r\n        arc: {\r\n          center: circle.center,\r\n          radius: circle.radius,\r\n          startAngle,\r\n          endAngle,\r\n          clockwise,\r\n        },\r\n      };\r\n    }\r\n  });\r\n}\r\n", "/**\r\n * Line fitting using Total Least Squares (TLS)\r\n * Minimizes perpendicular distance from points to the fitted line\r\n */\r\n\r\nimport type { Line, Point } from \"./geometry.ts\";\r\nimport { normalize } from \"./geometry.ts\";\r\n\r\nexport interface LineFitResult {\r\n  /** The fitted line */\r\n  line: Line;\r\n  /** Root mean square error (perpendicular distance) */\r\n  rmsError: number;\r\n  /** Median error */\r\n  medianError: number;\r\n  /** Number of points in the fit */\r\n  count: number;\r\n  /** Individual errors for each point */\r\n  errors: number[];\r\n}\r\n\r\n/**\r\n * Fit a line to a set of points using Total Least Squares\r\n * Returns null if fewer than 2 points or points are degenerate\r\n */\r\nexport function fitLine(points: Point[]): LineFitResult | null {\r\n  if (points.length < 2) {\r\n    return null;\r\n  }\r\n\r\n  // Calculate centroid\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  for (const p of points) {\r\n    sumX += p.x;\r\n    sumY += p.y;\r\n  }\r\n  const centroid = {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length,\r\n  };\r\n\r\n  // Calculate covariance matrix\r\n  let covXX = 0;\r\n  let covYY = 0;\r\n  let covXY = 0;\r\n  for (const p of points) {\r\n    const dx = p.x - centroid.x;\r\n    const dy = p.y - centroid.y;\r\n    covXX += dx * dx;\r\n    covYY += dy * dy;\r\n    covXY += dx * dy;\r\n  }\r\n\r\n  // Find principal component (eigenvector of largest eigenvalue)\r\n  // For 2x2 matrix: lambda = (trace \u00B1 sqrt(trace\u00B2 - 4*det)) / 2\r\n  const trace = covXX + covYY;\r\n  const det = covXX * covYY - covXY * covXY;\r\n  const discriminant = trace * trace - 4 * det;\r\n\r\n  if (discriminant < 0 || trace < 1e-10) {\r\n    // Degenerate case: all points are at the same location\r\n    return null;\r\n  }\r\n\r\n  const lambda1 = (trace + Math.sqrt(discriminant)) / 2;\r\n\r\n  // Eigenvector corresponding to lambda1\r\n  let direction: Point;\r\n  if (Math.abs(covXY) > 1e-10) {\r\n    direction = normalize({ x: lambda1 - covYY, y: covXY });\r\n  } else if (covXX > covYY) {\r\n    direction = { x: 1, y: 0 };\r\n  } else {\r\n    direction = { x: 0, y: 1 };\r\n  }\r\n\r\n  const line: Line = {\r\n    point: centroid,\r\n    direction,\r\n  };\r\n\r\n  // Calculate errors\r\n  const errors = points.map((p) => {\r\n    const dx = p.x - centroid.x;\r\n    const dy = p.y - centroid.y;\r\n    // Perpendicular distance: |cross product| with unit direction\r\n    return Math.abs(dx * direction.y - dy * direction.x);\r\n  });\r\n\r\n  // Calculate RMS error\r\n  const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n  const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n  // Calculate median error\r\n  const sortedErrors = [...errors].sort((a, b) => a - b);\r\n  const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n  return {\r\n    line,\r\n    rmsError,\r\n    medianError,\r\n    count: points.length,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Incremental line fitting for online algorithms\r\n * Allows adding points one at a time and updating the fit efficiently\r\n */\r\nexport class IncrementalLineFit {\r\n  private n = 0;\r\n  private sumX = 0;\r\n  private sumY = 0;\r\n  private sumXX = 0;\r\n  private sumYY = 0;\r\n  private sumXY = 0;\r\n  private points: Point[] = [];\r\n\r\n  /**\r\n   * Add a point to the fit\r\n   */\r\n  addPoint(p: Point): void {\r\n    this.n++;\r\n    this.sumX += p.x;\r\n    this.sumY += p.y;\r\n    this.sumXX += p.x * p.x;\r\n    this.sumYY += p.y * p.y;\r\n    this.sumXY += p.x * p.y;\r\n    this.points.push(p);\r\n  }\r\n\r\n  /**\r\n   * Get the number of points in the fit\r\n   */\r\n  getCount(): number {\r\n    return this.n;\r\n  }\r\n\r\n  /**\r\n   * Get all points in the fit\r\n   */\r\n  getPoints(): Point[] {\r\n    return [...this.points];\r\n  }\r\n\r\n  /**\r\n   * Get the current fit result\r\n   * Returns null if fewer than 2 points\r\n   */\r\n  getFit(): LineFitResult | null {\r\n    if (this.n < 2) {\r\n      return null;\r\n    }\r\n\r\n    // Calculate centroid\r\n    const centroid = {\r\n      x: this.sumX / this.n,\r\n      y: this.sumY / this.n,\r\n    };\r\n\r\n    // Calculate covariance matrix components\r\n    const covXX = this.sumXX - this.sumX * this.sumX / this.n;\r\n    const covYY = this.sumYY - this.sumY * this.sumY / this.n;\r\n    const covXY = this.sumXY - this.sumX * this.sumY / this.n;\r\n\r\n    // Find principal component\r\n    const trace = covXX + covYY;\r\n    const det = covXX * covYY - covXY * covXY;\r\n    const discriminant = trace * trace - 4 * det;\r\n\r\n    if (discriminant < 0 || trace < 1e-10) {\r\n      return null;\r\n    }\r\n\r\n    const lambda1 = (trace + Math.sqrt(discriminant)) / 2;\r\n\r\n    // Eigenvector\r\n    let direction: Point;\r\n    if (Math.abs(covXY) > 1e-10) {\r\n      direction = normalize({ x: lambda1 - covYY, y: covXY });\r\n    } else if (covXX > covYY) {\r\n      direction = { x: 1, y: 0 };\r\n    } else {\r\n      direction = { x: 0, y: 1 };\r\n    }\r\n\r\n    const line: Line = {\r\n      point: centroid,\r\n      direction,\r\n    };\r\n\r\n    // Calculate errors\r\n    const errors = this.points.map((p) => {\r\n      const dx = p.x - centroid.x;\r\n      const dy = p.y - centroid.y;\r\n      return Math.abs(dx * direction.y - dy * direction.x);\r\n    });\r\n\r\n    const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n    const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n    const sortedErrors = [...errors].sort((a, b) => a - b);\r\n    const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n    return {\r\n      line,\r\n      rmsError,\r\n      medianError,\r\n      count: this.n,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the fit to start over\r\n   */\r\n  reset(): void {\r\n    this.n = 0;\r\n    this.sumX = 0;\r\n    this.sumY = 0;\r\n    this.sumXX = 0;\r\n    this.sumYY = 0;\r\n    this.sumXY = 0;\r\n    this.points = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile of errors\r\n */\r\nexport function percentile(values: number[], p: number): number {\r\n  if (values.length === 0) return 0;\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const index = Math.floor(sorted.length * p);\r\n  return sorted[Math.min(index, sorted.length - 1)];\r\n}\r\n", "/**\r\n * Arc (circle) fitting using algebraic distance minimization\r\n * Minimizes the algebraic distance from points to the fitted circle\r\n */\r\n\r\nimport type { Circle, Point } from \"./geometry.ts\";\r\nimport { distance } from \"./geometry.ts\";\r\n\r\nexport interface ArcFitResult {\r\n  /** The fitted circle */\r\n  circle: Circle;\r\n  /** Root mean square error (radial distance) */\r\n  rmsError: number;\r\n  /** Median error */\r\n  medianError: number;\r\n  /** Number of points in the fit */\r\n  count: number;\r\n  /** Individual errors for each point */\r\n  errors: number[];\r\n  /** Start angle of the arc in radians */\r\n  startAngle: number;\r\n  /** End angle of the arc in radians */\r\n  endAngle: number;\r\n  /** Sweep angle in radians */\r\n  sweepAngle: number;\r\n  /** True if arc is clockwise */\r\n  clockwise: boolean;\r\n}\r\n\r\n/**\r\n * Fit a circle to a set of points using algebraic fitting\r\n * Returns null if fewer than 3 points or fit is degenerate\r\n */\r\nexport function fitCircle(points: Point[]): ArcFitResult | null {\r\n  if (points.length < 3) {\r\n    return null;\r\n  }\r\n\r\n  // Use algebraic circle fitting (Pratt method)\r\n  // Minimizes algebraic distance: (x-cx)\u00B2 + (y-cy)\u00B2 - r\u00B2\r\n\r\n  const n = points.length;\r\n\r\n  // Calculate means\r\n  let meanX = 0;\r\n  let meanY = 0;\r\n  for (const p of points) {\r\n    meanX += p.x;\r\n    meanY += p.y;\r\n  }\r\n  meanX /= n;\r\n  meanY /= n;\r\n\r\n  // Build moment matrix\r\n  let Mxx = 0, Mxy = 0, Myy = 0;\r\n  let Mxz = 0, Myz = 0;\r\n  let Mzz = 0;\r\n\r\n  for (const p of points) {\r\n    const x = p.x - meanX;\r\n    const y = p.y - meanY;\r\n    const z = x * x + y * y;\r\n\r\n    Mxx += x * x;\r\n    Mxy += x * y;\r\n    Myy += y * y;\r\n    Mxz += x * z;\r\n    Myz += y * z;\r\n    Mzz += z * z;\r\n  }\r\n\r\n  Mxx /= n;\r\n  Mxy /= n;\r\n  Myy /= n;\r\n  Mxz /= n;\r\n  Myz /= n;\r\n  Mzz /= n;\r\n\r\n  // Solve for center offset\r\n  // The equations are: 2*Mxx*cx + 2*Mxy*cy = Mxz, 2*Mxy*cx + 2*Myy*cy = Myz\r\n  const det = Mxx * Myy - Mxy * Mxy;\r\n  if (Math.abs(det) < 1e-10) {\r\n    return null; // Degenerate case\r\n  }\r\n\r\n  const cx = (Mxz * Myy - Myz * Mxy) / (2 * det);\r\n  const cy = (Myz * Mxx - Mxz * Mxy) / (2 * det);\r\n\r\n  const center = {\r\n    x: cx + meanX,\r\n    y: cy + meanY,\r\n  };\r\n\r\n  // Calculate radius\r\n  const radiusSquared = cx * cx + cy * cy + (Mxx + Myy);\r\n  if (radiusSquared <= 0) {\r\n    return null; // Invalid circle\r\n  }\r\n  const radius = Math.sqrt(radiusSquared);\r\n\r\n  const circle: Circle = { center, radius };\r\n\r\n  // Calculate errors (radial distance from circle)\r\n  const errors = points.map((p) => Math.abs(distance(p, center) - radius));\r\n\r\n  const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n  const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n  const sortedErrors = [...errors].sort((a, b) => a - b);\r\n  const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n  // Calculate arc parameters\r\n  const angles = points.map((p) => Math.atan2(p.y - center.y, p.x - center.x));\r\n  const startAngle = angles[0];\r\n  const endAngle = angles[angles.length - 1];\r\n\r\n  // Determine if arc is clockwise by checking angle progression\r\n  let totalTurn = 0;\r\n  for (let i = 1; i < angles.length; i++) {\r\n    let delta = angles[i] - angles[i - 1];\r\n    // Normalize to [-\u03C0, \u03C0]\r\n    while (delta > Math.PI) delta -= 2 * Math.PI;\r\n    while (delta < -Math.PI) delta += 2 * Math.PI;\r\n    totalTurn += delta;\r\n  }\r\n\r\n  const clockwise = totalTurn < 0;\r\n  const sweepAngle = Math.abs(totalTurn);\r\n\r\n  return {\r\n    circle,\r\n    rmsError,\r\n    medianError,\r\n    count: points.length,\r\n    errors,\r\n    startAngle,\r\n    endAngle,\r\n    sweepAngle,\r\n    clockwise,\r\n  };\r\n}\r\n\r\n/**\r\n * Incremental circle fitting for online algorithms\r\n * Allows adding points one at a time and updating the fit efficiently\r\n */\r\nexport class IncrementalCircleFit {\r\n  private n = 0;\r\n  private sumX = 0;\r\n  private sumY = 0;\r\n  private sumXX = 0;\r\n  private sumYY = 0;\r\n  private sumXY = 0;\r\n  private sumXXX = 0;\r\n  private sumXXY = 0;\r\n  private sumXYY = 0;\r\n  private sumYYY = 0;\r\n  private points: Point[] = [];\r\n\r\n  /**\r\n   * Add a point to the fit\r\n   */\r\n  addPoint(p: Point): void {\r\n    this.n++;\r\n    this.sumX += p.x;\r\n    this.sumY += p.y;\r\n    this.sumXX += p.x * p.x;\r\n    this.sumYY += p.y * p.y;\r\n    this.sumXY += p.x * p.y;\r\n    this.sumXXX += p.x * p.x * p.x;\r\n    this.sumXXY += p.x * p.x * p.y;\r\n    this.sumXYY += p.x * p.y * p.y;\r\n    this.sumYYY += p.y * p.y * p.y;\r\n\r\n    this.points.push(p);\r\n  }\r\n\r\n  /**\r\n   * Get the number of points in the fit\r\n   */\r\n  getCount(): number {\r\n    return this.n;\r\n  }\r\n\r\n  /**\r\n   * Get all points in the fit\r\n   */\r\n  getPoints(): Point[] {\r\n    return [...this.points];\r\n  }\r\n\r\n  /**\r\n   * Get the current fit result\r\n   * Returns null if fewer than 3 points\r\n   */\r\n  getFit(): ArcFitResult | null {\r\n    if (this.n < 3) {\r\n      return null;\r\n    }\r\n\r\n    const meanX = this.sumX / this.n;\r\n    const meanY = this.sumY / this.n;\r\n\r\n    // Calculate moment matrix using stored sums\r\n    // These match the batch computation exactly\r\n    let Mxx = 0, Mxy = 0, Myy = 0;\r\n    let Mxz = 0, Myz = 0;\r\n\r\n    for (const p of this.points) {\r\n      const x = p.x - meanX;\r\n      const y = p.y - meanY;\r\n      const z = x * x + y * y;\r\n\r\n      Mxx += x * x;\r\n      Mxy += x * y;\r\n      Myy += y * y;\r\n      Mxz += x * z;\r\n      Myz += y * z;\r\n    }\r\n\r\n    Mxx /= this.n;\r\n    Mxy /= this.n;\r\n    Myy /= this.n;\r\n    Mxz /= this.n;\r\n    Myz /= this.n;\r\n\r\n    const det = Mxx * Myy - Mxy * Mxy;\r\n    if (Math.abs(det) < 1e-10) {\r\n      return null;\r\n    }\r\n\r\n    const cx = (Mxz * Myy - Myz * Mxy) / (2 * det);\r\n    const cy = (Myz * Mxx - Mxz * Mxy) / (2 * det);\r\n\r\n    const center = {\r\n      x: cx + meanX,\r\n      y: cy + meanY,\r\n    };\r\n\r\n    const radiusSquared = cx * cx + cy * cy + (Mxx + Myy);\r\n    if (radiusSquared <= 0) {\r\n      return null;\r\n    }\r\n    const radius = Math.sqrt(radiusSquared);\r\n\r\n    const circle: Circle = { center, radius };\r\n\r\n    // Calculate errors\r\n    const errors = this.points.map((p) =>\r\n      Math.abs(distance(p, center) - radius)\r\n    );\r\n\r\n    const sumSquaredErrors = errors.reduce((sum, e) => sum + e * e, 0);\r\n    const rmsError = Math.sqrt(sumSquaredErrors / errors.length);\r\n\r\n    const sortedErrors = [...errors].sort((a, b) => a - b);\r\n    const medianError = sortedErrors[Math.floor(sortedErrors.length / 2)];\r\n\r\n    // Calculate arc parameters\r\n    const angles = this.points.map((p) =>\r\n      Math.atan2(p.y - center.y, p.x - center.x)\r\n    );\r\n    const startAngle = angles[0];\r\n    const endAngle = angles[angles.length - 1];\r\n\r\n    let totalTurn = 0;\r\n    for (let i = 1; i < angles.length; i++) {\r\n      let delta = angles[i] - angles[i - 1];\r\n      while (delta > Math.PI) delta -= 2 * Math.PI;\r\n      while (delta < -Math.PI) delta += 2 * Math.PI;\r\n      totalTurn += delta;\r\n    }\r\n\r\n    const clockwise = totalTurn < 0;\r\n    const sweepAngle = Math.abs(totalTurn);\r\n\r\n    return {\r\n      circle,\r\n      rmsError,\r\n      medianError,\r\n      count: this.n,\r\n      errors,\r\n      startAngle,\r\n      endAngle,\r\n      sweepAngle,\r\n      clockwise,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the fit to start over\r\n   */\r\n  reset(): void {\r\n    this.n = 0;\r\n    this.sumX = 0;\r\n    this.sumY = 0;\r\n    this.sumXX = 0;\r\n    this.sumYY = 0;\r\n    this.sumXY = 0;\r\n    this.sumXXX = 0;\r\n    this.sumXXY = 0;\r\n    this.sumXYY = 0;\r\n    this.sumYYY = 0;\r\n    this.points = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate percentile of errors\r\n */\r\nexport function percentile(values: number[], p: number): number {\r\n  if (values.length === 0) return 0;\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const index = Math.floor(sorted.length * p);\r\n  return sorted[Math.min(index, sorted.length - 1)];\r\n}\r\n", "import type { Graph, GraphEdge } from \"./tracer.ts\";\r\nimport type { Arc, Circle, Line, Point } from \"./geometry.ts\";\r\nimport { distance } from \"./geometry.ts\";\r\nimport { optimizeEdge } from \"./optimizer.ts\";\r\nimport { IncrementalLineFit } from \"./line_fit.ts\";\r\nimport { fitCircle, IncrementalCircleFit, percentile } from \"./arc_fit.ts\";\r\n\r\nexport type Segment =\r\n  | { type: \"line\"; line: Line; start: Point; end: Point; points: Point[] }\r\n  | { type: \"arc\"; arc: Arc; start: Point; end: Point; points: Point[] }\r\n  | { type: \"circle\"; circle: Circle; points: Point[] };\r\n\r\nexport interface SimplifiedEdge {\r\n  original: GraphEdge;\r\n  segments: Segment[];\r\n}\r\n\r\nexport interface SimplifiedGraph {\r\n  nodes: Graph[\"nodes\"];\r\n  edges: SimplifiedEdge[];\r\n}\r\n\r\nfunction segmentEdge(points: Point[]): Segment[] {\r\n  const segments: Segment[] = [];\r\n  let startIndex = 0;\r\n  // Use median + percentile thresholds to encourage longer segments\r\n  const MEDIAN_TOLERANCE = 1.5; // Median error threshold (allows for pixel aliasing)\r\n  const P90_TOLERANCE = 3.0; // 90th percentile threshold\r\n\r\n  // Check for closed loop - if start and end are very close, try fitting a circle first\r\n  const isClosedLoop = points.length >= 10 &&\r\n    distance(points[0], points[points.length - 1]) < 2.0;\r\n\r\n  if (isClosedLoop) {\r\n    const circleFit = fitCircle(points);\r\n    if (circleFit) {\r\n      const p90 = percentile(circleFit.errors, 0.9);\r\n      if (circleFit.medianError <= MEDIAN_TOLERANCE && p90 <= P90_TOLERANCE) {\r\n        // Good circle fit! Return single circle segment\r\n        return [{\r\n          type: \"circle\",\r\n          circle: circleFit.circle,\r\n          points: points,\r\n        }];\r\n      }\r\n    }\r\n  }\r\n\r\n  while (startIndex < points.length - 1) {\r\n    let bestEndIndex = startIndex + 1;\r\n    let bestType: \"line\" | \"arc\" = \"line\";\r\n    let bestLineFit = null;\r\n    let bestArcFit = null;\r\n\r\n    const lineFit = new IncrementalLineFit();\r\n    const arcFit = new IncrementalCircleFit();\r\n\r\n    // Add first point\r\n    lineFit.addPoint(points[startIndex]);\r\n    arcFit.addPoint(points[startIndex]);\r\n\r\n    // Try to extend as far as possible\r\n    for (let i = startIndex + 1; i < points.length; i++) {\r\n      const p = points[i];\r\n      lineFit.addPoint(p);\r\n      arcFit.addPoint(p);\r\n\r\n      const count = i - startIndex + 1;\r\n\r\n      let lValid = false;\r\n      let aValid = false;\r\n      let lFit = null;\r\n      let aFit = null;\r\n\r\n      // Check Line Fit\r\n      if (count >= 2) {\r\n        lFit = lineFit.getFit();\r\n        if (lFit) {\r\n          const p90 = percentile(lFit.errors, 0.9);\r\n          if (lFit.medianError <= MEDIAN_TOLERANCE && p90 <= P90_TOLERANCE) {\r\n            lValid = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check Arc Fit\r\n      if (count >= 3) {\r\n        aFit = arcFit.getFit();\r\n        if (aFit) {\r\n          const p90 = percentile(aFit.errors, 0.9);\r\n          const errOk = aFit.medianError <= MEDIAN_TOLERANCE &&\r\n            p90 <= P90_TOLERANCE;\r\n          // For closed loops (sweep approaching 360\u00B0), limit to ~350\u00B0 to leave room for closing\r\n          // This avoids the degenerate case where start == end (zero chord length)\r\n          const sweepOk = aFit.sweepAngle < 2 * Math.PI - 0.2; // ~350\u00B0 max\r\n          if (errOk && sweepOk) {\r\n            aValid = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!lValid && !aValid) {\r\n        // Both failed. The previous index was the last valid one.\r\n        break;\r\n      }\r\n\r\n      // Current index is valid for at least one type\r\n      bestEndIndex = i;\r\n\r\n      if (lValid && aValid) {\r\n        // Prefer line unless arc is significantly better\r\n        if (aFit!.rmsError < lFit!.rmsError * 0.8) {\r\n          bestType = \"arc\";\r\n          bestArcFit = aFit;\r\n          bestLineFit = null;\r\n        } else {\r\n          bestType = \"line\";\r\n          bestLineFit = lFit;\r\n          bestArcFit = null;\r\n        }\r\n      } else if (lValid) {\r\n        bestType = \"line\";\r\n        bestLineFit = lFit;\r\n        bestArcFit = null;\r\n      } else {\r\n        bestType = \"arc\";\r\n        bestArcFit = aFit;\r\n        bestLineFit = null;\r\n      }\r\n    }\r\n\r\n    // Create segment\r\n    const startP = points[startIndex];\r\n    const endP = points[bestEndIndex];\r\n    const segmentPoints = points.slice(startIndex, bestEndIndex + 1);\r\n\r\n    if (bestType === \"line\") {\r\n      if (!bestLineFit) {\r\n        const dx = endP.x - startP.x;\r\n        const dy = endP.y - startP.y;\r\n        const len = Math.sqrt(dx * dx + dy * dy);\r\n        bestLineFit = {\r\n          line: { point: startP, direction: { x: dx / len, y: dy / len } },\r\n          rmsError: 0,\r\n          medianError: 0,\r\n          count: 2,\r\n          errors: [0, 0],\r\n        };\r\n      }\r\n\r\n      segments.push({\r\n        type: \"line\",\r\n        line: bestLineFit!.line,\r\n        start: startP,\r\n        end: endP,\r\n        points: segmentPoints,\r\n      });\r\n    } else {\r\n      segments.push({\r\n        type: \"arc\",\r\n        arc: {\r\n          center: bestArcFit!.circle.center,\r\n          radius: bestArcFit!.circle.radius,\r\n          startAngle: bestArcFit!.startAngle,\r\n          endAngle: bestArcFit!.endAngle,\r\n          clockwise: bestArcFit!.clockwise,\r\n        },\r\n        start: startP,\r\n        end: endP,\r\n        points: segmentPoints,\r\n      });\r\n    }\r\n\r\n    startIndex = bestEndIndex;\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\nimport type { OptNode, OptSegment } from \"./optimizer.ts\";\r\n\r\n/**\r\n * Simplifies the edges in the graph into geometric segments (lines and arcs).\r\n */\r\nexport function simplifyGraph(\r\n  graph: Graph,\r\n  onIteration?: (\r\n    edgeId: number,\r\n    nodes: OptNode[],\r\n    segments: OptSegment[],\r\n    label: string,\r\n  ) => void,\r\n): SimplifiedGraph {\r\n  const simplifiedEdges: SimplifiedEdge[] = [];\r\n\r\n  for (const edge of graph.edges) {\r\n    if (edge.points.length < 2) {\r\n      continue;\r\n    }\r\n\r\n    // 1. Initial Greedy Pass\r\n    const initialSegments = segmentEdge(edge.points);\r\n\r\n    const initial: SimplifiedEdge = {\r\n      original: edge,\r\n      segments: initialSegments,\r\n    };\r\n\r\n    // 2. Optimization Pass\r\n    const optimized = optimizeEdge(\r\n      initial,\r\n      initialSegments,\r\n      (nodes, segments, label) => {\r\n        if (onIteration) onIteration(edge.id, nodes, segments, label);\r\n      },\r\n    );\r\n    simplifiedEdges.push(optimized);\r\n  }\r\n\r\n  return {\r\n    nodes: graph.nodes,\r\n    edges: simplifiedEdges,\r\n  };\r\n}\r\n", "/**\r\n * Vectorization module - converts skeletonized binary images to vector paths\r\n */\r\n\r\nimport type { BinaryImage } from \"../src/formats/binary.ts\";\r\nimport { traceGraph } from \"../src/vectorize/tracer.ts\";\r\nimport { type Segment, simplifyGraph } from \"../src/vectorize/simplifier.ts\";\r\n\r\nexport interface SimplifiedPath {\r\n  points: Array<{ x: number; y: number }>; // Just coordinates after simplification\r\n  closed: boolean;\r\n  segments: Segment[]; // Segment information for rendering arcs\r\n}\r\n\r\nexport interface VectorizedImage {\r\n  width: number;\r\n  height: number;\r\n  paths: SimplifiedPath[]; // Use SimplifiedPath after vectorization\r\n}\r\n\r\n/**\r\n * Convert a skeletonized binary image to vertices and connected paths\r\n * Single-pass algorithm that traces complete paths\r\n */\r\nexport function vectorizeSkeleton(binary: BinaryImage): VectorizedImage {\r\n  const graph = traceGraph(binary);\r\n  const simplified = simplifyGraph(graph);\r\n\r\n  const paths: SimplifiedPath[] = simplified.edges.map((edge, index) => {\r\n    console.log(`Path ${index}: ${edge.segments.length} segments`);\r\n    edge.segments.forEach((seg, segIndex) => {\r\n      if (seg.type === \"line\") {\r\n        console.log(\r\n          `  [${segIndex}] LINE: (${seg.start.x.toFixed(2)}, ${\r\n            seg.start.y.toFixed(2)\r\n          }) -> (${seg.end.x.toFixed(2)}, ${seg.end.y.toFixed(2)})`,\r\n        );\r\n      } else {\r\n        console.log(\r\n          `  [${segIndex}] ARC: (${seg.start.x.toFixed(2)}, ${\r\n            seg.start.y.toFixed(2)\r\n          }) -> (${seg.end.x.toFixed(2)}, ${seg.end.y.toFixed(2)}) R=${\r\n            seg.arc.radius.toFixed(2)\r\n          } CW=${seg.arc.clockwise}`,\r\n        );\r\n      }\r\n    });\r\n\r\n    // Collect all points from segments for the 'points' property\r\n    const allPoints: Array<{ x: number; y: number }> = [];\r\n    for (const seg of edge.segments) {\r\n      allPoints.push(...seg.points);\r\n    }\r\n\r\n    // Determine if closed\r\n    const first = edge.segments[0].start;\r\n    const last = edge.segments[edge.segments.length - 1].end;\r\n    const closed = Math.abs(first.x - last.x) < 1e-4 &&\r\n      Math.abs(first.y - last.y) < 1e-4;\r\n\r\n    return {\r\n      points: allPoints,\r\n      closed,\r\n      segments: edge.segments,\r\n    };\r\n  });\r\n\r\n  return {\r\n    width: binary.width,\r\n    height: binary.height,\r\n    paths,\r\n  };\r\n}\r\n\r\nexport function renderVectorizedToSVG(\r\n  image: VectorizedImage,\r\n  svgElement: SVGElement,\r\n  width?: number,\r\n  height?: number,\r\n) {\r\n  // Clear existing content\r\n  while (svgElement.firstChild) {\r\n    svgElement.removeChild(svgElement.firstChild);\r\n  }\r\n\r\n  if (width && height) {\r\n    svgElement.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\r\n  } else {\r\n    svgElement.setAttribute(\r\n      \"viewBox\",\r\n      `0 0 ${image.width} ${image.height}`,\r\n    );\r\n  }\r\n\r\n  for (const path of image.paths) {\r\n    // Draw segments\r\n    let d = \"\";\r\n    if (path.segments && path.segments.length > 0) {\r\n      const first = path.segments[0];\r\n      d += `M ${first.start.x + 0.5} ${first.start.y + 0.5} `;\r\n\r\n      for (const seg of path.segments) {\r\n        if (seg.type === \"line\") {\r\n          d += `L ${seg.end.x + 0.5} ${seg.end.y + 0.5} `;\r\n        } else if (seg.type === \"arc\") {\r\n          const r = seg.arc.radius;\r\n          const largeArc =\r\n            Math.abs(seg.arc.endAngle - seg.arc.startAngle) > Math.PI ? 1 : 0;\r\n          const sweep = seg.arc.clockwise ? 1 : 0;\r\n          d += `A ${r} ${r} 0 ${largeArc} ${sweep} ${seg.end.x + 0.5} ${\r\n            seg.end.y + 0.5\r\n          } `;\r\n        }\r\n      }\r\n      if (path.closed) {\r\n        d += \"Z\";\r\n      }\r\n    } else {\r\n      // Fallback to points if no segments (shouldn't happen with new simplifier)\r\n      if (path.points.length > 0) {\r\n        d += `M ${path.points[0].x + 0.5} ${path.points[0].y + 0.5} `;\r\n        for (let i = 1; i < path.points.length; i++) {\r\n          d += `L ${path.points[i].x + 0.5} ${path.points[i].y + 0.5} `;\r\n        }\r\n        if (path.closed) d += \"Z\";\r\n      }\r\n    }\r\n\r\n    // Create path element\r\n    const pathEl = document.createElementNS(\r\n      \"http://www.w3.org/2000/svg\",\r\n      \"path\",\r\n    );\r\n    pathEl.setAttribute(\"d\", d);\r\n    pathEl.setAttribute(\"fill\", \"none\");\r\n    pathEl.setAttribute(\"stroke\", \"red\");\r\n    pathEl.setAttribute(\"stroke-width\", \"1\");\r\n    pathEl.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n    svgElement.appendChild(pathEl);\r\n\r\n    // Draw vertices (endpoints of segments)\r\n    for (const seg of path.segments) {\r\n      const circle = document.createElementNS(\r\n        \"http://www.w3.org/2000/svg\",\r\n        \"circle\",\r\n      );\r\n      circle.setAttribute(\"cx\", (seg.start.x + 0.5).toString());\r\n      circle.setAttribute(\"cy\", (seg.start.y + 0.5).toString());\r\n      circle.setAttribute(\"r\", \"0.5\");\r\n      circle.setAttribute(\"fill\", \"blue\");\r\n      circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n      svgElement.appendChild(circle);\r\n    }\r\n    // Draw last endpoint\r\n    if (path.segments.length > 0) {\r\n      const last = path.segments[path.segments.length - 1];\r\n      const circle = document.createElementNS(\r\n        \"http://www.w3.org/2000/svg\",\r\n        \"circle\",\r\n      );\r\n      circle.setAttribute(\"cx\", (last.end.x + 0.5).toString());\r\n      circle.setAttribute(\"cy\", (last.end.y + 0.5).toString());\r\n      circle.setAttribute(\"r\", \"0.5\");\r\n      circle.setAttribute(\"fill\", \"blue\");\r\n      circle.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\r\n      svgElement.appendChild(circle);\r\n    }\r\n  }\r\n}\r\n", "// Browser application entry point - New UI\nimport { loadImageFromFile } from \"../src/pdf/image_load.ts\";\nimport { renderPdfPage } from \"../src/pdf/pdf_render.ts\";\nimport type { CanvasBackend } from \"../src/pdf/pdf_render.ts\";\nimport { cleanupGPU, recombineWithValue } from \"../src/gpu/cleanup_gpu.ts\";\nimport { processValueChannel } from \"../src/gpu/value_process_gpu.ts\";\nimport { palettizeGPU } from \"../src/gpu/palettize_gpu.ts\";\nimport { median3x3GPU } from \"../src/gpu/median_gpu.ts\";\nimport { extractBlackGPU } from \"../src/gpu/extract_black_gpu.ts\";\nimport { bloomFilter3x3GPU } from \"../src/gpu/bloom_gpu.ts\";\nimport { subtractBlackGPU } from \"../src/gpu/subtract_black_gpu.ts\";\nimport { createGPUBuffer, getGPUContext } from \"../src/gpu/gpu_context.ts\";\nimport type { RGBAImage } from \"../src/formats/rgba_image.ts\";\nimport type { PalettizedImage } from \"../src/formats/palettized.ts\";\nimport type { BinaryImage } from \"../src/formats/binary.ts\";\nimport { DEFAULT_PALETTE } from \"../src/formats/palettized.ts\";\nimport {\n  clearAllFiles,\n  deleteFile,\n  getFile,\n  listFiles,\n  saveFile,\n  updateFile,\n} from \"./storage.ts\";\nimport type {\n  AppMode,\n  BaseProcessingStage,\n  PaletteColor,\n  ProcessingStage,\n} from \"./types.ts\";\nimport { hexToRGBA, u32ToHex } from \"./utils.ts\";\nimport { state } from \"./state.ts\";\nimport {\n  adjustCropRegion,\n  cropImage,\n  drawCropOverlay,\n  fitToScreen,\n  getCropHandleAtPoint,\n  getCropSettings,\n  initCanvasElements,\n  loadImage,\n  redrawCanvas,\n  saveCropSettings,\n  setDefaultCrop,\n  updateCropInfo,\n  updateCursorForHandle,\n  updateTransform,\n  updateZoom,\n} from \"./canvas.ts\";\nimport {\n  addPaletteColor,\n  buildPaletteRGBA,\n  forceDeactivateEyedropper,\n  initPaletteDB,\n  initPaletteModule,\n  isEyedropperActive,\n  loadDefaultPalette,\n  loadPalette,\n  pickColorFromCanvas,\n  renderPaletteUI,\n  resetPaletteToDefault,\n  savePalette,\n  setDefaultPalette,\n} from \"./palette.ts\";\nimport { renderVectorizedToSVG, vectorizeSkeleton } from \"./vectorize.ts\";\n\n// Browser canvas backend for PDF rendering\nconst browserCanvasBackend: CanvasBackend = {\n  createCanvas(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n};\n\n// Declare global pdfjsLib from CDN script\n// deno-lint-ignore no-explicit-any\ndeclare const pdfjsLib: any;\n\n// DOM Elements\nconst uploadFileList = document.getElementById(\n  \"uploadFileList\",\n) as HTMLDivElement;\nconst uploadBtn = document.getElementById(\"uploadBtn\") as HTMLButtonElement;\nconst clearAllBtn = document.getElementById(\"clearAllBtn\") as HTMLButtonElement;\nconst fileInput = document.getElementById(\"fileInput\") as HTMLInputElement;\n\nconst uploadScreen = document.getElementById(\"uploadScreen\") as HTMLDivElement;\n\nconst pageSelectionScreen = document.getElementById(\n  \"pageSelectionScreen\",\n) as HTMLDivElement;\nconst pdfFileName = document.getElementById(\n  \"pdfFileName\",\n) as HTMLHeadingElement;\nconst pageGrid = document.getElementById(\"pageGrid\") as HTMLDivElement;\nconst pageStatusText = document.getElementById(\n  \"pageStatusText\",\n) as HTMLDivElement;\nconst backToFilesBtn = document.getElementById(\n  \"backToFilesBtn\",\n) as HTMLButtonElement;\n\nconst cropScreen = document.getElementById(\"cropScreen\") as HTMLDivElement;\nconst canvasContainer = document.getElementById(\n  \"canvasContainer\",\n) as HTMLDivElement;\nconst mainCanvas = document.getElementById(\"mainCanvas\") as HTMLCanvasElement;\nconst ctx = mainCanvas.getContext(\"2d\")!;\nconst cropOverlay = document.getElementById(\"cropOverlay\") as HTMLCanvasElement;\nconst cropCtx = cropOverlay.getContext(\"2d\")!;\n\nconst zoomInBtn = document.getElementById(\"zoomInBtn\") as HTMLButtonElement;\nconst zoomOutBtn = document.getElementById(\"zoomOutBtn\") as HTMLButtonElement;\nconst zoomLevel = document.getElementById(\"zoomLevel\") as HTMLDivElement;\nconst fitToScreenBtn = document.getElementById(\n  \"fitToScreenBtn\",\n) as HTMLButtonElement;\nconst clearCropBtn = document.getElementById(\n  \"clearCropBtn\",\n) as HTMLButtonElement;\nconst cropInfo = document.getElementById(\"cropInfo\") as HTMLDivElement;\nconst processBtn = document.getElementById(\"processBtn\") as HTMLButtonElement;\nconst statusText = document.getElementById(\"statusText\") as HTMLDivElement;\nconst resultsContainer = document.getElementById(\n  \"resultsContainer\",\n) as HTMLDivElement;\n\n// Top navigation elements\nconst navStepFile = document.getElementById(\"navStepFile\") as HTMLDivElement;\nconst navStepPage = document.getElementById(\"navStepPage\") as HTMLDivElement;\nconst navStepConfigure = document.getElementById(\n  \"navStepConfigure\",\n) as HTMLDivElement;\nconst toggleToolbarBtn = document.getElementById(\n  \"toggleToolbarBtn\",\n) as HTMLButtonElement;\nconst cropSidebar = document.getElementById(\"cropSidebar\") as HTMLDivElement;\nconst processSidebar = document.getElementById(\n  \"processSidebar\",\n) as HTMLDivElement;\n\n// Palette editor elements (removed const paletteList - now defined in renderPaletteUI)\nconst paletteName = document.getElementById(\"paletteName\") as HTMLInputElement;\nconst addPaletteColorBtn = document.getElementById(\n  \"addPaletteColorBtn\",\n) as HTMLButtonElement;\nconst resetPaletteBtn = document.getElementById(\n  \"resetPaletteBtn\",\n) as HTMLButtonElement;\nconst savePaletteBtn = document.getElementById(\n  \"savePaletteBtn\",\n) as HTMLButtonElement;\nconst loadPaletteBtn = document.getElementById(\n  \"loadPaletteBtn\",\n) as HTMLButtonElement;\nconst setDefaultPaletteBtn = document.getElementById(\n  \"setDefaultPaletteBtn\",\n) as HTMLButtonElement;\n\nconsole.log(\"Palette buttons:\", {\n  addPaletteColorBtn,\n  resetPaletteBtn,\n  savePaletteBtn,\n  loadPaletteBtn,\n  setDefaultPaletteBtn,\n});\n\nconst processingScreen = document.getElementById(\n  \"processingScreen\",\n) as HTMLDivElement;\nconst processCanvasContainer = document.getElementById(\n  \"processCanvasContainer\",\n) as HTMLDivElement;\nconst processContent = document.getElementById(\n  \"processContent\",\n) as HTMLDivElement;\nconst processCanvas = document.getElementById(\n  \"processCanvas\",\n) as HTMLCanvasElement;\nconst processCtx = processCanvas.getContext(\"2d\")!;\nconst processSvgOverlay = document.getElementById(\n  \"processSvgOverlay\",\n) as SVGSVGElement;\nconst processZoomInBtn = document.getElementById(\n  \"processZoomInBtn\",\n) as HTMLButtonElement;\nconst processZoomOutBtn = document.getElementById(\n  \"processZoomOutBtn\",\n) as HTMLButtonElement;\nconst processZoomLevel = document.getElementById(\n  \"processZoomLevel\",\n) as HTMLDivElement;\nconst processFitToScreenBtn = document.getElementById(\n  \"processFitToScreenBtn\",\n) as HTMLButtonElement;\nconst copyImageBtn = document.getElementById(\n  \"copyImageBtn\",\n) as HTMLButtonElement;\nconst processStatusText = document.getElementById(\n  \"processStatusText\",\n) as HTMLDivElement;\n\nconst stageCroppedBtn = document.getElementById(\n  \"stageCroppedBtn\",\n) as HTMLButtonElement;\nconst stageExtractBlackBtn = document.getElementById(\n  \"stageExtractBlackBtn\",\n) as HTMLButtonElement;\nconst stageSubtractBlackBtn = document.getElementById(\n  \"stageSubtractBlackBtn\",\n) as HTMLButtonElement;\nconst stageValueBtn = document.getElementById(\n  \"stageValueBtn\",\n) as HTMLButtonElement;\nconst stageSaturationBtn = document.getElementById(\n  \"stageSaturationBtn\",\n) as HTMLButtonElement;\nconst stageSaturationMedianBtn = document.getElementById(\n  \"stageSaturationMedianBtn\",\n) as HTMLButtonElement;\nconst stageHueBtn = document.getElementById(\"stageHueBtn\") as HTMLButtonElement;\nconst stageHueMedianBtn = document.getElementById(\n  \"stageHueMedianBtn\",\n) as HTMLButtonElement;\nconst stageCleanupBtn = document.getElementById(\n  \"stageCleanupBtn\",\n) as HTMLButtonElement;\nconst stagePalettizedBtn = document.getElementById(\n  \"stagePalettizedBtn\",\n) as HTMLButtonElement;\nconst stageMedianBtn = document.getElementById(\n  \"stageMedianBtn\",\n) as HTMLButtonElement;\nconst colorStagesContainer = document.getElementById(\n  \"colorStagesContainer\",\n) as HTMLDivElement;\nconst vectorOverlayContainer = document.getElementById(\n  \"vectorOverlayContainer\",\n) as HTMLDivElement;\n\n// Initialize canvas and palette modules\ninitCanvasElements({\n  canvasContainer,\n  mainCanvas,\n  ctx,\n  cropOverlay,\n  cropCtx,\n  zoomLevel,\n  cropInfo,\n});\n\ninitPaletteModule({\n  showStatus,\n  mainCanvas,\n});\n\n// Processing screen event handlers\nstageCroppedBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"cropped\"),\n);\nstageExtractBlackBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"extract_black\"),\n);\nstageSubtractBlackBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"subtract_black\"),\n);\nstageValueBtn.addEventListener(\"click\", () => displayProcessingStage(\"value\"));\nstageSaturationBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"saturation\"),\n);\nstageSaturationMedianBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"saturation_median\"),\n);\nstageHueBtn.addEventListener(\"click\", () => displayProcessingStage(\"hue\"));\nstageHueMedianBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"hue_median\"),\n);\nstageCleanupBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"cleanup\"),\n);\nstagePalettizedBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"palettized\"),\n);\nstageMedianBtn.addEventListener(\n  \"click\",\n  () => displayProcessingStage(\"median\"),\n);\n\nprocessZoomInBtn.addEventListener(\"click\", () => {\n  state.processZoom = Math.min(10, state.processZoom * 1.2);\n  updateProcessZoom();\n  updateProcessTransform();\n});\n\nprocessZoomOutBtn.addEventListener(\"click\", () => {\n  state.processZoom = Math.max(0.1, state.processZoom / 1.2);\n  updateProcessZoom();\n  updateProcessTransform();\n});\n\nprocessFitToScreenBtn.addEventListener(\"click\", () => {\n  processFitToScreen();\n});\n\ncopyImageBtn.addEventListener(\"click\", async () => {\n  // Get current stage image\n  const image = state.processedImages.get(state.currentStage);\n  if (!image) {\n    showStatus(\"No image to copy\", true);\n    return;\n  }\n\n  // Create a temporary canvas with the image\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.width = image.width;\n  tempCanvas.height = image.height;\n  const tempCtx = tempCanvas.getContext(\"2d\")!;\n\n  // Convert image to RGBA and draw\n  const numPixels = image.width * image.height;\n  const rgbaData = new Uint8ClampedArray(numPixels * 4);\n\n  // Check if it's a binary image\n  const expectedBinaryLength = Math.ceil(numPixels / 8);\n  if (\n    image.data instanceof Uint8Array &&\n    image.data.length === expectedBinaryLength\n  ) {\n    // BinaryImage - convert bit-packed 1-bit to RGBA\n    for (let y = 0; y < image.height; y++) {\n      for (let x = 0; x < image.width; x++) {\n        const pixelIndex = y * image.width + x;\n        const byteIndex = Math.floor(pixelIndex / 8);\n        const bitIndex = 7 - (pixelIndex % 8);\n        const bitValue = (image.data[byteIndex] >> bitIndex) & 1;\n        const value = bitValue ? 0 : 255; // 1=black, 0=white\n        const offset = pixelIndex * 4;\n        rgbaData[offset] = value;\n        rgbaData[offset + 1] = value;\n        rgbaData[offset + 2] = value;\n        rgbaData[offset + 3] = 255;\n      }\n    }\n  } else {\n    // Assume RGBA\n    for (let i = 0; i < image.data.length; i++) {\n      rgbaData[i] = image.data[i];\n    }\n  }\n\n  const imageData = new ImageData(rgbaData, image.width, image.height);\n  tempCtx.putImageData(imageData, 0, 0);\n\n  // Convert to base64 PNG\n  const dataUrl = tempCanvas.toDataURL(\"image/png\");\n\n  try {\n    await navigator.clipboard.writeText(dataUrl);\n    showStatus(\n      `Copied ${image.width}x${image.height} image as base64 PNG to clipboard`,\n    );\n  } catch (err) {\n    console.error(\"Failed to copy to clipboard:\", err);\n    // Fallback: log to console\n    console.log(\"Base64 PNG data URL:\");\n    console.log(dataUrl);\n    showStatus(\"Logged base64 PNG to console (clipboard failed)\");\n  }\n});\n\n// Navigation step click handlers\nnavStepFile.addEventListener(\"click\", () => {\n  if (!navStepFile.classList.contains(\"disabled\")) {\n    setMode(\"upload\");\n  }\n});\n\nnavStepPage.addEventListener(\"click\", () => {\n  if (!navStepPage.classList.contains(\"disabled\") && state.currentPdfData) {\n    setMode(\"pageSelection\");\n  }\n});\n\n// Sidebar toggle\ntoggleToolbarBtn.addEventListener(\"click\", () => {\n  cropSidebar?.classList.toggle(\"collapsed\");\n  processSidebar?.classList.toggle(\"collapsed\");\n});\n\n// Initialize\nrefreshFileList();\nsetMode(\"upload\");\n\n// File management\nuploadBtn.addEventListener(\"click\", (e) => {\n  e.stopPropagation();\n  fileInput.click();\n});\n\nuploadScreen.addEventListener(\"click\", (e) => {\n  const target = e.target as HTMLElement;\n  // Don't trigger file input if clicking on a file card, button, or inside the files grid\n  if (target.closest(\".file-card\") || target.closest(\".upload-actions\")) {\n    return;\n  }\n  // Only trigger on empty area or the upload-empty placeholder\n  if (target === uploadScreen || target.closest(\".upload-file-list\")) {\n    fileInput.click();\n  }\n});\n\nfileInput.addEventListener(\"change\", (e) => {\n  const files = (e.target as HTMLInputElement).files;\n  if (files && files.length > 0) {\n    handleFileUpload(files[0]);\n  }\n});\n\n// Drag and drop on entire upload screen\nuploadScreen.addEventListener(\"dragover\", (e) => {\n  e.preventDefault();\n  uploadScreen.classList.add(\"drag-over\");\n});\n\nuploadScreen.addEventListener(\"dragleave\", (e) => {\n  if (e.target === uploadScreen) {\n    uploadScreen.classList.remove(\"drag-over\");\n  }\n});\n\nuploadScreen.addEventListener(\"drop\", (e) => {\n  e.preventDefault();\n  uploadScreen.classList.remove(\"drag-over\");\n  const files = e.dataTransfer?.files;\n  if (files && files.length > 0) {\n    handleFileUpload(files[0]);\n  }\n});\n\nclearAllBtn.addEventListener(\"click\", async () => {\n  if (confirm(\"Delete all saved files?\")) {\n    await clearAllFiles();\n    await refreshFileList();\n    showStatus(\"All files cleared\");\n  }\n});\n\nbackToFilesBtn.addEventListener(\"click\", () => {\n  state.currentFileId = null;\n  state.currentPdfData = null;\n  state.currentImage = null;\n  state.cropRegion = null;\n  setMode(\"upload\");\n  refreshFileList();\n});\n\n// Zoom controls\nzoomInBtn.addEventListener(\"click\", () => {\n  state.zoom = Math.min(10, state.zoom * 1.2);\n  updateZoom();\n  updateTransform();\n});\n\nzoomOutBtn.addEventListener(\"click\", () => {\n  state.zoom /= 1.2;\n  updateZoom();\n  redrawCanvas();\n});\n\nfitToScreenBtn.addEventListener(\"click\", () => {\n  fitToScreen();\n});\n\n// Crop controls - crop is always active\nclearCropBtn.addEventListener(\"click\", () => {\n  // Reset to default 10% margin\n  if (state.currentImage) {\n    setDefaultCrop(state.currentImage.width, state.currentImage.height);\n    drawCropOverlay();\n  }\n});\n\nprocessBtn.addEventListener(\"click\", async () => {\n  if (state.currentImage) {\n    await startProcessing();\n  }\n});\n\n// Canvas interaction\ncanvasContainer.addEventListener(\"mousedown\", (e) => {\n  const rect = canvasContainer.getBoundingClientRect();\n  const canvasX = (e.clientX - rect.left - state.panX) / state.zoom;\n  const canvasY = (e.clientY - rect.top - state.panY) / state.zoom;\n\n  // Check if clicking on a crop handle\n  const handle = getCropHandleAtPoint(canvasX, canvasY);\n  if (handle && state.cropRegion) {\n    state.isDraggingCropHandle = true;\n    state.activeCropHandle = handle;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n  } else if (!e.shiftKey) {\n    // Pan with mouse drag (when not shift-clicking)\n    state.isPanning = true;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n    canvasContainer.classList.add(\"grabbing\");\n  }\n});\n\ncanvasContainer.addEventListener(\"mousemove\", (e) => {\n  if (\n    state.isDraggingCropHandle && state.activeCropHandle && state.cropRegion\n  ) {\n    const dx = (e.clientX - state.lastPanX) / state.zoom;\n    const dy = (e.clientY - state.lastPanY) / state.zoom;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n\n    // Adjust crop region based on handle\n    adjustCropRegion(state.activeCropHandle, dx, dy);\n    drawCropOverlay();\n  } else if (state.isPanning) {\n    const dx = e.clientX - state.lastPanX;\n    const dy = e.clientY - state.lastPanY;\n    state.panX += dx;\n    state.panY += dy;\n    state.lastPanX = e.clientX;\n    state.lastPanY = e.clientY;\n    updateTransform();\n  } else {\n    // Update cursor based on hover\n    const rect = canvasContainer.getBoundingClientRect();\n    const canvasX = (e.clientX - rect.left - state.panX) / state.zoom;\n    const canvasY = (e.clientY - rect.top - state.panY) / state.zoom;\n    const handle = getCropHandleAtPoint(canvasX, canvasY);\n    updateCursorForHandle(handle);\n  }\n});\n\ncanvasContainer.addEventListener(\"mouseup\", () => {\n  if (state.isDraggingCropHandle) {\n    state.isDraggingCropHandle = false;\n    state.activeCropHandle = null;\n    // Save crop settings\n    if (state.currentImage && state.cropRegion) {\n      saveCropSettings(\n        state.currentImage.width,\n        state.currentImage.height,\n        state.cropRegion,\n      );\n      updateCropInfo();\n    }\n  }\n\n  if (state.isPanning) {\n    state.isPanning = false;\n    canvasContainer.classList.remove(\"grabbing\");\n  }\n});\n\ncanvasContainer.addEventListener(\"mouseleave\", () => {\n  state.isPanning = false;\n  canvasContainer.classList.remove(\"grabbing\");\n});\n\ncanvasContainer.addEventListener(\"wheel\", (e) => {\n  e.preventDefault();\n\n  // Check if this is a pinch state.zoom (ctrlKey) or two-finger pan\n  const isPinchZoom = e.ctrlKey;\n\n  if (isPinchZoom) {\n    // Pinch to state.zoom\n    const rect = canvasContainer.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    // Calculate the point in canvas coordinates before state.zoom\n    const canvasX = (mouseX - state.panX) / state.zoom;\n    const canvasY = (mouseY - state.panY) / state.zoom;\n\n    // Apply state.zoom with constant speed in log space (feels consistent at all state.zoom levels)\n    // Instead of multiplying by a factor, we adjust by a fixed percentage of the current state.zoom\n    const zoomSpeed = 0.01; // Adjust this to change overall state.zoom speed\n    const zoomChange = -e.deltaY * zoomSpeed * state.zoom;\n    const newZoom = Math.max(0.1, Math.min(20, state.zoom + zoomChange));\n\n    // Adjust pan to keep the point under the mouse\n    state.panX = mouseX - canvasX * newZoom;\n    state.panY = mouseY - canvasY * newZoom;\n    state.zoom = newZoom;\n\n    updateZoom();\n    updateTransform();\n  } else {\n    // Two-finger pan (or mouse wheel)\n    state.panX -= e.deltaX;\n    state.panY -= e.deltaY;\n    updateTransform();\n  }\n});\n\n// Processing canvas interaction\nprocessCanvasContainer.addEventListener(\"mousedown\", (e) => {\n  state.isProcessPanning = true;\n  state.lastProcessPanX = e.clientX;\n  state.lastProcessPanY = e.clientY;\n  processCanvasContainer.classList.add(\"grabbing\");\n});\n\nprocessCanvasContainer.addEventListener(\"mousemove\", (e) => {\n  if (state.isProcessPanning) {\n    const dx = e.clientX - state.lastProcessPanX;\n    const dy = e.clientY - state.lastProcessPanY;\n    state.processPanX += dx;\n    state.processPanY += dy;\n    state.lastProcessPanX = e.clientX;\n    state.lastProcessPanY = e.clientY;\n    updateProcessTransform();\n  }\n});\n\nprocessCanvasContainer.addEventListener(\"mouseup\", () => {\n  if (state.isProcessPanning) {\n    state.isProcessPanning = false;\n    processCanvasContainer.classList.remove(\"grabbing\");\n  }\n});\n\nprocessCanvasContainer.addEventListener(\"mouseleave\", () => {\n  state.isProcessPanning = false;\n  processCanvasContainer.classList.remove(\"grabbing\");\n});\n\nprocessCanvasContainer.addEventListener(\"wheel\", (e) => {\n  e.preventDefault();\n\n  const isPinchZoom = e.ctrlKey;\n\n  if (isPinchZoom) {\n    // Pinch to zoom\n    const rect = processCanvasContainer.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    // Get dimensions from either processed image or vectorized image\n    let width = 0, height = 0;\n    const image = state.processedImages.get(state.currentStage);\n    if (image) {\n      width = image.width;\n      height = image.height;\n    } else if (state.currentStage.endsWith(\"_vec\")) {\n      const vectorized = state.vectorizedImages.get(state.currentStage);\n      if (vectorized) {\n        width = vectorized.width;\n        height = vectorized.height;\n      }\n    }\n\n    if (width === 0 || height === 0) return;\n\n    const canvasX = (mouseX - state.processPanX) / state.processZoom;\n    const canvasY = (mouseY - state.processPanY) / state.processZoom;\n\n    const zoomSpeed = 0.005;\n    const zoomChange = -e.deltaY * zoomSpeed * state.processZoom;\n    const newZoom = Math.max(0.1, Math.min(10, state.processZoom + zoomChange));\n\n    state.processPanX = mouseX - canvasX * newZoom;\n    state.processPanY = mouseY - canvasY * newZoom;\n    state.processZoom = newZoom;\n\n    updateProcessZoom();\n    updateProcessTransform();\n  } else {\n    // Two-finger pan (or mouse wheel)\n    state.processPanX -= e.deltaX;\n    state.processPanY -= e.deltaY;\n    updateProcessTransform();\n  }\n});\n\n// Mode management\nfunction updateNavigation(mode: AppMode) {\n  // Update navigation step states\n  navStepFile.classList.remove(\"active\", \"completed\", \"disabled\");\n  navStepPage.classList.remove(\"active\", \"completed\", \"disabled\");\n  navStepConfigure.classList.remove(\"active\", \"completed\", \"disabled\");\n\n  switch (mode) {\n    case \"upload\":\n      navStepFile.classList.add(\"active\");\n      navStepPage.classList.add(\"disabled\");\n      navStepConfigure.classList.add(\"disabled\");\n      break;\n    case \"pageSelection\":\n      navStepFile.classList.add(\"completed\");\n      navStepPage.classList.add(\"active\");\n      navStepConfigure.classList.add(\"disabled\");\n      break;\n    case \"crop\":\n      navStepFile.classList.add(\"completed\");\n      navStepPage.classList.add(\"completed\");\n      navStepConfigure.classList.add(\"active\");\n      break;\n    case \"processing\":\n      navStepFile.classList.add(\"completed\");\n      navStepPage.classList.add(\"completed\");\n      navStepConfigure.classList.add(\"completed\");\n      break;\n  }\n}\n\nfunction setMode(mode: AppMode) {\n  console.log(\"setMode called:\", mode);\n\n  uploadScreen.classList.remove(\"active\");\n  pageSelectionScreen.classList.remove(\"active\");\n  cropScreen.classList.remove(\"active\");\n  processingScreen.classList.remove(\"active\");\n\n  // Clear any inline styles that might override CSS\n  pageSelectionScreen.style.display = \"\";\n\n  switch (mode) {\n    case \"upload\":\n      uploadScreen.classList.add(\"active\");\n      console.log(\"Upload screen activated\");\n      console.log(\n        \"uploadScreen display:\",\n        globalThis.getComputedStyle(uploadScreen).display,\n      );\n      console.log(\n        \"uploadScreen hasClass active:\",\n        uploadScreen.classList.contains(\"active\"),\n      );\n      break;\n    case \"pageSelection\":\n      pageSelectionScreen.classList.add(\"active\");\n      // Force display as a test\n      pageSelectionScreen.style.display = \"flex\";\n      console.log(\n        \"Page selection screen activated, pageGrid children:\",\n        pageGrid.children.length,\n      );\n      console.log(\n        \"pageSelectionScreen display:\",\n        globalThis.getComputedStyle(pageSelectionScreen).display,\n      );\n      console.log(\n        \"pageSelectionScreen visibility:\",\n        globalThis.getComputedStyle(pageSelectionScreen).visibility,\n      );\n      break;\n    case \"crop\":\n      cropScreen.classList.add(\"active\");\n      console.log(\"Crop screen activated\");\n      break;\n    case \"processing\":\n      processingScreen.classList.add(\"active\");\n      console.log(\"Processing screen activated\");\n      break;\n  }\n\n  // Update navigation\n  updateNavigation(mode);\n}\n\nfunction showStatus(message: string, isError = false) {\n  // Update status in whichever screen is currently visible\n  let activeStatusText = statusText;\n  if (pageSelectionScreen.classList.contains(\"active\")) {\n    activeStatusText = pageStatusText;\n  } else if (processingScreen.classList.contains(\"active\")) {\n    activeStatusText = processStatusText;\n  }\n\n  activeStatusText.textContent = message;\n  if (isError) {\n    activeStatusText.classList.add(\"status-error\");\n  } else {\n    activeStatusText.classList.remove(\"status-error\");\n  }\n  console.log(message);\n}\n\n// Palette Storage Functions (IndexedDB)\n\n// Initialize palette DB (default palette will be loaded only if no file is selected)\ninitPaletteDB();\n\nasync function handleFileUpload(file: File) {\n  try {\n    showStatus(`Loading: ${file.name}...`);\n\n    // Save to storage if not already saved\n    if (!state.currentFileId) {\n      try {\n        state.currentFileId = await saveFile(file);\n        console.log(`File saved with ID: ${state.currentFileId}`);\n        // Load default palette for new uploads\n        await loadDefaultPalette();\n        await refreshFileList();\n      } catch (err) {\n        console.error(\"Error saving file:\", err);\n      }\n    }\n\n    if (file.type === \"application/pdf\") {\n      console.log(\"handleFileUpload: Detected PDF, calling loadPdf\");\n      await loadPdf(file);\n      console.log(\n        \"handleFileUpload: loadPdf complete, switching to pageSelection mode\",\n      );\n      setMode(\"pageSelection\");\n    } else {\n      console.log(\"handleFileUpload: Detected image, loading directly\");\n      const image = await loadImageFromFile(file);\n      await loadImage(image, showStatus);\n      setMode(\"crop\");\n    }\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, true);\n    console.error(error);\n  }\n}\n\nasync function loadPdf(file: File) {\n  try {\n    console.log(\"loadPdf: Starting to load\", file.name);\n    const arrayBuffer = await file.arrayBuffer();\n    console.log(\"loadPdf: Got arrayBuffer, length:\", arrayBuffer.byteLength);\n    const copy = new Uint8Array(arrayBuffer.byteLength);\n    copy.set(new Uint8Array(arrayBuffer));\n    state.currentPdfData = copy;\n    console.log(\"loadPdf: Created copy\", copy.length);\n\n    const initialCopy = state.currentPdfData.slice();\n    console.log(\"loadPdf: Calling getDocument\");\n    const loadingTask = pdfjsLib.getDocument({ data: initialCopy });\n    const pdf = await loadingTask.promise;\n    state.pdfPageCount = pdf.numPages;\n    console.log(\"loadPdf: PDF loaded, pages:\", state.pdfPageCount);\n\n    showStatus(`PDF loaded: ${state.pdfPageCount} pages`);\n    console.log(\"loadPdf: About to set pdfFileName, element:\", pdfFileName);\n    try {\n      pdfFileName.textContent = file.name;\n      console.log(\"loadPdf: pdfFileName set successfully\");\n    } catch (e) {\n      console.error(\"loadPdf: Error setting pdfFileName:\", e);\n    }\n    console.log(\"loadPdf: pdfFileName set, about to generate thumbnails\");\n\n    // Generate page thumbnails\n    console.log(\"loadPdf: Generating page thumbnails, clearing pageGrid\");\n    console.log(\"loadPdf: pageGrid element:\", pageGrid);\n    const existingCards = pageGrid.children.length;\n    if (existingCards > 0) {\n      console.log(\n        `[THUMBNAIL] PURGING ${existingCards} existing thumbnail cards from cache`,\n      );\n    }\n    pageGrid.innerHTML = \"\";\n    console.log(\n      \"loadPdf: pageGrid cleared, adding\",\n      state.pdfPageCount,\n      \"cards\",\n    );\n\n    // First pass: get all page dimensions and create cards with proper aspect ratios\n    const pageDimensions: Array<\n      { width: number; height: number; pageLabel: string }\n    > = [];\n\n    // Get page labels from PDF (if available)\n    let pageLabels: string[] | null = null;\n    try {\n      pageLabels = await pdf.getPageLabels();\n    } catch (_e) {\n      // Page labels not available, will use page numbers\n    }\n\n    for (let i = 1; i <= state.pdfPageCount; i++) {\n      const page = await pdf.getPage(i);\n      const viewport = page.getViewport({ scale: 1.0 });\n\n      // Get page label from PDF (e.g., \"i\", \"ii\", \"1\", \"A-1\", etc.)\n      const pageLabel = (pageLabels && pageLabels[i - 1]) || `Page ${i}`;\n\n      pageDimensions.push({\n        width: viewport.width,\n        height: viewport.height,\n        pageLabel,\n      });\n\n      const card = document.createElement(\"div\");\n      card.className = \"page-card\";\n\n      const imageDiv = document.createElement(\"div\");\n      imageDiv.className = \"page-card-image\";\n      imageDiv.textContent = \"\uD83D\uDCC4\";\n\n      // Set aspect ratio immediately so layout is stable\n      const aspectRatio = viewport.width / viewport.height;\n      imageDiv.style.aspectRatio = aspectRatio.toString();\n      imageDiv.style.width = (250 * aspectRatio) + \"px\";\n\n      const label = document.createElement(\"div\");\n      label.className = \"page-card-label\";\n      label.textContent = pageLabel;\n\n      card.appendChild(imageDiv);\n      card.appendChild(label);\n      card.dataset.pageNum = i.toString();\n\n      // Highlight if this is the currently selected page\n      if (i === state.currentSelectedPage) {\n        card.classList.add(\"selected\");\n      }\n\n      card.addEventListener(\"click\", () => {\n        selectPdfPage(i);\n      });\n\n      pageGrid.appendChild(card);\n    }\n\n    // Second pass: render thumbnails with interleaved priority (early pages + largest pages)\n    // Cap at reasonable number for large PDFs (~2-3 screenfuls worth)\n    const MAX_THUMBNAILS = 50;\n    const thumbnailsToRender = Math.min(state.pdfPageCount, MAX_THUMBNAILS);\n\n    // Reset cancellation flag\n    state.cancelThumbnailLoading = false;\n\n    (async () => {\n      // Sort pages by size (largest first)\n      const pagesBySize = Array.from(\n        { length: state.pdfPageCount },\n        (_, i) => i,\n      )\n        .sort((a, b) => {\n          const areaA = pageDimensions[a].width * pageDimensions[a].height;\n          const areaB = pageDimensions[b].width * pageDimensions[b].height;\n          return areaB - areaA;\n        });\n\n      // Interleave: [page 1, page 2, largest], [page 3, page 4, 2nd largest], etc.\n      const renderQueue: number[] = [];\n      const addedPages = new Set<number>();\n      let sequentialIndex = 0;\n      let largestIndex = 0;\n\n      console.log(\n        `[THUMBNAIL] Building render queue for ${thumbnailsToRender} thumbnails out of ${state.pdfPageCount} pages`,\n      );\n\n      while (\n        renderQueue.length < thumbnailsToRender &&\n        (sequentialIndex < state.pdfPageCount ||\n          largestIndex < pagesBySize.length)\n      ) {\n        // Add next 2 sequential pages\n        if (\n          sequentialIndex < state.pdfPageCount &&\n          renderQueue.length < thumbnailsToRender\n        ) {\n          if (!addedPages.has(sequentialIndex)) {\n            renderQueue.push(sequentialIndex);\n            addedPages.add(sequentialIndex);\n          }\n          sequentialIndex++;\n        }\n        if (\n          sequentialIndex < state.pdfPageCount &&\n          renderQueue.length < thumbnailsToRender\n        ) {\n          if (!addedPages.has(sequentialIndex)) {\n            renderQueue.push(sequentialIndex);\n            addedPages.add(sequentialIndex);\n          }\n          sequentialIndex++;\n        }\n\n        // Add next largest page (but skip if already in queue)\n        while (\n          largestIndex < pagesBySize.length &&\n          renderQueue.length < thumbnailsToRender\n        ) {\n          const largestPageIdx = pagesBySize[largestIndex++];\n          if (!addedPages.has(largestPageIdx)) {\n            renderQueue.push(largestPageIdx);\n            addedPages.add(largestPageIdx);\n            break;\n          }\n        }\n      }\n\n      console.log(\n        `[THUMBNAIL] Render queue built with ${renderQueue.length} pages:`,\n        renderQueue.map((idx) => {\n          const pageNum = idx + 1;\n          const label = pageDimensions[idx]?.pageLabel || `Page ${pageNum}`;\n          return `${pageNum}(${label})`;\n        }).join(\", \"),\n      );\n\n      // Render in batches of 3\n      const batchSize = 3;\n      let completed = 0;\n\n      // Store cards array once to avoid re-querying\n      const allCards = Array.from(pageGrid.children);\n\n      for (let i = 0; i < renderQueue.length; i += batchSize) {\n        // Check cancellation flag\n        if (state.cancelThumbnailLoading) {\n          console.log(\n            `[THUMBNAIL] Loading cancelled after ${completed} thumbnails`,\n          );\n          showStatus(`Thumbnail loading cancelled`);\n          return;\n        }\n\n        const batch = [];\n        const batchInfo = [];\n        for (let j = 0; j < batchSize && i + j < renderQueue.length; j++) {\n          const pageIndex = renderQueue[i + j];\n          const pageNum = pageIndex + 1;\n          const pageLabel = pageDimensions[pageIndex]?.pageLabel ||\n            `Page ${pageNum}`;\n\n          // Safely get card and image div\n          if (pageIndex < allCards.length) {\n            const card = allCards[pageIndex];\n            const imageDiv = card.querySelector(\n              \".page-card-image\",\n            ) as HTMLElement;\n            if (imageDiv) {\n              batchInfo.push(`${pageNum}(${pageLabel})`);\n              batch.push(generatePageThumbnail(pageNum, pageLabel, imageDiv));\n            } else {\n              console.warn(\n                `[THUMBNAIL] No imageDiv found for page ${pageNum}(${pageLabel}) at index ${pageIndex}`,\n              );\n            }\n          } else {\n            console.warn(\n              `[THUMBNAIL] Page index ${pageIndex} out of bounds (cards.length=${allCards.length}) for page ${pageNum}`,\n            );\n          }\n        }\n\n        if (batch.length > 0) {\n          console.log(\n            `[THUMBNAIL] Batch ${Math.floor(i / batchSize) + 1}: Rendering ${\n              batchInfo.join(\", \")\n            }`,\n          );\n          await Promise.all(batch);\n          completed += batch.length;\n          console.log(\n            `[THUMBNAIL] Batch complete. Total: ${completed}/${renderQueue.length}`,\n          );\n          const statusMsg = thumbnailsToRender < state.pdfPageCount\n            ? `Loading thumbnails: ${completed}/${thumbnailsToRender} (${state.pdfPageCount} pages total)`\n            : `Loading thumbnails: ${completed}/${state.pdfPageCount}`;\n          showStatus(statusMsg);\n        } else {\n          console.warn(\n            `[THUMBNAIL] Batch ${\n              Math.floor(i / batchSize) + 1\n            }: No valid thumbnails to render`,\n          );\n        }\n      }\n      const finalMsg = thumbnailsToRender < state.pdfPageCount\n        ? `PDF loaded: ${state.pdfPageCount} pages (showing ${thumbnailsToRender} thumbnails)`\n        : `PDF loaded: ${state.pdfPageCount} pages`;\n      showStatus(finalMsg);\n    })();\n  } catch (error) {\n    console.error(\"loadPdf error:\", error);\n    showStatus(`PDF load error: ${(error as Error).message}`, true);\n    throw error;\n  }\n}\n\nasync function generatePageThumbnail(\n  pageNum: number,\n  pageLabel: string,\n  container: HTMLElement,\n) {\n  try {\n    if (!state.currentPdfData) {\n      console.warn(`[THUMBNAIL] No PDF data for page ${pageNum}(${pageLabel})`);\n      return;\n    }\n\n    console.log(`[THUMBNAIL] START rendering page ${pageNum}(${pageLabel})`);\n    const pdfDataCopy = state.currentPdfData.slice();\n    const image = await renderPdfPage(\n      { file: pdfDataCopy, pageNumber: pageNum, scale: 0.4 },\n      browserCanvasBackend,\n      pdfjsLib,\n    );\n    console.log(\n      `[THUMBNAIL] RENDERED page ${pageNum}(${pageLabel}): ${image.width}x${image.height}`,\n    );\n\n    // Set the container's aspect ratio based on actual page dimensions\n    const aspectRatio = image.width / image.height;\n    container.style.aspectRatio = aspectRatio.toString();\n    container.style.width = (250 * aspectRatio) + \"px\";\n\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      const imageData = new ImageData(\n        new Uint8ClampedArray(image.data),\n        image.width,\n        image.height,\n      );\n      ctx.putImageData(imageData, 0, 0);\n\n      const img = document.createElement(\"img\");\n      img.src = canvas.toDataURL();\n      container.innerHTML = \"\";\n      container.appendChild(img);\n      console.log(\n        `[THUMBNAIL] COMPLETE page ${pageNum}(${pageLabel}) - image inserted into DOM`,\n      );\n    }\n  } catch (err) {\n    console.error(\n      `[THUMBNAIL] ERROR generating thumbnail for page ${pageNum}(${pageLabel}):`,\n      err,\n    );\n  }\n}\n\nasync function selectPdfPage(pageNum: number) {\n  try {\n    console.log(\"selectPdfPage: Starting, page:\", pageNum);\n    if (!state.currentPdfData) {\n      console.error(\"selectPdfPage: No PDF data!\");\n      showStatus(\"No PDF loaded\", true);\n      return;\n    }\n\n    // Cancel any ongoing thumbnail loading\n    state.cancelThumbnailLoading = true;\n\n    // Update selected page tracking\n    state.currentSelectedPage = pageNum;\n\n    // Update page card selection highlighting\n    const cards = pageGrid.querySelectorAll(\".page-card\");\n    cards.forEach((card) => card.classList.remove(\"selected\"));\n    const selectedCard = pageGrid.querySelector(`[data-page-num=\"${pageNum}\"]`);\n    if (selectedCard) {\n      selectedCard.classList.add(\"selected\");\n    }\n\n    // Switch to crop screen immediately with loading state\n    setMode(\"crop\");\n\n    // Clear previous canvas content AND hide crop overlay\n    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);\n    cropCtx.clearRect(0, 0, cropOverlay.width, cropOverlay.height);\n    mainCanvas.width = 0;\n    mainCanvas.height = 0;\n    cropOverlay.width = 0;\n    cropOverlay.height = 0;\n    cropOverlay.style.display = \"none\";\n\n    showStatus(`\u23F3 Rendering page ${pageNum} at 200 DPI...`);\n    canvasContainer.style.opacity = \"0.3\";\n\n    // Simulate progress indicator (since PDF.js doesn't provide real progress)\n    let progressDots = 0;\n    const progressInterval = setInterval(() => {\n      progressDots = (progressDots + 1) % 4;\n      showStatus(\n        `\u23F3 Rendering page ${pageNum} at 200 DPI${\".\".repeat(progressDots)}`,\n      );\n    }, 300);\n\n    console.log(\"selectPdfPage: Creating copy\");\n    const pdfDataCopy = state.currentPdfData.slice();\n    console.log(\"selectPdfPage: Calling renderPdfPage\");\n    // Scale 2.778 \u2248 200 DPI (72 * 2.778 \u2248 200)\n    const image = await renderPdfPage(\n      {\n        file: pdfDataCopy,\n        pageNumber: pageNum,\n        scale: 2.778,\n      },\n      browserCanvasBackend,\n      pdfjsLib,\n    );\n    console.log(\"selectPdfPage: Got image\", image.width, \"x\", image.height);\n\n    clearInterval(progressInterval);\n    canvasContainer.style.opacity = \"1\";\n    await loadImage(image, showStatus);\n    showStatus(`\u2713 Page ${pageNum} loaded: ${image.width}\u00D7${image.height}`);\n\n    // Update thumbnail and palette in storage\n    if (state.currentFileId && state.currentImage) {\n      const thumbnail = generateThumbnail(state.currentImage);\n      const palette = JSON.stringify(state.userPalette);\n      await updateFile(state.currentFileId, { thumbnail, palette });\n      await refreshFileList();\n    }\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, true);\n    console.error(error);\n  }\n}\n\n// Helper: Convert RGBA skeleton (grayscale) to binary format\nfunction rgbaToBinary(rgba: RGBAImage): BinaryImage {\n  const { width, height, data } = rgba;\n  const numPixels = width * height;\n  const byteCount = Math.ceil(numPixels / 8);\n  const binaryData = new Uint8Array(byteCount);\n\n  // Convert: white (255) = 0, black (0) = 1\n  for (let pixelIndex = 0; pixelIndex < numPixels; pixelIndex++) {\n    const r = data[pixelIndex * 4];\n\n    // If pixel is black (or dark), set bit to 1\n    if (r < 128) {\n      const bitByteIndex = Math.floor(pixelIndex / 8);\n      const bitIndex = 7 - (pixelIndex % 8); // MSB-first\n      binaryData[bitByteIndex] |= 1 << bitIndex;\n    }\n  }\n\n  return { width, height, data: binaryData };\n}\n\n// Crop management functions\n\n// Helper: Extract a single color from palettized image to binary format\nfunction extractColorFromPalettized(\n  palettized: PalettizedImage,\n  colorIndex: number,\n): BinaryImage {\n  const { width, height, data } = palettized;\n  const numPixels = width * height;\n\n  // Create properly bit-packed binary image\n  const byteCount = Math.ceil(numPixels / 8);\n  const binaryData = new Uint8Array(byteCount);\n\n  for (let pixelIndex = 0; pixelIndex < numPixels; pixelIndex++) {\n    const byteIndex = Math.floor(pixelIndex / 2);\n    const isHighNibble = pixelIndex % 2 === 0;\n\n    // Extract 4-bit color index from nibble\n    const paletteIndex = isHighNibble\n      ? (data[byteIndex] >> 4) & 0x0f\n      : data[byteIndex] & 0x0f;\n\n    // Set bit to 1 if this pixel matches the color we're extracting\n    if (paletteIndex === colorIndex) {\n      const bitByteIndex = Math.floor(pixelIndex / 8);\n      const bitIndex = 7 - (pixelIndex % 8); // MSB-first\n      binaryData[bitByteIndex] |= 1 << bitIndex;\n    }\n  }\n\n  return { width, height, data: binaryData };\n}\n\n// Helper: Convert Binary image to GPU buffer for processing\nasync function binaryToGPUBuffer(binary: BinaryImage): Promise<GPUBuffer> {\n  const { device } = await getGPUContext();\n  const { width, height, data } = binary;\n  const numPixels = width * height;\n\n  // Binary data is already bit-packed (8 pixels per byte, MSB-first)\n  // Convert to packed binary format for GPU (32 pixels per u32)\n  const numWords = Math.ceil(numPixels / 32);\n  const packed = new Uint32Array(numWords);\n\n  for (let i = 0; i < numPixels; i++) {\n    // Read bit from bit-packed data\n    const byteIdx = Math.floor(i / 8);\n    const bitIdx = 7 - (i % 8); // MSB-first\n    const bit = (data[byteIdx] >> bitIdx) & 1;\n\n    if (bit) {\n      const wordIdx = Math.floor(i / 32);\n      const bitInWord = i % 32;\n      packed[wordIdx] |= 1 << bitInWord;\n    }\n  }\n\n  // Create and fill GPU buffer\n  const buffer = createGPUBuffer(\n    device,\n    packed,\n    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n  );\n\n  return buffer;\n}\n\n// Processing mode functions\nasync function startProcessing() {\n  if (!state.currentImage) return;\n\n  try {\n    setMode(\"processing\");\n    state.processedImages.clear();\n    state.processViewInitialized = false; // Reset for new processing session\n\n    // Apply crop if selected\n    let processImage = state.currentImage;\n    if (\n      state.cropRegion && state.cropRegion.width > 0 &&\n      state.cropRegion.height > 0\n    ) {\n      showStatus(\"Cropping image...\");\n      processImage = cropImage(state.currentImage, state.cropRegion);\n    }\n\n    // Store and display cropped image\n    state.processedImages.set(\"cropped\", processImage);\n    displayProcessingStage(\"cropped\");\n\n    // Extract black from cropped image\n    showStatus(\"Extracting black...\");\n    const extractBlackStart = performance.now();\n    const extractedBlack = await extractBlackGPU(processImage, 0.20);\n    const extractBlackEnd = performance.now();\n    showStatus(\n      `Extract black: ${(extractBlackEnd - extractBlackStart).toFixed(1)}ms`,\n    );\n\n    state.processedImages.set(\"extract_black\", extractedBlack);\n    displayProcessingStage(\"extract_black\");\n\n    // Process color_1: median filter and skeletonize\n    const color1Buffer = await binaryToGPUBuffer(extractedBlack);\n    const color1SkelResults = await processValueChannel(\n      color1Buffer,\n      extractedBlack.width,\n      extractedBlack.height,\n    );\n\n    // Store median-filtered version as color_1, skeletonized as color_1_skel\n    state.processedImages.set(\"color_1\", color1SkelResults.median);\n    state.processedImages.set(\"color_1_skel\", color1SkelResults.skeleton);\n\n    color1Buffer.destroy();\n    color1SkelResults.skeletonBuffer.destroy();\n\n    // Apply bloom filter to extracted black\n    showStatus(\"Applying bloom filter...\");\n    const bloomStart = performance.now();\n    const bloomFiltered = await bloomFilter3x3GPU(extractedBlack);\n    const bloomEnd = performance.now();\n    showStatus(`Bloom filter: ${(bloomEnd - bloomStart).toFixed(1)}ms`);\n\n    // Subtract black from cropped image\n    showStatus(\"Subtracting black...\");\n    const subtractStart = performance.now();\n    const subtractedImage = await subtractBlackGPU(processImage, bloomFiltered);\n    const subtractEnd = performance.now();\n    showStatus(`Subtract black: ${(subtractEnd - subtractStart).toFixed(1)}ms`);\n    state.processedImages.set(\"subtract_black\", subtractedImage);\n    displayProcessingStage(\"subtract_black\");\n\n    // Use subtracted image for further processing\n    processImage = subtractedImage;\n\n    // Run GPU pipeline with auto-advance after each stage\n    showStatus(\"Running cleanup (extracting channels)...\");\n    const t1 = performance.now();\n    const cleanupResults = await cleanupGPU(processImage);\n    const t2 = performance.now();\n    showStatus(`Cleanup: ${(t2 - t1).toFixed(1)}ms`);\n\n    // Store all intermediate cleanup stages\n    state.processedImages.set(\"value\", cleanupResults.value);\n    state.processedImages.set(\"saturation\", cleanupResults.saturation);\n    state.processedImages.set(\n      \"saturation_median\",\n      cleanupResults.saturationMedian,\n    );\n    state.processedImages.set(\"hue\", cleanupResults.hue);\n    state.processedImages.set(\"hue_median\", cleanupResults.hueMedian);\n\n    // Recombine with thresholded value (no skeletonization yet)\n    showStatus(\"Recombining channels...\");\n    const t2d = performance.now();\n    const cleanupFinal = await recombineWithValue(\n      cleanupResults.valueBuffer,\n      cleanupResults.saturationBuffer,\n      cleanupResults.hueBuffer,\n      cleanupResults.width,\n      cleanupResults.height,\n    );\n    const t2e = performance.now();\n    showStatus(`Recombine: ${(t2e - t2d).toFixed(1)}ms`);\n    state.processedImages.set(\"cleanup\", cleanupFinal);\n    displayProcessingStage(\"cleanup\");\n\n    // Clean up buffers now that we're done with them\n    cleanupResults.valueBuffer.destroy();\n    cleanupResults.saturationBuffer.destroy();\n    cleanupResults.hueBuffer.destroy();\n\n    showStatus(\"Palettizing...\");\n    const t3 = performance.now();\n    const inputPalette = buildPaletteRGBA(); // Input colors for matching\n    const palettized = await palettizeGPU(cleanupFinal, inputPalette);\n\n    // Replace palette with output colors (after matching is done)\n    const outputPalette = new Uint8ClampedArray(16 * 4);\n    for (let i = 0; i < state.userPalette.length && i < 16; i++) {\n      const color = state.userPalette[i];\n      // Use output color, or background if marked for removal\n      const useColor = color.mapToBg\n        ? state.userPalette[0].outputColor\n        : color.outputColor;\n      const [r, g, b, a] = hexToRGBA(useColor);\n      outputPalette[i * 4] = r;\n      outputPalette[i * 4 + 1] = g;\n      outputPalette[i * 4 + 2] = b;\n      outputPalette[i * 4 + 3] = a;\n    }\n    for (let i = state.userPalette.length; i < 16; i++) {\n      const [r, g, b, a] = hexToRGBA(state.userPalette[0].outputColor);\n      outputPalette[i * 4] = r;\n      outputPalette[i * 4 + 1] = g;\n      outputPalette[i * 4 + 2] = b;\n      outputPalette[i * 4 + 3] = a;\n    }\n\n    // Convert to Uint32Array for palette storage\n    const outputPaletteU32 = new Uint32Array(16);\n    const outputView = new DataView(\n      outputPalette.buffer,\n      outputPalette.byteOffset,\n      outputPalette.byteLength,\n    );\n    for (let i = 0; i < 16; i++) {\n      outputPaletteU32[i] = outputView.getUint32(i * 4, true); // little-endian\n    }\n    palettized.palette = outputPaletteU32;\n\n    const t4 = performance.now();\n    showStatus(`Palettize: ${(t4 - t3).toFixed(1)}ms`);\n    state.processedImages.set(\"palettized\", palettized);\n    displayProcessingStage(\"palettized\");\n\n    // Apply median filter right after palettization (3 passes for aggressive cleaning)\n    showStatus(\"Applying median filter (pass 1/3)...\");\n    const t4b = performance.now();\n    let median = await median3x3GPU(palettized);\n    showStatus(\"Applying median filter (pass 2/3)...\");\n    median = await median3x3GPU(median);\n    showStatus(\"Applying median filter (pass 3/3)...\");\n    median = await median3x3GPU(median);\n    const t4c = performance.now();\n    showStatus(`Median filter (3 passes): ${(t4c - t4b).toFixed(1)}ms`);\n    state.processedImages.set(\"median\", median);\n    displayProcessingStage(\"median\");\n\n    // Process each non-background, non-removed color separately\n    showStatus(\"Processing individual colors...\");\n    const t5 = performance.now();\n    for (let i = 1; i < state.userPalette.length && i < 16; i++) {\n      const color = state.userPalette[i];\n      if (color.mapToBg) continue; // Skip removed colors\n      if (i === 1) continue; // Skip color_1 - already processed as extracted black\n\n      showStatus(`Processing color ${i}...`);\n\n      // Extract this color as binary from median-filtered image\n      const colorBinary = extractColorFromPalettized(median, i);\n      state.processedImages.set(`color_${i}`, colorBinary);\n\n      // Convert to GPU buffer and run skeletonization\n      const colorBuffer = await binaryToGPUBuffer(colorBinary);\n      const skelResults = await processValueChannel(\n        colorBuffer,\n        colorBinary.width,\n        colorBinary.height,\n      );\n\n      // Store skeletonized result\n      state.processedImages.set(`color_${i}_skel`, skelResults.skeleton);\n\n      // Clean up\n      colorBuffer.destroy();\n      skelResults.skeletonBuffer.destroy();\n    }\n    const t6 = performance.now();\n    showStatus(`Per-color processing: ${(t6 - t5).toFixed(1)}ms`);\n\n    // Add dynamic stage buttons for each color\n    addColorStageButtons();\n\n    const totalTime = t6 - t1;\n    showStatus(`\u2713 Pipeline complete! Total: ${totalTime.toFixed(1)}ms`);\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, true);\n    console.error(error);\n  }\n}\n\n// Add dynamic color stage buttons after processing\nfunction addColorStageButtons() {\n  // Clear existing color buttons\n  colorStagesContainer.innerHTML = \"\";\n  vectorOverlayContainer.innerHTML = \"\";\n\n  // Add a button for each non-background, non-removed color\n  for (let i = 1; i < state.userPalette.length && i < 16; i++) {\n    const color = state.userPalette[i];\n    if (color.mapToBg) continue; // Skip removed colors\n\n    // Check if this color stage exists\n    if (!state.processedImages.has(`color_${i}`)) continue;\n\n    // Color button\n    const colorBtn = document.createElement(\"button\");\n    colorBtn.className = \"stage-btn\";\n    colorBtn.textContent = `Color ${i}`;\n    colorBtn.style.borderLeft = `4px solid ${color.outputColor}`;\n    colorBtn.addEventListener(\n      \"click\",\n      () => displayProcessingStage(`color_${i}`),\n    );\n    colorStagesContainer.appendChild(colorBtn);\n\n    // Skeleton button (if it exists)\n    if (state.processedImages.has(`color_${i}_skel`)) {\n      const skelBtn = document.createElement(\"button\");\n      skelBtn.className = \"stage-btn\";\n      skelBtn.textContent = `Color ${i} Skel`;\n      skelBtn.style.borderLeft = `4px solid ${color.outputColor}`;\n      skelBtn.dataset.stage = `color_${i}_skel`;\n      skelBtn.addEventListener(\n        \"click\",\n        () => displayProcessingStage(`color_${i}_skel`),\n      );\n      colorStagesContainer.appendChild(skelBtn);\n\n      // Vector overlay toggle button\n      const vecStage = `color_${i}_vec`;\n      const vecToggle = document.createElement(\"button\");\n      vecToggle.className = \"stage-btn\";\n      vecToggle.textContent = `Color ${i} Vec`;\n      vecToggle.style.borderLeft = `4px solid ${color.outputColor}`;\n      vecToggle.dataset.stage = vecStage;\n      vecToggle.addEventListener(\"click\", () => toggleVectorOverlay(vecStage));\n      vectorOverlayContainer.appendChild(vecToggle);\n    }\n  }\n}\n\nfunction toggleVectorOverlay(vecStage: string) {\n  // If clicking the same overlay, toggle it off\n  if (state.vectorOverlayEnabled && state.vectorOverlayStage === vecStage) {\n    state.vectorOverlayEnabled = false;\n    state.vectorOverlayStage = null;\n    processSvgOverlay.style.display = \"none\";\n    updateVectorOverlayButtons();\n    showStatus(\"Vector overlay hidden\");\n    return;\n  }\n\n  // Check if we need to vectorize\n  let vectorized = state.vectorizedImages.get(vecStage);\n\n  if (!vectorized) {\n    // Vectorize on-demand\n    const skelStage = vecStage.replace(\"_vec\", \"_skel\") as ProcessingStage;\n    const skelImage = state.processedImages.get(skelStage);\n\n    if (!skelImage) {\n      showStatus(`Skeleton stage ${skelStage} not available`, true);\n      return;\n    }\n\n    // Convert skeleton to binary format if needed\n    let binaryImage: BinaryImage;\n    const expectedBinaryLength = Math.ceil(\n      skelImage.width * skelImage.height / 8,\n    );\n\n    if (\n      skelImage.data instanceof Uint8ClampedArray &&\n      skelImage.data.length === skelImage.width * skelImage.height * 4\n    ) {\n      console.log(`Converting ${skelStage} from RGBA to binary format`);\n      binaryImage = rgbaToBinary(skelImage as RGBAImage);\n    } else if (\n      skelImage.data instanceof Uint8Array &&\n      skelImage.data.length === expectedBinaryLength\n    ) {\n      binaryImage = skelImage as BinaryImage;\n    } else {\n      showStatus(`${skelStage} has unexpected format`, true);\n      return;\n    }\n\n    showStatus(`Vectorizing ${skelStage}...`);\n    const vectorizeStart = performance.now();\n    vectorized = vectorizeSkeleton(binaryImage);\n    state.vectorizedImages.set(vecStage, vectorized);\n    const vectorizeEnd = performance.now();\n    const totalPoints = vectorized.paths.reduce(\n      (sum, p) => sum + p.points.length,\n      0,\n    );\n    console.log(\n      `Vectorized: ${vectorized.paths.length} paths, ${totalPoints} points (${\n        (vectorizeEnd - vectorizeStart).toFixed(1)\n      }ms)`,\n    );\n  }\n\n  // Enable overlay\n  state.vectorOverlayEnabled = true;\n  state.vectorOverlayStage = vecStage;\n\n  // Render SVG overlay\n  const currentImage = state.processedImages.get(state.currentStage);\n  if (currentImage) {\n    renderVectorizedToSVG(\n      vectorized,\n      processSvgOverlay,\n      currentImage.width,\n      currentImage.height,\n    );\n    processSvgOverlay.style.display = \"block\";\n\n    // Ensure size is correct\n    processSvgOverlay.setAttribute(\"width\", currentImage.width.toString());\n    processSvgOverlay.setAttribute(\"height\", currentImage.height.toString());\n    processSvgOverlay.style.width = `${currentImage.width}px`;\n    processSvgOverlay.style.height = `${currentImage.height}px`;\n  }\n\n  updateVectorOverlayButtons();\n  const totalPoints = vectorized.paths.reduce(\n    (sum, p) => sum + p.points.length,\n    0,\n  );\n  showStatus(\n    `Vector overlay: ${vectorized.paths.length} paths, ${totalPoints} points`,\n  );\n}\n\nfunction updateVectorOverlayButtons() {\n  vectorOverlayContainer.querySelectorAll(\".stage-btn\").forEach((btn) => {\n    const btnStage = (btn as HTMLElement).dataset.stage;\n    if (btnStage === state.vectorOverlayStage && state.vectorOverlayEnabled) {\n      btn.classList.add(\"active\");\n    } else {\n      btn.classList.remove(\"active\");\n    }\n  });\n}\n\nfunction displayProcessingStage(stage: ProcessingStage) {\n  // Check if this is a vectorized stage\n  if (stage.endsWith(\"_vec\")) {\n    // Check if we already have it vectorized\n    let vectorized = state.vectorizedImages.get(stage);\n\n    if (!vectorized) {\n      // Need to vectorize on-demand\n      const skelStage = stage.replace(\"_vec\", \"_skel\") as ProcessingStage;\n      const skelImage = state.processedImages.get(skelStage);\n\n      if (!skelImage) {\n        showStatus(`Skeleton stage ${skelStage} not available`, true);\n        return;\n      }\n\n      // Convert skeleton to binary format if needed\n      let binaryImage: BinaryImage;\n      const expectedBinaryLength = Math.ceil(\n        skelImage.width * skelImage.height / 8,\n      );\n\n      if (\n        skelImage.data instanceof Uint8ClampedArray &&\n        skelImage.data.length === skelImage.width * skelImage.height * 4\n      ) {\n        // RGBA format - convert to binary\n        console.log(`Converting ${skelStage} from RGBA to binary format`);\n        binaryImage = rgbaToBinary(skelImage as RGBAImage);\n      } else if (\n        skelImage.data instanceof Uint8Array &&\n        skelImage.data.length === expectedBinaryLength\n      ) {\n        // Already binary format\n        binaryImage = skelImage as BinaryImage;\n      } else {\n        showStatus(`${skelStage} has unexpected format`, true);\n        console.error(`Unexpected format:`, {\n          dataType: skelImage.data?.constructor?.name,\n          actualLength: skelImage.data.length,\n          expectedRGBA: skelImage.width * skelImage.height * 4,\n          expectedBinary: expectedBinaryLength,\n        });\n        return;\n      }\n\n      // Vectorize now\n      showStatus(`Vectorizing ${skelStage}...`);\n      const vectorizeStart = performance.now();\n      vectorized = vectorizeSkeleton(binaryImage);\n      state.vectorizedImages.set(stage, vectorized);\n      const vectorizeEnd = performance.now();\n      const totalPoints = vectorized.paths.reduce(\n        (sum, p) => sum + p.points.length,\n        0,\n      );\n      showStatus(\n        `Vectorized: ${vectorized.paths.length} paths, ${totalPoints} points (${\n          (vectorizeEnd - vectorizeStart).toFixed(1)\n        }ms)`,\n      );\n    }\n\n    state.currentStage = stage;\n\n    // Update stage button states\n    document.querySelectorAll(\".stage-btn\").forEach((btn) =>\n      btn.classList.remove(\"active\")\n    );\n    const btn = Array.from(document.querySelectorAll(\".stage-btn\")).find(\n      (b) => (b as HTMLElement).dataset.stage === stage,\n    );\n    btn?.classList.add(\"active\");\n\n    // First, display the skeleton image on canvas\n    const skelStage = stage.replace(\"_vec\", \"_skel\") as ProcessingStage;\n    const skelImage = state.processedImages.get(skelStage);\n    if (skelImage) {\n      // Render skeleton to canvas\n      processCanvas.width = skelImage.width;\n      processCanvas.height = skelImage.height;\n\n      // Convert to RGBA for display\n      let rgbaData: Uint8ClampedArray;\n      if (\n        skelImage.data instanceof Uint8ClampedArray &&\n        skelImage.data.length === skelImage.width * skelImage.height * 4\n      ) {\n        rgbaData = skelImage.data;\n      } else {\n        // Convert binary to RGBA\n        const numPixels = skelImage.width * skelImage.height;\n        rgbaData = new Uint8ClampedArray(numPixels * 4);\n        for (let i = 0; i < numPixels; i++) {\n          const byteIndex = Math.floor(i / 8);\n          const bitIndex = 7 - (i % 8);\n          const bit = (skelImage.data[byteIndex] >> bitIndex) & 1;\n          const value = bit ? 0 : 255;\n          rgbaData[i * 4] = value;\n          rgbaData[i * 4 + 1] = value;\n          rgbaData[i * 4 + 2] = value;\n          rgbaData[i * 4 + 3] = 255;\n        }\n      }\n\n      const imageData = new ImageData(\n        rgbaData,\n        skelImage.width,\n        skelImage.height,\n      );\n      processCtx.putImageData(imageData, 0, 0);\n    }\n\n    // Then overlay the vectorized paths as SVG\n    renderVectorizedToSVG(vectorized, processSvgOverlay);\n\n    // Fit to screen on first display\n    if (!state.processViewInitialized) {\n      processFitToScreen();\n      state.processViewInitialized = true;\n    } else {\n      updateProcessTransform();\n    }\n\n    const totalPoints = vectorized.paths.reduce(\n      (sum, p) => sum + p.points.length,\n      0,\n    );\n    showStatus(\n      `Viewing: ${stage} (${vectorized.paths.length} paths, ${totalPoints} points)`,\n    );\n    return;\n  }\n\n  const image = state.processedImages.get(stage);\n  if (!image) {\n    showStatus(`Stage ${stage} not available`, true);\n    return;\n  }\n\n  state.currentStage = stage;\n\n  // Re-render vector overlay if it's enabled (over the new stage)\n  if (state.vectorOverlayEnabled && state.vectorOverlayStage) {\n    const vectorized = state.vectorizedImages.get(state.vectorOverlayStage);\n    if (vectorized) {\n      renderVectorizedToSVG(\n        vectorized,\n        processSvgOverlay,\n        image.width,\n        image.height,\n      );\n      processSvgOverlay.style.display = \"block\";\n    }\n  }\n\n  // Update stage button states\n  document.querySelectorAll(\".stage-btn\").forEach((btn) =>\n    btn.classList.remove(\"active\")\n  );\n\n  // Handle dynamic color stage buttons\n  if (typeof stage === \"string\" && (stage.startsWith(\"color_\"))) {\n    const btn = Array.from(document.querySelectorAll(\".stage-btn\")).find(\n      (b) =>\n        (b as HTMLElement).textContent?.toLowerCase().replace(\" \", \"_\")\n          .includes(stage),\n    );\n    btn?.classList.add(\"active\");\n  } else {\n    // Static stage buttons\n    const stageButtons: Partial<\n      Record<BaseProcessingStage, HTMLButtonElement>\n    > = {\n      cropped: stageCroppedBtn,\n      extract_black: stageExtractBlackBtn,\n      subtract_black: stageSubtractBlackBtn,\n      value: stageValueBtn,\n      saturation: stageSaturationBtn,\n      saturation_median: stageSaturationMedianBtn,\n      hue: stageHueBtn,\n      hue_median: stageHueMedianBtn,\n      cleanup: stageCleanupBtn,\n      palettized: stagePalettizedBtn,\n      median: stageMedianBtn,\n    };\n    const baseStage = stage as BaseProcessingStage;\n    stageButtons[baseStage]?.classList.add(\"active\");\n  }\n\n  // Set up canvas\n  processCanvas.width = image.width;\n  processCanvas.height = image.height;\n\n  // Set up SVG overlay size to match canvas\n  processSvgOverlay.setAttribute(\"width\", image.width.toString());\n  processSvgOverlay.setAttribute(\"height\", image.height.toString());\n  processSvgOverlay.style.width = `${image.width}px`;\n  processSvgOverlay.style.height = `${image.height}px`;\n\n  // Convert to RGBA for display\n  let rgbaData: Uint8ClampedArray;\n  if (\"palette\" in image && image.palette) {\n    // PalettizedImage - convert indexed colors to RGBA\n    // Palettized format stores 2 pixels per byte: high nibble (left) and low nibble (right)\n    const numPixels = image.width * image.height;\n    rgbaData = new Uint8ClampedArray(numPixels * 4);\n\n    for (let pixelIndex = 0; pixelIndex < numPixels; pixelIndex++) {\n      const byteIndex = Math.floor(pixelIndex / 2);\n      const isHighNibble = pixelIndex % 2 === 0;\n\n      // Extract 4-bit color index from nibble\n      const colorIndex = isHighNibble\n        ? (image.data[byteIndex] >> 4) & 0x0f\n        : image.data[byteIndex] & 0x0f;\n\n      // Look up RGBA color in palette (stored as Uint32Array - need to unpack)\n      const pixelOffset = pixelIndex * 4;\n      const packedColor = image.palette[colorIndex];\n\n      // Unpack RGBA from 32-bit value (little-endian: ABGR)\n      rgbaData[pixelOffset] = packedColor & 0xff; // R\n      rgbaData[pixelOffset + 1] = (packedColor >> 8) & 0xff; // G\n      rgbaData[pixelOffset + 2] = (packedColor >> 16) & 0xff; // B\n      rgbaData[pixelOffset + 3] = (packedColor >> 24) & 0xff; // A\n    }\n  } else if (\n    image.data instanceof Uint8Array &&\n    image.data.length === Math.ceil(image.width * image.height / 8)\n  ) {\n    // BinaryImage - convert bit-packed 1-bit to RGBA (0=white, 1=black)\n    rgbaData = new Uint8ClampedArray(image.width * image.height * 4);\n    for (let y = 0; y < image.height; y++) {\n      for (let x = 0; x < image.width; x++) {\n        const pixelIndex = y * image.width + x;\n        const byteIndex = Math.floor(pixelIndex / 8);\n        const bitIndex = 7 - (pixelIndex % 8); // MSB-first\n        const bitValue = (image.data[byteIndex] >> bitIndex) & 1;\n        const value = bitValue ? 0 : 255; // 1=black, 0=white\n        const offset = pixelIndex * 4;\n        rgbaData[offset] = value;\n        rgbaData[offset + 1] = value;\n        rgbaData[offset + 2] = value;\n        rgbaData[offset + 3] = 255;\n      }\n    }\n  } else {\n    // RGBAImage - use directly\n    rgbaData = new Uint8ClampedArray(image.data);\n  }\n\n  // Draw image - ensure it's a proper Uint8ClampedArray with ArrayBuffer\n  const displayData = new Uint8ClampedArray(rgbaData);\n  const imageData = new ImageData(\n    displayData,\n    image.width,\n    image.height,\n  );\n  processCtx.putImageData(imageData, 0, 0);\n\n  // Only fit to screen on first display, then preserve state.zoom/pan\n  if (!state.processViewInitialized) {\n    processFitToScreen();\n    state.processViewInitialized = true;\n  } else {\n    updateProcessTransform();\n  }\n\n  showStatus(`Viewing: ${stage} (${image.width}\u00D7${image.height})`);\n}\n\nfunction processFitToScreen() {\n  // Get dimensions from either processed image or vectorized image\n  let imageWidth = 0, imageHeight = 0;\n  const image = state.processedImages.get(state.currentStage);\n  if (image) {\n    imageWidth = image.width;\n    imageHeight = image.height;\n  } else if (state.currentStage.endsWith(\"_vec\")) {\n    const vectorized = state.vectorizedImages.get(state.currentStage);\n    if (vectorized) {\n      imageWidth = vectorized.width;\n      imageHeight = vectorized.height;\n    }\n  }\n\n  if (imageWidth === 0 || imageHeight === 0) return;\n\n  const containerWidth = processCanvasContainer.clientWidth;\n  const containerHeight = processCanvasContainer.clientHeight;\n\n  const scaleX = containerWidth / imageWidth;\n  const scaleY = containerHeight / imageHeight;\n  state.processZoom = Math.min(scaleX, scaleY) * 0.9;\n\n  state.processPanX = (containerWidth - imageWidth * state.processZoom) / 2;\n  state.processPanY = (containerHeight - imageHeight * state.processZoom) / 2;\n\n  updateProcessZoom();\n  updateProcessTransform();\n}\n\nfunction updateProcessZoom() {\n  processZoomLevel.textContent = `${Math.round(state.processZoom * 100)}%`;\n}\n\nfunction updateProcessTransform() {\n  const transform =\n    `translate(${state.processPanX}px, ${state.processPanY}px) scale(${state.processZoom})`;\n\n  if (processContent) {\n    processContent.style.transform = transform;\n    processContent.style.transformOrigin = \"0 0\";\n    processContent.style.willChange = \"transform\";\n  } else {\n    // Fallback if processContent is missing (shouldn't happen with new HTML)\n    processCanvas.style.transform = transform;\n    processCanvas.style.transformOrigin = \"0 0\";\n    processCanvas.style.willChange = \"transform\";\n    processSvgOverlay.style.transform = transform;\n    processSvgOverlay.style.transformOrigin = \"0 0\";\n    processSvgOverlay.style.willChange = \"transform\";\n  }\n\n  if (state.processZoom >= 1) {\n    processCanvas.style.imageRendering = \"pixelated\";\n  } else {\n    processCanvas.style.imageRendering = \"auto\";\n  }\n}\n\nfunction _displayResult(image: RGBAImage, label: string) {\n  const item = document.createElement(\"div\");\n  item.className = \"result-item\";\n\n  const title = document.createElement(\"h3\");\n  title.textContent = label;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = image.width;\n  canvas.height = image.height;\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    const imageData = new ImageData(\n      new Uint8ClampedArray(image.data),\n      image.width,\n      image.height,\n    );\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  const img = document.createElement(\"img\");\n  img.src = canvas.toDataURL();\n\n  item.appendChild(title);\n  item.appendChild(img);\n  resultsContainer.appendChild(item);\n}\n\nfunction generateThumbnail(image: RGBAImage): string {\n  const maxSize = 128; // Increased for better quality\n  const scale = Math.min(maxSize / image.width, maxSize / image.height);\n  const thumbWidth = Math.floor(image.width * scale);\n  const thumbHeight = Math.floor(image.height * scale);\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = thumbWidth;\n  canvas.height = thumbHeight;\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return \"\";\n\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.width = image.width;\n  tempCanvas.height = image.height;\n  const tempCtx = tempCanvas.getContext(\"2d\");\n  if (!tempCtx) return \"\";\n\n  const imageData = new ImageData(\n    new Uint8ClampedArray(image.data),\n    image.width,\n    image.height,\n  );\n  tempCtx.putImageData(imageData, 0, 0);\n\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = \"high\";\n  ctx.drawImage(tempCanvas, 0, 0, thumbWidth, thumbHeight);\n\n  return canvas.toDataURL(\"image/png\");\n}\n\n// File list management\nasync function refreshFileList() {\n  const files = await listFiles();\n\n  console.log(`Refreshing file list: ${files.length} files`);\n\n  if (files.length === 0) {\n    uploadFileList.innerHTML = `\n      <div class=\"upload-empty\">\n        <div>\uD83D\uDCC1</div>\n        <div>No files yet</div>\n      </div>\n    `;\n    return;\n  }\n\n  uploadFileList.innerHTML = `<div class=\"files-grid\"></div>`;\n  const filesGrid = uploadFileList.querySelector(\n    \".files-grid\",\n  ) as HTMLDivElement;\n\n  for (const file of files) {\n    const item = document.createElement(\"div\");\n    item.className = \"file-card\";\n    if (file.id === state.currentFileId) {\n      item.classList.add(\"active\");\n    }\n\n    const thumbnail = document.createElement(\"div\");\n    thumbnail.className = \"file-thumbnail\";\n    if (file.thumbnail) {\n      const img = document.createElement(\"img\");\n      img.src = file.thumbnail;\n      thumbnail.appendChild(img);\n    } else {\n      thumbnail.textContent = file.type.includes(\"pdf\") ? \"\uD83D\uDCC4\" : \"\uD83D\uDDBC\uFE0F\";\n    }\n\n    const info = document.createElement(\"div\");\n    info.className = \"file-info\";\n\n    const name = document.createElement(\"div\");\n    name.className = \"file-name\";\n    name.textContent = file.name;\n    name.title = file.name;\n\n    const meta = document.createElement(\"div\");\n    meta.className = \"file-meta\";\n    const date = new Date(file.uploadedAt);\n    const size = (file.data.length / 1024).toFixed(0);\n    meta.textContent = `${size} KB \u2022 ${date.toLocaleDateString()}`;\n\n    info.appendChild(name);\n    info.appendChild(meta);\n\n    const deleteBtn = document.createElement(\"button\");\n    deleteBtn.className = \"file-delete\";\n    deleteBtn.textContent = \"\u00D7\";\n    deleteBtn.title = \"Delete file\";\n    deleteBtn.onclick = async (e) => {\n      e.stopPropagation();\n      if (confirm(`Delete ${file.name}?`)) {\n        await deleteFile(file.id);\n        if (file.id === state.currentFileId) {\n          state.currentFileId = null;\n          state.currentPdfData = null;\n          state.currentImage = null;\n          setMode(\"upload\");\n        }\n        await refreshFileList();\n        showStatus(`Deleted ${file.name}`);\n      }\n    };\n\n    item.appendChild(thumbnail);\n    item.appendChild(info);\n    item.appendChild(deleteBtn);\n\n    item.onclick = () => loadStoredFile(file.id);\n\n    filesGrid.appendChild(item);\n  }\n}\n\nasync function loadStoredFile(id: string) {\n  showStatus(\"\u23F3 Loading file...\");\n\n  const stored = await getFile(id);\n  if (!stored) {\n    showStatus(\"File not found\", true);\n    return;\n  }\n\n  state.currentFileId = id;\n\n  // Restore palette if saved, otherwise load default\n  if (stored.palette) {\n    try {\n      const savedPalette = JSON.parse(stored.palette);\n      state.userPalette.length = 0;\n      state.userPalette.push(...savedPalette);\n      renderPaletteUI();\n      console.log(\"Restored saved palette with\", savedPalette.length, \"colors\");\n    } catch (err) {\n      console.error(\"Failed to restore palette:\", err);\n      await loadDefaultPalette();\n    }\n  } else {\n    // No saved palette, load default\n    await loadDefaultPalette();\n  }\n\n  const data = new Uint8Array(stored.data);\n  const blob = new Blob([data], { type: stored.type });\n  const file = new File([blob], stored.name, { type: stored.type });\n\n  await refreshFileList();\n  await handleFileUpload(file);\n}\n\n// Palette Editor Functions\n\n// Color Editor Panel - opens when clicking a palette color\n\n// Convert state.userPalette to RGBA format for GPU processing\n\n// Palette editor event handlers\nconsole.log(\"Setting up palette event listeners...\");\nif (addPaletteColorBtn) {\n  addPaletteColorBtn.addEventListener(\"click\", () => {\n    console.log(\"Add button clicked!\");\n    addPaletteColor();\n  });\n} else {\n  console.error(\"addPaletteColorBtn not found!\");\n}\n\nif (resetPaletteBtn) {\n  resetPaletteBtn.addEventListener(\"click\", () => {\n    console.log(\"Reset button clicked!\");\n    resetPaletteToDefault();\n  });\n} else {\n  console.error(\"resetPaletteBtn not found!\");\n}\n\nif (savePaletteBtn) {\n  savePaletteBtn.addEventListener(\"click\", () => {\n    const name = paletteName.value;\n    savePalette(name);\n  });\n}\n\nif (loadPaletteBtn) {\n  loadPaletteBtn.addEventListener(\"click\", () => {\n    loadPalette();\n  });\n}\n\nif (setDefaultPaletteBtn) {\n  setDefaultPaletteBtn.addEventListener(\"click\", () => {\n    setDefaultPalette();\n  });\n}\n\n// Canvas click handler for eyedropper\nmainCanvas.addEventListener(\"click\", (e: MouseEvent) => {\n  if (isEyedropperActive()) {\n    pickColorFromCanvas(e.clientX, e.clientY);\n  }\n});\n\n// ESC key to cancel eyedropper\ndocument.addEventListener(\"keydown\", (e: KeyboardEvent) => {\n  if (e.key === \"Escape\" && isEyedropperActive()) {\n    forceDeactivateEyedropper();\n  }\n});\n\n// Initialize palette UI on load\nrenderPaletteUI();\n"],
  "mappings": "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",
  "names": ["ctx", "pdfjsLib", "scale", "shaderCode", "shaderCode", "shaderCode", "shaderCode", "db", "db", "center", "radius", "canvasContainer", "mainCanvas", "ctx", "cropOverlay", "cropCtx", "zoomLevel", "cropInfo", "totalPoints", "skelStage", "skelImage", "btn", "rgbaData", "imageData", "scale", "ctx", "mainCanvas"]
}
